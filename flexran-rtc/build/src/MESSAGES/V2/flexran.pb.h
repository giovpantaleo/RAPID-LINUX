// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flexran.proto

#ifndef PROTOBUF_flexran_2eproto__INCLUDED
#define PROTOBUF_flexran_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "stats_messages.pb.h"
#include "header.pb.h"
#include "time_common.pb.h"
#include "config_messages.pb.h"
#include "controller_commands.pb.h"
#include "config_common.pb.h"
// @@protoc_insertion_point(includes)
namespace protocol {
class flex_a1_event;
class flex_a1_eventDefaultTypeInternal;
extern flex_a1_eventDefaultTypeInternal _flex_a1_event_default_instance_;
class flex_a2_event;
class flex_a2_eventDefaultTypeInternal;
extern flex_a2_eventDefaultTypeInternal _flex_a2_event_default_instance_;
class flex_a3_event;
class flex_a3_eventDefaultTypeInternal;
extern flex_a3_eventDefaultTypeInternal _flex_a3_event_default_instance_;
class flex_a4_event;
class flex_a4_eventDefaultTypeInternal;
extern flex_a4_eventDefaultTypeInternal _flex_a4_event_default_instance_;
class flex_a5_event;
class flex_a5_eventDefaultTypeInternal;
extern flex_a5_eventDefaultTypeInternal _flex_a5_event_default_instance_;
class flex_agent_reconfiguration;
class flex_agent_reconfigurationDefaultTypeInternal;
extern flex_agent_reconfigurationDefaultTypeInternal _flex_agent_reconfiguration_default_instance_;
class flex_cell_config;
class flex_cell_configDefaultTypeInternal;
extern flex_cell_configDefaultTypeInternal _flex_cell_config_default_instance_;
class flex_cell_stats_report;
class flex_cell_stats_reportDefaultTypeInternal;
extern flex_cell_stats_reportDefaultTypeInternal _flex_cell_stats_report_default_instance_;
class flex_cell_stats_request;
class flex_cell_stats_requestDefaultTypeInternal;
extern flex_cell_stats_requestDefaultTypeInternal _flex_cell_stats_request_default_instance_;
class flex_complete_stats_request;
class flex_complete_stats_requestDefaultTypeInternal;
extern flex_complete_stats_requestDefaultTypeInternal _flex_complete_stats_request_default_instance_;
class flex_complete_stats_request_repeated;
class flex_complete_stats_request_repeatedDefaultTypeInternal;
extern flex_complete_stats_request_repeatedDefaultTypeInternal _flex_complete_stats_request_repeated_default_instance_;
class flex_control_delegation;
class flex_control_delegationDefaultTypeInternal;
extern flex_control_delegationDefaultTypeInternal _flex_control_delegation_default_instance_;
class flex_cqi_config;
class flex_cqi_configDefaultTypeInternal;
extern flex_cqi_configDefaultTypeInternal _flex_cqi_config_default_instance_;
class flex_disconnect;
class flex_disconnectDefaultTypeInternal;
extern flex_disconnectDefaultTypeInternal _flex_disconnect_default_instance_;
class flex_dl_broadcast;
class flex_dl_broadcastDefaultTypeInternal;
extern flex_dl_broadcastDefaultTypeInternal _flex_dl_broadcast_default_instance_;
class flex_dl_data;
class flex_dl_dataDefaultTypeInternal;
extern flex_dl_dataDefaultTypeInternal _flex_dl_data_default_instance_;
class flex_dl_info;
class flex_dl_infoDefaultTypeInternal;
extern flex_dl_infoDefaultTypeInternal _flex_dl_info_default_instance_;
class flex_dl_mac_config;
class flex_dl_mac_configDefaultTypeInternal;
extern flex_dl_mac_configDefaultTypeInternal _flex_dl_mac_config_default_instance_;
class flex_dl_rar;
class flex_dl_rarDefaultTypeInternal;
extern flex_dl_rarDefaultTypeInternal _flex_dl_rar_default_instance_;
class flex_drx_config;
class flex_drx_configDefaultTypeInternal;
extern flex_drx_configDefaultTypeInternal _flex_drx_config_default_instance_;
class flex_echo_reply;
class flex_echo_replyDefaultTypeInternal;
extern flex_echo_replyDefaultTypeInternal _flex_echo_reply_default_instance_;
class flex_echo_reply_latency;
class flex_echo_reply_latencyDefaultTypeInternal;
extern flex_echo_reply_latencyDefaultTypeInternal _flex_echo_reply_latency_default_instance_;
class flex_echo_request;
class flex_echo_requestDefaultTypeInternal;
extern flex_echo_requestDefaultTypeInternal _flex_echo_request_default_instance_;
class flex_echo_request_latency;
class flex_echo_request_latencyDefaultTypeInternal;
extern flex_echo_request_latencyDefaultTypeInternal _flex_echo_request_latency_default_instance_;
class flex_enb_config_reply;
class flex_enb_config_replyDefaultTypeInternal;
extern flex_enb_config_replyDefaultTypeInternal _flex_enb_config_reply_default_instance_;
class flex_enb_config_request;
class flex_enb_config_requestDefaultTypeInternal;
extern flex_enb_config_requestDefaultTypeInternal _flex_enb_config_request_default_instance_;
class flex_gummei;
class flex_gummeiDefaultTypeInternal;
extern flex_gummeiDefaultTypeInternal _flex_gummei_default_instance_;
class flex_header;
class flex_headerDefaultTypeInternal;
extern flex_headerDefaultTypeInternal _flex_header_default_instance_;
class flex_hello;
class flex_helloDefaultTypeInternal;
extern flex_helloDefaultTypeInternal _flex_hello_default_instance_;
class flex_ho_command;
class flex_ho_commandDefaultTypeInternal;
extern flex_ho_commandDefaultTypeInternal _flex_ho_command_default_instance_;
class flex_lc_config;
class flex_lc_configDefaultTypeInternal;
extern flex_lc_configDefaultTypeInternal _flex_lc_config_default_instance_;
class flex_lc_config_reply;
class flex_lc_config_replyDefaultTypeInternal;
extern flex_lc_config_replyDefaultTypeInternal _flex_lc_config_reply_default_instance_;
class flex_lc_config_request;
class flex_lc_config_requestDefaultTypeInternal;
extern flex_lc_config_requestDefaultTypeInternal _flex_lc_config_request_default_instance_;
class flex_lc_ue_config;
class flex_lc_ue_configDefaultTypeInternal;
extern flex_lc_ue_configDefaultTypeInternal _flex_lc_ue_config_default_instance_;
class flex_measurement_event;
class flex_measurement_eventDefaultTypeInternal;
extern flex_measurement_eventDefaultTypeInternal _flex_measurement_event_default_instance_;
class flex_measurement_info;
class flex_measurement_infoDefaultTypeInternal;
extern flex_measurement_infoDefaultTypeInternal _flex_measurement_info_default_instance_;
class flex_pdcch_ofdm_sym_count;
class flex_pdcch_ofdm_sym_countDefaultTypeInternal;
extern flex_pdcch_ofdm_sym_countDefaultTypeInternal _flex_pdcch_ofdm_sym_count_default_instance_;
class flex_per_event;
class flex_per_eventDefaultTypeInternal;
extern flex_per_eventDefaultTypeInternal _flex_per_event_default_instance_;
class flex_plmn;
class flex_plmnDefaultTypeInternal;
extern flex_plmnDefaultTypeInternal _flex_plmn_default_instance_;
class flex_rrc_triggering;
class flex_rrc_triggeringDefaultTypeInternal;
extern flex_rrc_triggeringDefaultTypeInternal _flex_rrc_triggering_default_instance_;
class flex_s1ap_config;
class flex_s1ap_configDefaultTypeInternal;
extern flex_s1ap_configDefaultTypeInternal _flex_s1ap_config_default_instance_;
class flex_s1ap_mme;
class flex_s1ap_mmeDefaultTypeInternal;
extern flex_s1ap_mmeDefaultTypeInternal _flex_s1ap_mme_default_instance_;
class flex_scell_config;
class flex_scell_configDefaultTypeInternal;
extern flex_scell_configDefaultTypeInternal _flex_scell_config_default_instance_;
class flex_sf_trigger;
class flex_sf_triggerDefaultTypeInternal;
extern flex_sf_triggerDefaultTypeInternal _flex_sf_trigger_default_instance_;
class flex_si_config;
class flex_si_configDefaultTypeInternal;
extern flex_si_configDefaultTypeInternal _flex_si_config_default_instance_;
class flex_si_message;
class flex_si_messageDefaultTypeInternal;
extern flex_si_messageDefaultTypeInternal _flex_si_message_default_instance_;
class flex_slice;
class flex_sliceDefaultTypeInternal;
extern flex_sliceDefaultTypeInternal _flex_slice_default_instance_;
class flex_slice_config;
class flex_slice_configDefaultTypeInternal;
extern flex_slice_configDefaultTypeInternal _flex_slice_config_default_instance_;
class flex_slice_dl_ul_config;
class flex_slice_dl_ul_configDefaultTypeInternal;
extern flex_slice_dl_ul_configDefaultTypeInternal _flex_slice_dl_ul_config_default_instance_;
class flex_slice_static;
class flex_slice_staticDefaultTypeInternal;
extern flex_slice_staticDefaultTypeInternal _flex_slice_static_default_instance_;
class flex_sps_config;
class flex_sps_configDefaultTypeInternal;
extern flex_sps_configDefaultTypeInternal _flex_sps_config_default_instance_;
class flex_sr_config;
class flex_sr_configDefaultTypeInternal;
extern flex_sr_configDefaultTypeInternal _flex_sr_config_default_instance_;
class flex_stats_reply;
class flex_stats_replyDefaultTypeInternal;
extern flex_stats_replyDefaultTypeInternal _flex_stats_reply_default_instance_;
class flex_stats_request;
class flex_stats_requestDefaultTypeInternal;
extern flex_stats_requestDefaultTypeInternal _flex_stats_request_default_instance_;
class flex_ue_capabilities;
class flex_ue_capabilitiesDefaultTypeInternal;
extern flex_ue_capabilitiesDefaultTypeInternal _flex_ue_capabilities_default_instance_;
class flex_ue_config;
class flex_ue_configDefaultTypeInternal;
extern flex_ue_configDefaultTypeInternal _flex_ue_config_default_instance_;
class flex_ue_config_reply;
class flex_ue_config_replyDefaultTypeInternal;
extern flex_ue_config_replyDefaultTypeInternal _flex_ue_config_reply_default_instance_;
class flex_ue_config_request;
class flex_ue_config_requestDefaultTypeInternal;
extern flex_ue_config_requestDefaultTypeInternal _flex_ue_config_request_default_instance_;
class flex_ue_state_change;
class flex_ue_state_changeDefaultTypeInternal;
extern flex_ue_state_changeDefaultTypeInternal _flex_ue_state_change_default_instance_;
class flex_ue_stats_report;
class flex_ue_stats_reportDefaultTypeInternal;
extern flex_ue_stats_reportDefaultTypeInternal _flex_ue_stats_report_default_instance_;
class flex_ue_stats_request;
class flex_ue_stats_requestDefaultTypeInternal;
extern flex_ue_stats_requestDefaultTypeInternal _flex_ue_stats_request_default_instance_;
class flex_ul_data;
class flex_ul_dataDefaultTypeInternal;
extern flex_ul_dataDefaultTypeInternal _flex_ul_data_default_instance_;
class flex_ul_info;
class flex_ul_infoDefaultTypeInternal;
extern flex_ul_infoDefaultTypeInternal _flex_ul_info_default_instance_;
class flex_ul_mac_config;
class flex_ul_mac_configDefaultTypeInternal;
extern flex_ul_mac_configDefaultTypeInternal _flex_ul_mac_config_default_instance_;
class flex_ul_sr_info;
class flex_ul_sr_infoDefaultTypeInternal;
extern flex_ul_sr_infoDefaultTypeInternal _flex_ul_sr_info_default_instance_;
class flexran_message;
class flexran_messageDefaultTypeInternal;
extern flexran_messageDefaultTypeInternal _flexran_message_default_instance_;
}  // namespace protocol

namespace protocol {

namespace protobuf_flexran_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_flexran_2eproto

enum flexran_direction {
  NOT_SET = 0,
  INITIATING_MESSAGE = 1,
  SUCCESSFUL_OUTCOME = 2,
  UNSUCCESSFUL_OUTCOME = 3
};
bool flexran_direction_IsValid(int value);
const flexran_direction flexran_direction_MIN = NOT_SET;
const flexran_direction flexran_direction_MAX = UNSUCCESSFUL_OUTCOME;
const int flexran_direction_ARRAYSIZE = flexran_direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* flexran_direction_descriptor();
inline const ::std::string& flexran_direction_Name(flexran_direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    flexran_direction_descriptor(), value);
}
inline bool flexran_direction_Parse(
    const ::std::string& name, flexran_direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flexran_direction>(
    flexran_direction_descriptor(), name, value);
}
enum flexran_err {
  NO_ERR = 0,
  MSG_DEQUEUING = -1,
  MSG_ENQUEUING = -2,
  MSG_DECODING = -3,
  MSG_ENCODING = -4,
  MSG_BUILD = -5,
  MSG_NOT_SUPPORTED = -6,
  MSG_NOT_HANDLED = -7,
  MSG_NOT_VALIDATED = -8,
  MSG_OUT_DATED = -9,
  UNEXPECTED = -100
};
bool flexran_err_IsValid(int value);
const flexran_err flexran_err_MIN = UNEXPECTED;
const flexran_err flexran_err_MAX = NO_ERR;
const int flexran_err_ARRAYSIZE = flexran_err_MAX + 1;

const ::google::protobuf::EnumDescriptor* flexran_err_descriptor();
inline const ::std::string& flexran_err_Name(flexran_err value) {
  return ::google::protobuf::internal::NameOfEnum(
    flexran_err_descriptor(), value);
}
inline bool flexran_err_Parse(
    const ::std::string& name, flexran_err* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flexran_err>(
    flexran_err_descriptor(), name, value);
}
enum flex_bs_capability {
  LOPHY = 0,
  HIPHY = 1,
  LOMAC = 2,
  HIMAC = 3,
  RLC = 4,
  PDCP = 5,
  SDAP = 6,
  RRC = 7,
  S1AP = 8
};
bool flex_bs_capability_IsValid(int value);
const flex_bs_capability flex_bs_capability_MIN = LOPHY;
const flex_bs_capability flex_bs_capability_MAX = S1AP;
const int flex_bs_capability_ARRAYSIZE = flex_bs_capability_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_bs_capability_descriptor();
inline const ::std::string& flex_bs_capability_Name(flex_bs_capability value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_bs_capability_descriptor(), value);
}
inline bool flex_bs_capability_Parse(
    const ::std::string& name, flex_bs_capability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_bs_capability>(
    flex_bs_capability_descriptor(), name, value);
}
enum flex_bs_split {
  F1 = 0,
  nFAPI = 1,
  IF4 = 2,
  IF4p5 = 3,
  IF5 = 4
};
bool flex_bs_split_IsValid(int value);
const flex_bs_split flex_bs_split_MIN = F1;
const flex_bs_split flex_bs_split_MAX = IF5;
const int flex_bs_split_ARRAYSIZE = flex_bs_split_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_bs_split_descriptor();
inline const ::std::string& flex_bs_split_Name(flex_bs_split value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_bs_split_descriptor(), value);
}
inline bool flex_bs_split_Parse(
    const ::std::string& name, flex_bs_split* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_bs_split>(
    flex_bs_split_descriptor(), name, value);
}
// ===================================================================

class flexran_message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flexran_message) */ {
 public:
  flexran_message();
  virtual ~flexran_message();

  flexran_message(const flexran_message& from);

  inline flexran_message& operator=(const flexran_message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flexran_message& default_instance();

  enum MsgCase {
    kHelloMsg = 1,
    kEchoRequestMsg = 2,
    kEchoReplyMsg = 3,
    kStatsRequestMsg = 4,
    kStatsReplyMsg = 5,
    kSfTriggerMsg = 6,
    kUlSrInfoMsg = 7,
    kEnbConfigRequestMsg = 8,
    kEnbConfigReplyMsg = 9,
    kUeConfigRequestMsg = 10,
    kUeConfigReplyMsg = 11,
    kLcConfigRequestMsg = 12,
    kLcConfigReplyMsg = 13,
    kDlMacConfigMsg = 14,
    kUeStateChangeMsg = 15,
    kControlDelegationMsg = 16,
    kAgentReconfigurationMsg = 17,
    kRrcTriggering = 18,
    kUlMacConfigMsg = 19,
    kDisconnectMsg = 20,
    kHoCommand = 21,
    MSG_NOT_SET = 0,
  };

  static inline const flexran_message* internal_default_instance() {
    return reinterpret_cast<const flexran_message*>(
               &_flexran_message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(flexran_message* other);

  // implements Message ----------------------------------------------

  inline flexran_message* New() const PROTOBUF_FINAL { return New(NULL); }

  flexran_message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flexran_message& from);
  void MergeFrom(const flexran_message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flexran_message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flexran_direction msg_dir = 100;
  bool has_msg_dir() const;
  void clear_msg_dir();
  static const int kMsgDirFieldNumber = 100;
  ::protocol::flexran_direction msg_dir() const;
  void set_msg_dir(::protocol::flexran_direction value);

  // optional .protocol.flex_hello hello_msg = 1;
  bool has_hello_msg() const;
  void clear_hello_msg();
  static const int kHelloMsgFieldNumber = 1;
  const ::protocol::flex_hello& hello_msg() const;
  ::protocol::flex_hello* mutable_hello_msg();
  ::protocol::flex_hello* release_hello_msg();
  void set_allocated_hello_msg(::protocol::flex_hello* hello_msg);

  // optional .protocol.flex_echo_request echo_request_msg = 2;
  bool has_echo_request_msg() const;
  void clear_echo_request_msg();
  static const int kEchoRequestMsgFieldNumber = 2;
  const ::protocol::flex_echo_request& echo_request_msg() const;
  ::protocol::flex_echo_request* mutable_echo_request_msg();
  ::protocol::flex_echo_request* release_echo_request_msg();
  void set_allocated_echo_request_msg(::protocol::flex_echo_request* echo_request_msg);

  // optional .protocol.flex_echo_reply echo_reply_msg = 3;
  bool has_echo_reply_msg() const;
  void clear_echo_reply_msg();
  static const int kEchoReplyMsgFieldNumber = 3;
  const ::protocol::flex_echo_reply& echo_reply_msg() const;
  ::protocol::flex_echo_reply* mutable_echo_reply_msg();
  ::protocol::flex_echo_reply* release_echo_reply_msg();
  void set_allocated_echo_reply_msg(::protocol::flex_echo_reply* echo_reply_msg);

  // optional .protocol.flex_stats_request stats_request_msg = 4;
  bool has_stats_request_msg() const;
  void clear_stats_request_msg();
  static const int kStatsRequestMsgFieldNumber = 4;
  const ::protocol::flex_stats_request& stats_request_msg() const;
  ::protocol::flex_stats_request* mutable_stats_request_msg();
  ::protocol::flex_stats_request* release_stats_request_msg();
  void set_allocated_stats_request_msg(::protocol::flex_stats_request* stats_request_msg);

  // optional .protocol.flex_stats_reply stats_reply_msg = 5;
  bool has_stats_reply_msg() const;
  void clear_stats_reply_msg();
  static const int kStatsReplyMsgFieldNumber = 5;
  const ::protocol::flex_stats_reply& stats_reply_msg() const;
  ::protocol::flex_stats_reply* mutable_stats_reply_msg();
  ::protocol::flex_stats_reply* release_stats_reply_msg();
  void set_allocated_stats_reply_msg(::protocol::flex_stats_reply* stats_reply_msg);

  // optional .protocol.flex_sf_trigger sf_trigger_msg = 6;
  bool has_sf_trigger_msg() const;
  void clear_sf_trigger_msg();
  static const int kSfTriggerMsgFieldNumber = 6;
  const ::protocol::flex_sf_trigger& sf_trigger_msg() const;
  ::protocol::flex_sf_trigger* mutable_sf_trigger_msg();
  ::protocol::flex_sf_trigger* release_sf_trigger_msg();
  void set_allocated_sf_trigger_msg(::protocol::flex_sf_trigger* sf_trigger_msg);

  // optional .protocol.flex_ul_sr_info ul_sr_info_msg = 7;
  bool has_ul_sr_info_msg() const;
  void clear_ul_sr_info_msg();
  static const int kUlSrInfoMsgFieldNumber = 7;
  const ::protocol::flex_ul_sr_info& ul_sr_info_msg() const;
  ::protocol::flex_ul_sr_info* mutable_ul_sr_info_msg();
  ::protocol::flex_ul_sr_info* release_ul_sr_info_msg();
  void set_allocated_ul_sr_info_msg(::protocol::flex_ul_sr_info* ul_sr_info_msg);

  // optional .protocol.flex_enb_config_request enb_config_request_msg = 8;
  bool has_enb_config_request_msg() const;
  void clear_enb_config_request_msg();
  static const int kEnbConfigRequestMsgFieldNumber = 8;
  const ::protocol::flex_enb_config_request& enb_config_request_msg() const;
  ::protocol::flex_enb_config_request* mutable_enb_config_request_msg();
  ::protocol::flex_enb_config_request* release_enb_config_request_msg();
  void set_allocated_enb_config_request_msg(::protocol::flex_enb_config_request* enb_config_request_msg);

  // optional .protocol.flex_enb_config_reply enb_config_reply_msg = 9;
  bool has_enb_config_reply_msg() const;
  void clear_enb_config_reply_msg();
  static const int kEnbConfigReplyMsgFieldNumber = 9;
  const ::protocol::flex_enb_config_reply& enb_config_reply_msg() const;
  ::protocol::flex_enb_config_reply* mutable_enb_config_reply_msg();
  ::protocol::flex_enb_config_reply* release_enb_config_reply_msg();
  void set_allocated_enb_config_reply_msg(::protocol::flex_enb_config_reply* enb_config_reply_msg);

  // optional .protocol.flex_ue_config_request ue_config_request_msg = 10;
  bool has_ue_config_request_msg() const;
  void clear_ue_config_request_msg();
  static const int kUeConfigRequestMsgFieldNumber = 10;
  const ::protocol::flex_ue_config_request& ue_config_request_msg() const;
  ::protocol::flex_ue_config_request* mutable_ue_config_request_msg();
  ::protocol::flex_ue_config_request* release_ue_config_request_msg();
  void set_allocated_ue_config_request_msg(::protocol::flex_ue_config_request* ue_config_request_msg);

  // optional .protocol.flex_ue_config_reply ue_config_reply_msg = 11;
  bool has_ue_config_reply_msg() const;
  void clear_ue_config_reply_msg();
  static const int kUeConfigReplyMsgFieldNumber = 11;
  const ::protocol::flex_ue_config_reply& ue_config_reply_msg() const;
  ::protocol::flex_ue_config_reply* mutable_ue_config_reply_msg();
  ::protocol::flex_ue_config_reply* release_ue_config_reply_msg();
  void set_allocated_ue_config_reply_msg(::protocol::flex_ue_config_reply* ue_config_reply_msg);

  // optional .protocol.flex_lc_config_request lc_config_request_msg = 12;
  bool has_lc_config_request_msg() const;
  void clear_lc_config_request_msg();
  static const int kLcConfigRequestMsgFieldNumber = 12;
  const ::protocol::flex_lc_config_request& lc_config_request_msg() const;
  ::protocol::flex_lc_config_request* mutable_lc_config_request_msg();
  ::protocol::flex_lc_config_request* release_lc_config_request_msg();
  void set_allocated_lc_config_request_msg(::protocol::flex_lc_config_request* lc_config_request_msg);

  // optional .protocol.flex_lc_config_reply lc_config_reply_msg = 13;
  bool has_lc_config_reply_msg() const;
  void clear_lc_config_reply_msg();
  static const int kLcConfigReplyMsgFieldNumber = 13;
  const ::protocol::flex_lc_config_reply& lc_config_reply_msg() const;
  ::protocol::flex_lc_config_reply* mutable_lc_config_reply_msg();
  ::protocol::flex_lc_config_reply* release_lc_config_reply_msg();
  void set_allocated_lc_config_reply_msg(::protocol::flex_lc_config_reply* lc_config_reply_msg);

  // optional .protocol.flex_dl_mac_config dl_mac_config_msg = 14;
  bool has_dl_mac_config_msg() const;
  void clear_dl_mac_config_msg();
  static const int kDlMacConfigMsgFieldNumber = 14;
  const ::protocol::flex_dl_mac_config& dl_mac_config_msg() const;
  ::protocol::flex_dl_mac_config* mutable_dl_mac_config_msg();
  ::protocol::flex_dl_mac_config* release_dl_mac_config_msg();
  void set_allocated_dl_mac_config_msg(::protocol::flex_dl_mac_config* dl_mac_config_msg);

  // optional .protocol.flex_ue_state_change ue_state_change_msg = 15;
  bool has_ue_state_change_msg() const;
  void clear_ue_state_change_msg();
  static const int kUeStateChangeMsgFieldNumber = 15;
  const ::protocol::flex_ue_state_change& ue_state_change_msg() const;
  ::protocol::flex_ue_state_change* mutable_ue_state_change_msg();
  ::protocol::flex_ue_state_change* release_ue_state_change_msg();
  void set_allocated_ue_state_change_msg(::protocol::flex_ue_state_change* ue_state_change_msg);

  // optional .protocol.flex_control_delegation control_delegation_msg = 16;
  bool has_control_delegation_msg() const;
  void clear_control_delegation_msg();
  static const int kControlDelegationMsgFieldNumber = 16;
  const ::protocol::flex_control_delegation& control_delegation_msg() const;
  ::protocol::flex_control_delegation* mutable_control_delegation_msg();
  ::protocol::flex_control_delegation* release_control_delegation_msg();
  void set_allocated_control_delegation_msg(::protocol::flex_control_delegation* control_delegation_msg);

  // optional .protocol.flex_agent_reconfiguration agent_reconfiguration_msg = 17;
  bool has_agent_reconfiguration_msg() const;
  void clear_agent_reconfiguration_msg();
  static const int kAgentReconfigurationMsgFieldNumber = 17;
  const ::protocol::flex_agent_reconfiguration& agent_reconfiguration_msg() const;
  ::protocol::flex_agent_reconfiguration* mutable_agent_reconfiguration_msg();
  ::protocol::flex_agent_reconfiguration* release_agent_reconfiguration_msg();
  void set_allocated_agent_reconfiguration_msg(::protocol::flex_agent_reconfiguration* agent_reconfiguration_msg);

  // optional .protocol.flex_rrc_triggering rrc_triggering = 18;
  bool has_rrc_triggering() const;
  void clear_rrc_triggering();
  static const int kRrcTriggeringFieldNumber = 18;
  const ::protocol::flex_rrc_triggering& rrc_triggering() const;
  ::protocol::flex_rrc_triggering* mutable_rrc_triggering();
  ::protocol::flex_rrc_triggering* release_rrc_triggering();
  void set_allocated_rrc_triggering(::protocol::flex_rrc_triggering* rrc_triggering);

  // optional .protocol.flex_ul_mac_config ul_mac_config_msg = 19;
  bool has_ul_mac_config_msg() const;
  void clear_ul_mac_config_msg();
  static const int kUlMacConfigMsgFieldNumber = 19;
  const ::protocol::flex_ul_mac_config& ul_mac_config_msg() const;
  ::protocol::flex_ul_mac_config* mutable_ul_mac_config_msg();
  ::protocol::flex_ul_mac_config* release_ul_mac_config_msg();
  void set_allocated_ul_mac_config_msg(::protocol::flex_ul_mac_config* ul_mac_config_msg);

  // optional .protocol.flex_disconnect disconnect_msg = 20;
  bool has_disconnect_msg() const;
  void clear_disconnect_msg();
  static const int kDisconnectMsgFieldNumber = 20;
  const ::protocol::flex_disconnect& disconnect_msg() const;
  ::protocol::flex_disconnect* mutable_disconnect_msg();
  ::protocol::flex_disconnect* release_disconnect_msg();
  void set_allocated_disconnect_msg(::protocol::flex_disconnect* disconnect_msg);

  // optional .protocol.flex_ho_command ho_command = 21;
  bool has_ho_command() const;
  void clear_ho_command();
  static const int kHoCommandFieldNumber = 21;
  const ::protocol::flex_ho_command& ho_command() const;
  ::protocol::flex_ho_command* mutable_ho_command();
  ::protocol::flex_ho_command* release_ho_command();
  void set_allocated_ho_command(::protocol::flex_ho_command* ho_command);

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:protocol.flexran_message)
 private:
  void set_has_msg_dir();
  void clear_has_msg_dir();
  void set_has_hello_msg();
  void set_has_echo_request_msg();
  void set_has_echo_reply_msg();
  void set_has_stats_request_msg();
  void set_has_stats_reply_msg();
  void set_has_sf_trigger_msg();
  void set_has_ul_sr_info_msg();
  void set_has_enb_config_request_msg();
  void set_has_enb_config_reply_msg();
  void set_has_ue_config_request_msg();
  void set_has_ue_config_reply_msg();
  void set_has_lc_config_request_msg();
  void set_has_lc_config_reply_msg();
  void set_has_dl_mac_config_msg();
  void set_has_ue_state_change_msg();
  void set_has_control_delegation_msg();
  void set_has_agent_reconfiguration_msg();
  void set_has_rrc_triggering();
  void set_has_ul_mac_config_msg();
  void set_has_disconnect_msg();
  void set_has_ho_command();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int msg_dir_;
  union MsgUnion {
    MsgUnion() {}
    ::protocol::flex_hello* hello_msg_;
    ::protocol::flex_echo_request* echo_request_msg_;
    ::protocol::flex_echo_reply* echo_reply_msg_;
    ::protocol::flex_stats_request* stats_request_msg_;
    ::protocol::flex_stats_reply* stats_reply_msg_;
    ::protocol::flex_sf_trigger* sf_trigger_msg_;
    ::protocol::flex_ul_sr_info* ul_sr_info_msg_;
    ::protocol::flex_enb_config_request* enb_config_request_msg_;
    ::protocol::flex_enb_config_reply* enb_config_reply_msg_;
    ::protocol::flex_ue_config_request* ue_config_request_msg_;
    ::protocol::flex_ue_config_reply* ue_config_reply_msg_;
    ::protocol::flex_lc_config_request* lc_config_request_msg_;
    ::protocol::flex_lc_config_reply* lc_config_reply_msg_;
    ::protocol::flex_dl_mac_config* dl_mac_config_msg_;
    ::protocol::flex_ue_state_change* ue_state_change_msg_;
    ::protocol::flex_control_delegation* control_delegation_msg_;
    ::protocol::flex_agent_reconfiguration* agent_reconfiguration_msg_;
    ::protocol::flex_rrc_triggering* rrc_triggering_;
    ::protocol::flex_ul_mac_config* ul_mac_config_msg_;
    ::protocol::flex_disconnect* disconnect_msg_;
    ::protocol::flex_ho_command* ho_command_;
  } msg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_hello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_hello) */ {
 public:
  flex_hello();
  virtual ~flex_hello();

  flex_hello(const flex_hello& from);

  inline flex_hello& operator=(const flex_hello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_hello& default_instance();

  static inline const flex_hello* internal_default_instance() {
    return reinterpret_cast<const flex_hello*>(
               &_flex_hello_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(flex_hello* other);

  // implements Message ----------------------------------------------

  inline flex_hello* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_hello* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_hello& from);
  void MergeFrom(const flex_hello& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_hello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.flex_bs_capability capabilities = 3;
  int capabilities_size() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 3;
  ::protocol::flex_bs_capability capabilities(int index) const;
  void set_capabilities(int index, ::protocol::flex_bs_capability value);
  void add_capabilities(::protocol::flex_bs_capability value);
  const ::google::protobuf::RepeatedField<int>& capabilities() const;
  ::google::protobuf::RepeatedField<int>* mutable_capabilities();

  // repeated .protocol.flex_bs_split splits = 4;
  int splits_size() const;
  void clear_splits();
  static const int kSplitsFieldNumber = 4;
  ::protocol::flex_bs_split splits(int index) const;
  void set_splits(int index, ::protocol::flex_bs_split value);
  void add_splits(::protocol::flex_bs_split value);
  const ::google::protobuf::RepeatedField<int>& splits() const;
  ::google::protobuf::RepeatedField<int>* mutable_splits();

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // optional uint64 bs_id = 2;
  bool has_bs_id() const;
  void clear_bs_id();
  static const int kBsIdFieldNumber = 2;
  ::google::protobuf::uint64 bs_id() const;
  void set_bs_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_hello)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_bs_id();
  void clear_has_bs_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> capabilities_;
  ::google::protobuf::RepeatedField<int> splits_;
  ::protocol::flex_header* header_;
  ::google::protobuf::uint64 bs_id_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_echo_request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_echo_request) */ {
 public:
  flex_echo_request();
  virtual ~flex_echo_request();

  flex_echo_request(const flex_echo_request& from);

  inline flex_echo_request& operator=(const flex_echo_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_echo_request& default_instance();

  static inline const flex_echo_request* internal_default_instance() {
    return reinterpret_cast<const flex_echo_request*>(
               &_flex_echo_request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(flex_echo_request* other);

  // implements Message ----------------------------------------------

  inline flex_echo_request* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_echo_request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_echo_request& from);
  void MergeFrom(const flex_echo_request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_echo_request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(flex_echo_request)
  // @@protoc_insertion_point(class_scope:protocol.flex_echo_request)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::flex_header* header_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_echo_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_echo_reply) */ {
 public:
  flex_echo_reply();
  virtual ~flex_echo_reply();

  flex_echo_reply(const flex_echo_reply& from);

  inline flex_echo_reply& operator=(const flex_echo_reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_echo_reply& default_instance();

  static inline const flex_echo_reply* internal_default_instance() {
    return reinterpret_cast<const flex_echo_reply*>(
               &_flex_echo_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(flex_echo_reply* other);

  // implements Message ----------------------------------------------

  inline flex_echo_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_echo_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_echo_reply& from);
  void MergeFrom(const flex_echo_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_echo_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(flex_echo_reply)
  // @@protoc_insertion_point(class_scope:protocol.flex_echo_reply)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::flex_header* header_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_stats_request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_stats_request) */ {
 public:
  flex_stats_request();
  virtual ~flex_stats_request();

  flex_stats_request(const flex_stats_request& from);

  inline flex_stats_request& operator=(const flex_stats_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_stats_request& default_instance();

  enum BodyCase {
    kCompleteStatsRequest = 3,
    kCellStatsRequest = 4,
    kUeStatsRequest = 5,
    BODY_NOT_SET = 0,
  };

  static inline const flex_stats_request* internal_default_instance() {
    return reinterpret_cast<const flex_stats_request*>(
               &_flex_stats_request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(flex_stats_request* other);

  // implements Message ----------------------------------------------

  inline flex_stats_request* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_stats_request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_stats_request& from);
  void MergeFrom(const flex_stats_request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_stats_request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // optional .protocol.flex_stats_type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::protocol::flex_stats_type type() const;
  void set_type(::protocol::flex_stats_type value);

  // optional .protocol.flex_complete_stats_request complete_stats_request = 3;
  bool has_complete_stats_request() const;
  void clear_complete_stats_request();
  static const int kCompleteStatsRequestFieldNumber = 3;
  const ::protocol::flex_complete_stats_request& complete_stats_request() const;
  ::protocol::flex_complete_stats_request* mutable_complete_stats_request();
  ::protocol::flex_complete_stats_request* release_complete_stats_request();
  void set_allocated_complete_stats_request(::protocol::flex_complete_stats_request* complete_stats_request);

  // optional .protocol.flex_cell_stats_request cell_stats_request = 4;
  bool has_cell_stats_request() const;
  void clear_cell_stats_request();
  static const int kCellStatsRequestFieldNumber = 4;
  const ::protocol::flex_cell_stats_request& cell_stats_request() const;
  ::protocol::flex_cell_stats_request* mutable_cell_stats_request();
  ::protocol::flex_cell_stats_request* release_cell_stats_request();
  void set_allocated_cell_stats_request(::protocol::flex_cell_stats_request* cell_stats_request);

  // optional .protocol.flex_ue_stats_request ue_stats_request = 5;
  bool has_ue_stats_request() const;
  void clear_ue_stats_request();
  static const int kUeStatsRequestFieldNumber = 5;
  const ::protocol::flex_ue_stats_request& ue_stats_request() const;
  ::protocol::flex_ue_stats_request* mutable_ue_stats_request();
  ::protocol::flex_ue_stats_request* release_ue_stats_request();
  void set_allocated_ue_stats_request(::protocol::flex_ue_stats_request* ue_stats_request);

  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:protocol.flex_stats_request)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_type();
  void clear_has_type();
  void set_has_complete_stats_request();
  void set_has_cell_stats_request();
  void set_has_ue_stats_request();

  inline bool has_body() const;
  void clear_body();
  inline void clear_has_body();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::flex_header* header_;
  int type_;
  union BodyUnion {
    BodyUnion() {}
    ::protocol::flex_complete_stats_request* complete_stats_request_;
    ::protocol::flex_cell_stats_request* cell_stats_request_;
    ::protocol::flex_ue_stats_request* ue_stats_request_;
  } body_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_stats_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_stats_reply) */ {
 public:
  flex_stats_reply();
  virtual ~flex_stats_reply();

  flex_stats_reply(const flex_stats_reply& from);

  inline flex_stats_reply& operator=(const flex_stats_reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_stats_reply& default_instance();

  static inline const flex_stats_reply* internal_default_instance() {
    return reinterpret_cast<const flex_stats_reply*>(
               &_flex_stats_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(flex_stats_reply* other);

  // implements Message ----------------------------------------------

  inline flex_stats_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_stats_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_stats_reply& from);
  void MergeFrom(const flex_stats_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_stats_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.flex_ue_stats_report ue_report = 2;
  int ue_report_size() const;
  void clear_ue_report();
  static const int kUeReportFieldNumber = 2;
  const ::protocol::flex_ue_stats_report& ue_report(int index) const;
  ::protocol::flex_ue_stats_report* mutable_ue_report(int index);
  ::protocol::flex_ue_stats_report* add_ue_report();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_ue_stats_report >*
      mutable_ue_report();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_ue_stats_report >&
      ue_report() const;

  // repeated .protocol.flex_cell_stats_report cell_report = 3;
  int cell_report_size() const;
  void clear_cell_report();
  static const int kCellReportFieldNumber = 3;
  const ::protocol::flex_cell_stats_report& cell_report(int index) const;
  ::protocol::flex_cell_stats_report* mutable_cell_report(int index);
  ::protocol::flex_cell_stats_report* add_cell_report();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_cell_stats_report >*
      mutable_cell_report();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_cell_stats_report >&
      cell_report() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // @@protoc_insertion_point(class_scope:protocol.flex_stats_reply)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_ue_stats_report > ue_report_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_cell_stats_report > cell_report_;
  ::protocol::flex_header* header_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_sf_trigger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_sf_trigger) */ {
 public:
  flex_sf_trigger();
  virtual ~flex_sf_trigger();

  flex_sf_trigger(const flex_sf_trigger& from);

  inline flex_sf_trigger& operator=(const flex_sf_trigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_sf_trigger& default_instance();

  static inline const flex_sf_trigger* internal_default_instance() {
    return reinterpret_cast<const flex_sf_trigger*>(
               &_flex_sf_trigger_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(flex_sf_trigger* other);

  // implements Message ----------------------------------------------

  inline flex_sf_trigger* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_sf_trigger* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_sf_trigger& from);
  void MergeFrom(const flex_sf_trigger& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_sf_trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.flex_dl_info dl_info = 3;
  int dl_info_size() const;
  void clear_dl_info();
  static const int kDlInfoFieldNumber = 3;
  const ::protocol::flex_dl_info& dl_info(int index) const;
  ::protocol::flex_dl_info* mutable_dl_info(int index);
  ::protocol::flex_dl_info* add_dl_info();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_info >*
      mutable_dl_info();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_info >&
      dl_info() const;

  // repeated .protocol.flex_ul_info ul_info = 4;
  int ul_info_size() const;
  void clear_ul_info();
  static const int kUlInfoFieldNumber = 4;
  const ::protocol::flex_ul_info& ul_info(int index) const;
  ::protocol::flex_ul_info* mutable_ul_info(int index);
  ::protocol::flex_ul_info* add_ul_info();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_ul_info >*
      mutable_ul_info();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_ul_info >&
      ul_info() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // optional uint32 sfn_sf = 2;
  bool has_sfn_sf() const;
  void clear_sfn_sf();
  static const int kSfnSfFieldNumber = 2;
  ::google::protobuf::uint32 sfn_sf() const;
  void set_sfn_sf(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_sf_trigger)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_sfn_sf();
  void clear_has_sfn_sf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_info > dl_info_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_ul_info > ul_info_;
  ::protocol::flex_header* header_;
  ::google::protobuf::uint32 sfn_sf_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_ul_sr_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ul_sr_info) */ {
 public:
  flex_ul_sr_info();
  virtual ~flex_ul_sr_info();

  flex_ul_sr_info(const flex_ul_sr_info& from);

  inline flex_ul_sr_info& operator=(const flex_ul_sr_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_ul_sr_info& default_instance();

  static inline const flex_ul_sr_info* internal_default_instance() {
    return reinterpret_cast<const flex_ul_sr_info*>(
               &_flex_ul_sr_info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(flex_ul_sr_info* other);

  // implements Message ----------------------------------------------

  inline flex_ul_sr_info* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_ul_sr_info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_ul_sr_info& from);
  void MergeFrom(const flex_ul_sr_info& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_ul_sr_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 rnti = 3;
  int rnti_size() const;
  void clear_rnti();
  static const int kRntiFieldNumber = 3;
  ::google::protobuf::uint32 rnti(int index) const;
  void set_rnti(int index, ::google::protobuf::uint32 value);
  void add_rnti(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      rnti() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_rnti();

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // optional uint32 sfn_sf = 2;
  bool has_sfn_sf() const;
  void clear_sfn_sf();
  static const int kSfnSfFieldNumber = 2;
  ::google::protobuf::uint32 sfn_sf() const;
  void set_sfn_sf(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_ul_sr_info)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_sfn_sf();
  void clear_has_sfn_sf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > rnti_;
  ::protocol::flex_header* header_;
  ::google::protobuf::uint32 sfn_sf_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_enb_config_request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_enb_config_request) */ {
 public:
  flex_enb_config_request();
  virtual ~flex_enb_config_request();

  flex_enb_config_request(const flex_enb_config_request& from);

  inline flex_enb_config_request& operator=(const flex_enb_config_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_enb_config_request& default_instance();

  static inline const flex_enb_config_request* internal_default_instance() {
    return reinterpret_cast<const flex_enb_config_request*>(
               &_flex_enb_config_request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(flex_enb_config_request* other);

  // implements Message ----------------------------------------------

  inline flex_enb_config_request* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_enb_config_request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_enb_config_request& from);
  void MergeFrom(const flex_enb_config_request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_enb_config_request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // @@protoc_insertion_point(class_scope:protocol.flex_enb_config_request)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::flex_header* header_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_enb_config_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_enb_config_reply) */ {
 public:
  flex_enb_config_reply();
  virtual ~flex_enb_config_reply();

  flex_enb_config_reply(const flex_enb_config_reply& from);

  inline flex_enb_config_reply& operator=(const flex_enb_config_reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_enb_config_reply& default_instance();

  static inline const flex_enb_config_reply* internal_default_instance() {
    return reinterpret_cast<const flex_enb_config_reply*>(
               &_flex_enb_config_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(flex_enb_config_reply* other);

  // implements Message ----------------------------------------------

  inline flex_enb_config_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_enb_config_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_enb_config_reply& from);
  void MergeFrom(const flex_enb_config_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_enb_config_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.flex_cell_config cell_config = 3;
  int cell_config_size() const;
  void clear_cell_config();
  static const int kCellConfigFieldNumber = 3;
  const ::protocol::flex_cell_config& cell_config(int index) const;
  ::protocol::flex_cell_config* mutable_cell_config(int index);
  ::protocol::flex_cell_config* add_cell_config();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_cell_config >*
      mutable_cell_config();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_cell_config >&
      cell_config() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // optional .protocol.flex_s1ap_config s1ap = 5;
  bool has_s1ap() const;
  void clear_s1ap();
  static const int kS1ApFieldNumber = 5;
  const ::protocol::flex_s1ap_config& s1ap() const;
  ::protocol::flex_s1ap_config* mutable_s1ap();
  ::protocol::flex_s1ap_config* release_s1ap();
  void set_allocated_s1ap(::protocol::flex_s1ap_config* s1ap);

  // optional uint64 eNB_id = 2;
  bool has_enb_id() const;
  void clear_enb_id();
  static const int kENBIdFieldNumber = 2;
  ::google::protobuf::uint64 enb_id() const;
  void set_enb_id(::google::protobuf::uint64 value);

  // optional uint32 device_spec = 4;
  bool has_device_spec() const;
  void clear_device_spec();
  static const int kDeviceSpecFieldNumber = 4;
  ::google::protobuf::uint32 device_spec() const;
  void set_device_spec(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_enb_config_reply)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_enb_id();
  void clear_has_enb_id();
  void set_has_device_spec();
  void clear_has_device_spec();
  void set_has_s1ap();
  void clear_has_s1ap();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_cell_config > cell_config_;
  ::protocol::flex_header* header_;
  ::protocol::flex_s1ap_config* s1ap_;
  ::google::protobuf::uint64 enb_id_;
  ::google::protobuf::uint32 device_spec_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_ue_config_request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ue_config_request) */ {
 public:
  flex_ue_config_request();
  virtual ~flex_ue_config_request();

  flex_ue_config_request(const flex_ue_config_request& from);

  inline flex_ue_config_request& operator=(const flex_ue_config_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_ue_config_request& default_instance();

  static inline const flex_ue_config_request* internal_default_instance() {
    return reinterpret_cast<const flex_ue_config_request*>(
               &_flex_ue_config_request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(flex_ue_config_request* other);

  // implements Message ----------------------------------------------

  inline flex_ue_config_request* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_ue_config_request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_ue_config_request& from);
  void MergeFrom(const flex_ue_config_request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_ue_config_request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // @@protoc_insertion_point(class_scope:protocol.flex_ue_config_request)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::flex_header* header_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_ue_config_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ue_config_reply) */ {
 public:
  flex_ue_config_reply();
  virtual ~flex_ue_config_reply();

  flex_ue_config_reply(const flex_ue_config_reply& from);

  inline flex_ue_config_reply& operator=(const flex_ue_config_reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_ue_config_reply& default_instance();

  static inline const flex_ue_config_reply* internal_default_instance() {
    return reinterpret_cast<const flex_ue_config_reply*>(
               &_flex_ue_config_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(flex_ue_config_reply* other);

  // implements Message ----------------------------------------------

  inline flex_ue_config_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_ue_config_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_ue_config_reply& from);
  void MergeFrom(const flex_ue_config_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_ue_config_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.flex_ue_config ue_config = 2;
  int ue_config_size() const;
  void clear_ue_config();
  static const int kUeConfigFieldNumber = 2;
  const ::protocol::flex_ue_config& ue_config(int index) const;
  ::protocol::flex_ue_config* mutable_ue_config(int index);
  ::protocol::flex_ue_config* add_ue_config();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_ue_config >*
      mutable_ue_config();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_ue_config >&
      ue_config() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // @@protoc_insertion_point(class_scope:protocol.flex_ue_config_reply)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_ue_config > ue_config_;
  ::protocol::flex_header* header_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_lc_config_request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_lc_config_request) */ {
 public:
  flex_lc_config_request();
  virtual ~flex_lc_config_request();

  flex_lc_config_request(const flex_lc_config_request& from);

  inline flex_lc_config_request& operator=(const flex_lc_config_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_lc_config_request& default_instance();

  static inline const flex_lc_config_request* internal_default_instance() {
    return reinterpret_cast<const flex_lc_config_request*>(
               &_flex_lc_config_request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(flex_lc_config_request* other);

  // implements Message ----------------------------------------------

  inline flex_lc_config_request* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_lc_config_request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_lc_config_request& from);
  void MergeFrom(const flex_lc_config_request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_lc_config_request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // @@protoc_insertion_point(class_scope:protocol.flex_lc_config_request)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::flex_header* header_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_lc_config_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_lc_config_reply) */ {
 public:
  flex_lc_config_reply();
  virtual ~flex_lc_config_reply();

  flex_lc_config_reply(const flex_lc_config_reply& from);

  inline flex_lc_config_reply& operator=(const flex_lc_config_reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_lc_config_reply& default_instance();

  static inline const flex_lc_config_reply* internal_default_instance() {
    return reinterpret_cast<const flex_lc_config_reply*>(
               &_flex_lc_config_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(flex_lc_config_reply* other);

  // implements Message ----------------------------------------------

  inline flex_lc_config_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_lc_config_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_lc_config_reply& from);
  void MergeFrom(const flex_lc_config_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_lc_config_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.flex_lc_ue_config lc_ue_config = 2;
  int lc_ue_config_size() const;
  void clear_lc_ue_config();
  static const int kLcUeConfigFieldNumber = 2;
  const ::protocol::flex_lc_ue_config& lc_ue_config(int index) const;
  ::protocol::flex_lc_ue_config* mutable_lc_ue_config(int index);
  ::protocol::flex_lc_ue_config* add_lc_ue_config();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_lc_ue_config >*
      mutable_lc_ue_config();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_lc_ue_config >&
      lc_ue_config() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // @@protoc_insertion_point(class_scope:protocol.flex_lc_config_reply)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_lc_ue_config > lc_ue_config_;
  ::protocol::flex_header* header_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_dl_mac_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_dl_mac_config) */ {
 public:
  flex_dl_mac_config();
  virtual ~flex_dl_mac_config();

  flex_dl_mac_config(const flex_dl_mac_config& from);

  inline flex_dl_mac_config& operator=(const flex_dl_mac_config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_dl_mac_config& default_instance();

  static inline const flex_dl_mac_config* internal_default_instance() {
    return reinterpret_cast<const flex_dl_mac_config*>(
               &_flex_dl_mac_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(flex_dl_mac_config* other);

  // implements Message ----------------------------------------------

  inline flex_dl_mac_config* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_dl_mac_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_dl_mac_config& from);
  void MergeFrom(const flex_dl_mac_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_dl_mac_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.flex_dl_data dl_ue_data = 3;
  int dl_ue_data_size() const;
  void clear_dl_ue_data();
  static const int kDlUeDataFieldNumber = 3;
  const ::protocol::flex_dl_data& dl_ue_data(int index) const;
  ::protocol::flex_dl_data* mutable_dl_ue_data(int index);
  ::protocol::flex_dl_data* add_dl_ue_data();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_data >*
      mutable_dl_ue_data();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_data >&
      dl_ue_data() const;

  // repeated .protocol.flex_dl_rar dl_rar = 4;
  int dl_rar_size() const;
  void clear_dl_rar();
  static const int kDlRarFieldNumber = 4;
  const ::protocol::flex_dl_rar& dl_rar(int index) const;
  ::protocol::flex_dl_rar* mutable_dl_rar(int index);
  ::protocol::flex_dl_rar* add_dl_rar();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_rar >*
      mutable_dl_rar();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_rar >&
      dl_rar() const;

  // repeated .protocol.flex_dl_broadcast dl_broadcast = 5;
  int dl_broadcast_size() const;
  void clear_dl_broadcast();
  static const int kDlBroadcastFieldNumber = 5;
  const ::protocol::flex_dl_broadcast& dl_broadcast(int index) const;
  ::protocol::flex_dl_broadcast* mutable_dl_broadcast(int index);
  ::protocol::flex_dl_broadcast* add_dl_broadcast();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_broadcast >*
      mutable_dl_broadcast();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_broadcast >&
      dl_broadcast() const;

  // repeated .protocol.flex_pdcch_ofdm_sym_count ofdm_sym = 6;
  int ofdm_sym_size() const;
  void clear_ofdm_sym();
  static const int kOfdmSymFieldNumber = 6;
  const ::protocol::flex_pdcch_ofdm_sym_count& ofdm_sym(int index) const;
  ::protocol::flex_pdcch_ofdm_sym_count* mutable_ofdm_sym(int index);
  ::protocol::flex_pdcch_ofdm_sym_count* add_ofdm_sym();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_pdcch_ofdm_sym_count >*
      mutable_ofdm_sym();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_pdcch_ofdm_sym_count >&
      ofdm_sym() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // optional uint32 sfn_sf = 2;
  bool has_sfn_sf() const;
  void clear_sfn_sf();
  static const int kSfnSfFieldNumber = 2;
  ::google::protobuf::uint32 sfn_sf() const;
  void set_sfn_sf(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_dl_mac_config)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_sfn_sf();
  void clear_has_sfn_sf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_data > dl_ue_data_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_rar > dl_rar_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_broadcast > dl_broadcast_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_pdcch_ofdm_sym_count > ofdm_sym_;
  ::protocol::flex_header* header_;
  ::google::protobuf::uint32 sfn_sf_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_ul_mac_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ul_mac_config) */ {
 public:
  flex_ul_mac_config();
  virtual ~flex_ul_mac_config();

  flex_ul_mac_config(const flex_ul_mac_config& from);

  inline flex_ul_mac_config& operator=(const flex_ul_mac_config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_ul_mac_config& default_instance();

  static inline const flex_ul_mac_config* internal_default_instance() {
    return reinterpret_cast<const flex_ul_mac_config*>(
               &_flex_ul_mac_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(flex_ul_mac_config* other);

  // implements Message ----------------------------------------------

  inline flex_ul_mac_config* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_ul_mac_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_ul_mac_config& from);
  void MergeFrom(const flex_ul_mac_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_ul_mac_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.flex_ul_data ul_ue_data = 3;
  int ul_ue_data_size() const;
  void clear_ul_ue_data();
  static const int kUlUeDataFieldNumber = 3;
  const ::protocol::flex_ul_data& ul_ue_data(int index) const;
  ::protocol::flex_ul_data* mutable_ul_ue_data(int index);
  ::protocol::flex_ul_data* add_ul_ue_data();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_ul_data >*
      mutable_ul_ue_data();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_ul_data >&
      ul_ue_data() const;

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // optional uint32 sfn_sf = 2;
  bool has_sfn_sf() const;
  void clear_sfn_sf();
  static const int kSfnSfFieldNumber = 2;
  ::google::protobuf::uint32 sfn_sf() const;
  void set_sfn_sf(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_ul_mac_config)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_sfn_sf();
  void clear_has_sfn_sf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_ul_data > ul_ue_data_;
  ::protocol::flex_header* header_;
  ::google::protobuf::uint32 sfn_sf_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_rrc_triggering : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_rrc_triggering) */ {
 public:
  flex_rrc_triggering();
  virtual ~flex_rrc_triggering();

  flex_rrc_triggering(const flex_rrc_triggering& from);

  inline flex_rrc_triggering& operator=(const flex_rrc_triggering& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_rrc_triggering& default_instance();

  static inline const flex_rrc_triggering* internal_default_instance() {
    return reinterpret_cast<const flex_rrc_triggering*>(
               &_flex_rrc_triggering_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(flex_rrc_triggering* other);

  // implements Message ----------------------------------------------

  inline flex_rrc_triggering* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_rrc_triggering* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_rrc_triggering& from);
  void MergeFrom(const flex_rrc_triggering& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_rrc_triggering* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string rrc_trigger = 2;
  bool has_rrc_trigger() const;
  void clear_rrc_trigger();
  static const int kRrcTriggerFieldNumber = 2;
  const ::std::string& rrc_trigger() const;
  void set_rrc_trigger(const ::std::string& value);
  #if LANG_CXX11
  void set_rrc_trigger(::std::string&& value);
  #endif
  void set_rrc_trigger(const char* value);
  void set_rrc_trigger(const char* value, size_t size);
  ::std::string* mutable_rrc_trigger();
  ::std::string* release_rrc_trigger();
  void set_allocated_rrc_trigger(::std::string* rrc_trigger);

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // optional .protocol.flex_measurement_info meas_info = 3;
  bool has_meas_info() const;
  void clear_meas_info();
  static const int kMeasInfoFieldNumber = 3;
  const ::protocol::flex_measurement_info& meas_info() const;
  ::protocol::flex_measurement_info* mutable_meas_info();
  ::protocol::flex_measurement_info* release_meas_info();
  void set_allocated_meas_info(::protocol::flex_measurement_info* meas_info);

  // @@protoc_insertion_point(class_scope:protocol.flex_rrc_triggering)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_rrc_trigger();
  void clear_has_rrc_trigger();
  void set_has_meas_info();
  void clear_has_meas_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rrc_trigger_;
  ::protocol::flex_header* header_;
  ::protocol::flex_measurement_info* meas_info_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_ho_command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ho_command) */ {
 public:
  flex_ho_command();
  virtual ~flex_ho_command();

  flex_ho_command(const flex_ho_command& from);

  inline flex_ho_command& operator=(const flex_ho_command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_ho_command& default_instance();

  static inline const flex_ho_command* internal_default_instance() {
    return reinterpret_cast<const flex_ho_command*>(
               &_flex_ho_command_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(flex_ho_command* other);

  // implements Message ----------------------------------------------

  inline flex_ho_command* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_ho_command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_ho_command& from);
  void MergeFrom(const flex_ho_command& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_ho_command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // optional uint32 rnti = 2;
  bool has_rnti() const;
  void clear_rnti();
  static const int kRntiFieldNumber = 2;
  ::google::protobuf::uint32 rnti() const;
  void set_rnti(::google::protobuf::uint32 value);

  // optional uint32 target_phy_cell_id = 3;
  bool has_target_phy_cell_id() const;
  void clear_target_phy_cell_id();
  static const int kTargetPhyCellIdFieldNumber = 3;
  ::google::protobuf::uint32 target_phy_cell_id() const;
  void set_target_phy_cell_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_ho_command)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_rnti();
  void clear_has_rnti();
  void set_has_target_phy_cell_id();
  void clear_has_target_phy_cell_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::flex_header* header_;
  ::google::protobuf::uint32 rnti_;
  ::google::protobuf::uint32 target_phy_cell_id_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_ue_state_change : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ue_state_change) */ {
 public:
  flex_ue_state_change();
  virtual ~flex_ue_state_change();

  flex_ue_state_change(const flex_ue_state_change& from);

  inline flex_ue_state_change& operator=(const flex_ue_state_change& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_ue_state_change& default_instance();

  static inline const flex_ue_state_change* internal_default_instance() {
    return reinterpret_cast<const flex_ue_state_change*>(
               &_flex_ue_state_change_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(flex_ue_state_change* other);

  // implements Message ----------------------------------------------

  inline flex_ue_state_change* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_ue_state_change* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_ue_state_change& from);
  void MergeFrom(const flex_ue_state_change& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_ue_state_change* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // optional .protocol.flex_ue_config config = 3;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 3;
  const ::protocol::flex_ue_config& config() const;
  ::protocol::flex_ue_config* mutable_config();
  ::protocol::flex_ue_config* release_config();
  void set_allocated_config(::protocol::flex_ue_config* config);

  // optional uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_ue_state_change)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_type();
  void clear_has_type();
  void set_has_config();
  void clear_has_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::flex_header* header_;
  ::protocol::flex_ue_config* config_;
  ::google::protobuf::uint32 type_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_control_delegation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_control_delegation) */ {
 public:
  flex_control_delegation();
  virtual ~flex_control_delegation();

  flex_control_delegation(const flex_control_delegation& from);

  inline flex_control_delegation& operator=(const flex_control_delegation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_control_delegation& default_instance();

  static inline const flex_control_delegation* internal_default_instance() {
    return reinterpret_cast<const flex_control_delegation*>(
               &_flex_control_delegation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(flex_control_delegation* other);

  // implements Message ----------------------------------------------

  inline flex_control_delegation* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_control_delegation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_control_delegation& from);
  void MergeFrom(const flex_control_delegation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_control_delegation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes payload = 3;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // optional string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // optional uint32 delegation_type = 2;
  bool has_delegation_type() const;
  void clear_delegation_type();
  static const int kDelegationTypeFieldNumber = 2;
  ::google::protobuf::uint32 delegation_type() const;
  void set_delegation_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_control_delegation)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_delegation_type();
  void clear_has_delegation_type();
  void set_has_payload();
  void clear_has_payload();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::protocol::flex_header* header_;
  ::google::protobuf::uint32 delegation_type_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_agent_reconfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_agent_reconfiguration) */ {
 public:
  flex_agent_reconfiguration();
  virtual ~flex_agent_reconfiguration();

  flex_agent_reconfiguration(const flex_agent_reconfiguration& from);

  inline flex_agent_reconfiguration& operator=(const flex_agent_reconfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_agent_reconfiguration& default_instance();

  static inline const flex_agent_reconfiguration* internal_default_instance() {
    return reinterpret_cast<const flex_agent_reconfiguration*>(
               &_flex_agent_reconfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(flex_agent_reconfiguration* other);

  // implements Message ----------------------------------------------

  inline flex_agent_reconfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_agent_reconfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_agent_reconfiguration& from);
  void MergeFrom(const flex_agent_reconfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_agent_reconfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string policy = 2;
  bool has_policy() const;
  void clear_policy();
  static const int kPolicyFieldNumber = 2;
  const ::std::string& policy() const;
  void set_policy(const ::std::string& value);
  #if LANG_CXX11
  void set_policy(::std::string&& value);
  #endif
  void set_policy(const char* value);
  void set_policy(const char* value, size_t size);
  ::std::string* mutable_policy();
  ::std::string* release_policy();
  void set_allocated_policy(::std::string* policy);

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // @@protoc_insertion_point(class_scope:protocol.flex_agent_reconfiguration)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_policy();
  void clear_has_policy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr policy_;
  ::protocol::flex_header* header_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_echo_request_latency : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_echo_request_latency) */ {
 public:
  flex_echo_request_latency();
  virtual ~flex_echo_request_latency();

  flex_echo_request_latency(const flex_echo_request_latency& from);

  inline flex_echo_request_latency& operator=(const flex_echo_request_latency& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_echo_request_latency& default_instance();

  static inline const flex_echo_request_latency* internal_default_instance() {
    return reinterpret_cast<const flex_echo_request_latency*>(
               &_flex_echo_request_latency_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(flex_echo_request_latency* other);

  // implements Message ----------------------------------------------

  inline flex_echo_request_latency* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_echo_request_latency* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_echo_request_latency& from);
  void MergeFrom(const flex_echo_request_latency& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_echo_request_latency* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  static const int kLatencyFieldNumber = 100;
  static ::google::protobuf::internal::ExtensionIdentifier< ::protocol::flex_echo_request,
      ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::uint32 >, 13, false >
    latency;
  // @@protoc_insertion_point(class_scope:protocol.flex_echo_request_latency)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_echo_reply_latency : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_echo_reply_latency) */ {
 public:
  flex_echo_reply_latency();
  virtual ~flex_echo_reply_latency();

  flex_echo_reply_latency(const flex_echo_reply_latency& from);

  inline flex_echo_reply_latency& operator=(const flex_echo_reply_latency& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_echo_reply_latency& default_instance();

  static inline const flex_echo_reply_latency* internal_default_instance() {
    return reinterpret_cast<const flex_echo_reply_latency*>(
               &_flex_echo_reply_latency_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(flex_echo_reply_latency* other);

  // implements Message ----------------------------------------------

  inline flex_echo_reply_latency* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_echo_reply_latency* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_echo_reply_latency& from);
  void MergeFrom(const flex_echo_reply_latency& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_echo_reply_latency* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  static const int kLatencyFieldNumber = 100;
  static ::google::protobuf::internal::ExtensionIdentifier< ::protocol::flex_echo_reply,
      ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::uint32 >, 13, false >
    latency;
  // @@protoc_insertion_point(class_scope:protocol.flex_echo_reply_latency)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_disconnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_disconnect) */ {
 public:
  flex_disconnect();
  virtual ~flex_disconnect();

  flex_disconnect(const flex_disconnect& from);

  inline flex_disconnect& operator=(const flex_disconnect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_disconnect& default_instance();

  static inline const flex_disconnect* internal_default_instance() {
    return reinterpret_cast<const flex_disconnect*>(
               &_flex_disconnect_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(flex_disconnect* other);

  // implements Message ----------------------------------------------

  inline flex_disconnect* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_disconnect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_disconnect& from);
  void MergeFrom(const flex_disconnect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_disconnect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flex_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::protocol::flex_header& header() const;
  ::protocol::flex_header* mutable_header();
  ::protocol::flex_header* release_header();
  void set_allocated_header(::protocol::flex_header* header);

  // @@protoc_insertion_point(class_scope:protocol.flex_disconnect)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::flex_header* header_;
  friend struct protobuf_flexran_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// flexran_message

// optional .protocol.flexran_direction msg_dir = 100;
inline bool flexran_message::has_msg_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flexran_message::set_has_msg_dir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flexran_message::clear_has_msg_dir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flexran_message::clear_msg_dir() {
  msg_dir_ = 0;
  clear_has_msg_dir();
}
inline ::protocol::flexran_direction flexran_message::msg_dir() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.msg_dir)
  return static_cast< ::protocol::flexran_direction >(msg_dir_);
}
inline void flexran_message::set_msg_dir(::protocol::flexran_direction value) {
  assert(::protocol::flexran_direction_IsValid(value));
  set_has_msg_dir();
  msg_dir_ = value;
  // @@protoc_insertion_point(field_set:protocol.flexran_message.msg_dir)
}

// optional .protocol.flex_hello hello_msg = 1;
inline bool flexran_message::has_hello_msg() const {
  return msg_case() == kHelloMsg;
}
inline void flexran_message::set_has_hello_msg() {
  _oneof_case_[0] = kHelloMsg;
}
inline void flexran_message::clear_hello_msg() {
  if (has_hello_msg()) {
    delete msg_.hello_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_hello& flexran_message::hello_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.hello_msg)
  return has_hello_msg()
      ? *msg_.hello_msg_
      : ::protocol::flex_hello::default_instance();
}
inline ::protocol::flex_hello* flexran_message::mutable_hello_msg() {
  if (!has_hello_msg()) {
    clear_msg();
    set_has_hello_msg();
    msg_.hello_msg_ = new ::protocol::flex_hello;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.hello_msg)
  return msg_.hello_msg_;
}
inline ::protocol::flex_hello* flexran_message::release_hello_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.hello_msg)
  if (has_hello_msg()) {
    clear_has_msg();
    ::protocol::flex_hello* temp = msg_.hello_msg_;
    msg_.hello_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_hello_msg(::protocol::flex_hello* hello_msg) {
  clear_msg();
  if (hello_msg) {
    set_has_hello_msg();
    msg_.hello_msg_ = hello_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.hello_msg)
}

// optional .protocol.flex_echo_request echo_request_msg = 2;
inline bool flexran_message::has_echo_request_msg() const {
  return msg_case() == kEchoRequestMsg;
}
inline void flexran_message::set_has_echo_request_msg() {
  _oneof_case_[0] = kEchoRequestMsg;
}
inline void flexran_message::clear_echo_request_msg() {
  if (has_echo_request_msg()) {
    delete msg_.echo_request_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_echo_request& flexran_message::echo_request_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.echo_request_msg)
  return has_echo_request_msg()
      ? *msg_.echo_request_msg_
      : ::protocol::flex_echo_request::default_instance();
}
inline ::protocol::flex_echo_request* flexran_message::mutable_echo_request_msg() {
  if (!has_echo_request_msg()) {
    clear_msg();
    set_has_echo_request_msg();
    msg_.echo_request_msg_ = new ::protocol::flex_echo_request;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.echo_request_msg)
  return msg_.echo_request_msg_;
}
inline ::protocol::flex_echo_request* flexran_message::release_echo_request_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.echo_request_msg)
  if (has_echo_request_msg()) {
    clear_has_msg();
    ::protocol::flex_echo_request* temp = msg_.echo_request_msg_;
    msg_.echo_request_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_echo_request_msg(::protocol::flex_echo_request* echo_request_msg) {
  clear_msg();
  if (echo_request_msg) {
    set_has_echo_request_msg();
    msg_.echo_request_msg_ = echo_request_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.echo_request_msg)
}

// optional .protocol.flex_echo_reply echo_reply_msg = 3;
inline bool flexran_message::has_echo_reply_msg() const {
  return msg_case() == kEchoReplyMsg;
}
inline void flexran_message::set_has_echo_reply_msg() {
  _oneof_case_[0] = kEchoReplyMsg;
}
inline void flexran_message::clear_echo_reply_msg() {
  if (has_echo_reply_msg()) {
    delete msg_.echo_reply_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_echo_reply& flexran_message::echo_reply_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.echo_reply_msg)
  return has_echo_reply_msg()
      ? *msg_.echo_reply_msg_
      : ::protocol::flex_echo_reply::default_instance();
}
inline ::protocol::flex_echo_reply* flexran_message::mutable_echo_reply_msg() {
  if (!has_echo_reply_msg()) {
    clear_msg();
    set_has_echo_reply_msg();
    msg_.echo_reply_msg_ = new ::protocol::flex_echo_reply;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.echo_reply_msg)
  return msg_.echo_reply_msg_;
}
inline ::protocol::flex_echo_reply* flexran_message::release_echo_reply_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.echo_reply_msg)
  if (has_echo_reply_msg()) {
    clear_has_msg();
    ::protocol::flex_echo_reply* temp = msg_.echo_reply_msg_;
    msg_.echo_reply_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_echo_reply_msg(::protocol::flex_echo_reply* echo_reply_msg) {
  clear_msg();
  if (echo_reply_msg) {
    set_has_echo_reply_msg();
    msg_.echo_reply_msg_ = echo_reply_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.echo_reply_msg)
}

// optional .protocol.flex_stats_request stats_request_msg = 4;
inline bool flexran_message::has_stats_request_msg() const {
  return msg_case() == kStatsRequestMsg;
}
inline void flexran_message::set_has_stats_request_msg() {
  _oneof_case_[0] = kStatsRequestMsg;
}
inline void flexran_message::clear_stats_request_msg() {
  if (has_stats_request_msg()) {
    delete msg_.stats_request_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_stats_request& flexran_message::stats_request_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.stats_request_msg)
  return has_stats_request_msg()
      ? *msg_.stats_request_msg_
      : ::protocol::flex_stats_request::default_instance();
}
inline ::protocol::flex_stats_request* flexran_message::mutable_stats_request_msg() {
  if (!has_stats_request_msg()) {
    clear_msg();
    set_has_stats_request_msg();
    msg_.stats_request_msg_ = new ::protocol::flex_stats_request;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.stats_request_msg)
  return msg_.stats_request_msg_;
}
inline ::protocol::flex_stats_request* flexran_message::release_stats_request_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.stats_request_msg)
  if (has_stats_request_msg()) {
    clear_has_msg();
    ::protocol::flex_stats_request* temp = msg_.stats_request_msg_;
    msg_.stats_request_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_stats_request_msg(::protocol::flex_stats_request* stats_request_msg) {
  clear_msg();
  if (stats_request_msg) {
    set_has_stats_request_msg();
    msg_.stats_request_msg_ = stats_request_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.stats_request_msg)
}

// optional .protocol.flex_stats_reply stats_reply_msg = 5;
inline bool flexran_message::has_stats_reply_msg() const {
  return msg_case() == kStatsReplyMsg;
}
inline void flexran_message::set_has_stats_reply_msg() {
  _oneof_case_[0] = kStatsReplyMsg;
}
inline void flexran_message::clear_stats_reply_msg() {
  if (has_stats_reply_msg()) {
    delete msg_.stats_reply_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_stats_reply& flexran_message::stats_reply_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.stats_reply_msg)
  return has_stats_reply_msg()
      ? *msg_.stats_reply_msg_
      : ::protocol::flex_stats_reply::default_instance();
}
inline ::protocol::flex_stats_reply* flexran_message::mutable_stats_reply_msg() {
  if (!has_stats_reply_msg()) {
    clear_msg();
    set_has_stats_reply_msg();
    msg_.stats_reply_msg_ = new ::protocol::flex_stats_reply;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.stats_reply_msg)
  return msg_.stats_reply_msg_;
}
inline ::protocol::flex_stats_reply* flexran_message::release_stats_reply_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.stats_reply_msg)
  if (has_stats_reply_msg()) {
    clear_has_msg();
    ::protocol::flex_stats_reply* temp = msg_.stats_reply_msg_;
    msg_.stats_reply_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_stats_reply_msg(::protocol::flex_stats_reply* stats_reply_msg) {
  clear_msg();
  if (stats_reply_msg) {
    set_has_stats_reply_msg();
    msg_.stats_reply_msg_ = stats_reply_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.stats_reply_msg)
}

// optional .protocol.flex_sf_trigger sf_trigger_msg = 6;
inline bool flexran_message::has_sf_trigger_msg() const {
  return msg_case() == kSfTriggerMsg;
}
inline void flexran_message::set_has_sf_trigger_msg() {
  _oneof_case_[0] = kSfTriggerMsg;
}
inline void flexran_message::clear_sf_trigger_msg() {
  if (has_sf_trigger_msg()) {
    delete msg_.sf_trigger_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_sf_trigger& flexran_message::sf_trigger_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.sf_trigger_msg)
  return has_sf_trigger_msg()
      ? *msg_.sf_trigger_msg_
      : ::protocol::flex_sf_trigger::default_instance();
}
inline ::protocol::flex_sf_trigger* flexran_message::mutable_sf_trigger_msg() {
  if (!has_sf_trigger_msg()) {
    clear_msg();
    set_has_sf_trigger_msg();
    msg_.sf_trigger_msg_ = new ::protocol::flex_sf_trigger;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.sf_trigger_msg)
  return msg_.sf_trigger_msg_;
}
inline ::protocol::flex_sf_trigger* flexran_message::release_sf_trigger_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.sf_trigger_msg)
  if (has_sf_trigger_msg()) {
    clear_has_msg();
    ::protocol::flex_sf_trigger* temp = msg_.sf_trigger_msg_;
    msg_.sf_trigger_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_sf_trigger_msg(::protocol::flex_sf_trigger* sf_trigger_msg) {
  clear_msg();
  if (sf_trigger_msg) {
    set_has_sf_trigger_msg();
    msg_.sf_trigger_msg_ = sf_trigger_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.sf_trigger_msg)
}

// optional .protocol.flex_ul_sr_info ul_sr_info_msg = 7;
inline bool flexran_message::has_ul_sr_info_msg() const {
  return msg_case() == kUlSrInfoMsg;
}
inline void flexran_message::set_has_ul_sr_info_msg() {
  _oneof_case_[0] = kUlSrInfoMsg;
}
inline void flexran_message::clear_ul_sr_info_msg() {
  if (has_ul_sr_info_msg()) {
    delete msg_.ul_sr_info_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_ul_sr_info& flexran_message::ul_sr_info_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ul_sr_info_msg)
  return has_ul_sr_info_msg()
      ? *msg_.ul_sr_info_msg_
      : ::protocol::flex_ul_sr_info::default_instance();
}
inline ::protocol::flex_ul_sr_info* flexran_message::mutable_ul_sr_info_msg() {
  if (!has_ul_sr_info_msg()) {
    clear_msg();
    set_has_ul_sr_info_msg();
    msg_.ul_sr_info_msg_ = new ::protocol::flex_ul_sr_info;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ul_sr_info_msg)
  return msg_.ul_sr_info_msg_;
}
inline ::protocol::flex_ul_sr_info* flexran_message::release_ul_sr_info_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ul_sr_info_msg)
  if (has_ul_sr_info_msg()) {
    clear_has_msg();
    ::protocol::flex_ul_sr_info* temp = msg_.ul_sr_info_msg_;
    msg_.ul_sr_info_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_ul_sr_info_msg(::protocol::flex_ul_sr_info* ul_sr_info_msg) {
  clear_msg();
  if (ul_sr_info_msg) {
    set_has_ul_sr_info_msg();
    msg_.ul_sr_info_msg_ = ul_sr_info_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.ul_sr_info_msg)
}

// optional .protocol.flex_enb_config_request enb_config_request_msg = 8;
inline bool flexran_message::has_enb_config_request_msg() const {
  return msg_case() == kEnbConfigRequestMsg;
}
inline void flexran_message::set_has_enb_config_request_msg() {
  _oneof_case_[0] = kEnbConfigRequestMsg;
}
inline void flexran_message::clear_enb_config_request_msg() {
  if (has_enb_config_request_msg()) {
    delete msg_.enb_config_request_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_enb_config_request& flexran_message::enb_config_request_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.enb_config_request_msg)
  return has_enb_config_request_msg()
      ? *msg_.enb_config_request_msg_
      : ::protocol::flex_enb_config_request::default_instance();
}
inline ::protocol::flex_enb_config_request* flexran_message::mutable_enb_config_request_msg() {
  if (!has_enb_config_request_msg()) {
    clear_msg();
    set_has_enb_config_request_msg();
    msg_.enb_config_request_msg_ = new ::protocol::flex_enb_config_request;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.enb_config_request_msg)
  return msg_.enb_config_request_msg_;
}
inline ::protocol::flex_enb_config_request* flexran_message::release_enb_config_request_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.enb_config_request_msg)
  if (has_enb_config_request_msg()) {
    clear_has_msg();
    ::protocol::flex_enb_config_request* temp = msg_.enb_config_request_msg_;
    msg_.enb_config_request_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_enb_config_request_msg(::protocol::flex_enb_config_request* enb_config_request_msg) {
  clear_msg();
  if (enb_config_request_msg) {
    set_has_enb_config_request_msg();
    msg_.enb_config_request_msg_ = enb_config_request_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.enb_config_request_msg)
}

// optional .protocol.flex_enb_config_reply enb_config_reply_msg = 9;
inline bool flexran_message::has_enb_config_reply_msg() const {
  return msg_case() == kEnbConfigReplyMsg;
}
inline void flexran_message::set_has_enb_config_reply_msg() {
  _oneof_case_[0] = kEnbConfigReplyMsg;
}
inline void flexran_message::clear_enb_config_reply_msg() {
  if (has_enb_config_reply_msg()) {
    delete msg_.enb_config_reply_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_enb_config_reply& flexran_message::enb_config_reply_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.enb_config_reply_msg)
  return has_enb_config_reply_msg()
      ? *msg_.enb_config_reply_msg_
      : ::protocol::flex_enb_config_reply::default_instance();
}
inline ::protocol::flex_enb_config_reply* flexran_message::mutable_enb_config_reply_msg() {
  if (!has_enb_config_reply_msg()) {
    clear_msg();
    set_has_enb_config_reply_msg();
    msg_.enb_config_reply_msg_ = new ::protocol::flex_enb_config_reply;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.enb_config_reply_msg)
  return msg_.enb_config_reply_msg_;
}
inline ::protocol::flex_enb_config_reply* flexran_message::release_enb_config_reply_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.enb_config_reply_msg)
  if (has_enb_config_reply_msg()) {
    clear_has_msg();
    ::protocol::flex_enb_config_reply* temp = msg_.enb_config_reply_msg_;
    msg_.enb_config_reply_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_enb_config_reply_msg(::protocol::flex_enb_config_reply* enb_config_reply_msg) {
  clear_msg();
  if (enb_config_reply_msg) {
    set_has_enb_config_reply_msg();
    msg_.enb_config_reply_msg_ = enb_config_reply_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.enb_config_reply_msg)
}

// optional .protocol.flex_ue_config_request ue_config_request_msg = 10;
inline bool flexran_message::has_ue_config_request_msg() const {
  return msg_case() == kUeConfigRequestMsg;
}
inline void flexran_message::set_has_ue_config_request_msg() {
  _oneof_case_[0] = kUeConfigRequestMsg;
}
inline void flexran_message::clear_ue_config_request_msg() {
  if (has_ue_config_request_msg()) {
    delete msg_.ue_config_request_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_ue_config_request& flexran_message::ue_config_request_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ue_config_request_msg)
  return has_ue_config_request_msg()
      ? *msg_.ue_config_request_msg_
      : ::protocol::flex_ue_config_request::default_instance();
}
inline ::protocol::flex_ue_config_request* flexran_message::mutable_ue_config_request_msg() {
  if (!has_ue_config_request_msg()) {
    clear_msg();
    set_has_ue_config_request_msg();
    msg_.ue_config_request_msg_ = new ::protocol::flex_ue_config_request;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ue_config_request_msg)
  return msg_.ue_config_request_msg_;
}
inline ::protocol::flex_ue_config_request* flexran_message::release_ue_config_request_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ue_config_request_msg)
  if (has_ue_config_request_msg()) {
    clear_has_msg();
    ::protocol::flex_ue_config_request* temp = msg_.ue_config_request_msg_;
    msg_.ue_config_request_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_ue_config_request_msg(::protocol::flex_ue_config_request* ue_config_request_msg) {
  clear_msg();
  if (ue_config_request_msg) {
    set_has_ue_config_request_msg();
    msg_.ue_config_request_msg_ = ue_config_request_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.ue_config_request_msg)
}

// optional .protocol.flex_ue_config_reply ue_config_reply_msg = 11;
inline bool flexran_message::has_ue_config_reply_msg() const {
  return msg_case() == kUeConfigReplyMsg;
}
inline void flexran_message::set_has_ue_config_reply_msg() {
  _oneof_case_[0] = kUeConfigReplyMsg;
}
inline void flexran_message::clear_ue_config_reply_msg() {
  if (has_ue_config_reply_msg()) {
    delete msg_.ue_config_reply_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_ue_config_reply& flexran_message::ue_config_reply_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ue_config_reply_msg)
  return has_ue_config_reply_msg()
      ? *msg_.ue_config_reply_msg_
      : ::protocol::flex_ue_config_reply::default_instance();
}
inline ::protocol::flex_ue_config_reply* flexran_message::mutable_ue_config_reply_msg() {
  if (!has_ue_config_reply_msg()) {
    clear_msg();
    set_has_ue_config_reply_msg();
    msg_.ue_config_reply_msg_ = new ::protocol::flex_ue_config_reply;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ue_config_reply_msg)
  return msg_.ue_config_reply_msg_;
}
inline ::protocol::flex_ue_config_reply* flexran_message::release_ue_config_reply_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ue_config_reply_msg)
  if (has_ue_config_reply_msg()) {
    clear_has_msg();
    ::protocol::flex_ue_config_reply* temp = msg_.ue_config_reply_msg_;
    msg_.ue_config_reply_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_ue_config_reply_msg(::protocol::flex_ue_config_reply* ue_config_reply_msg) {
  clear_msg();
  if (ue_config_reply_msg) {
    set_has_ue_config_reply_msg();
    msg_.ue_config_reply_msg_ = ue_config_reply_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.ue_config_reply_msg)
}

// optional .protocol.flex_lc_config_request lc_config_request_msg = 12;
inline bool flexran_message::has_lc_config_request_msg() const {
  return msg_case() == kLcConfigRequestMsg;
}
inline void flexran_message::set_has_lc_config_request_msg() {
  _oneof_case_[0] = kLcConfigRequestMsg;
}
inline void flexran_message::clear_lc_config_request_msg() {
  if (has_lc_config_request_msg()) {
    delete msg_.lc_config_request_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_lc_config_request& flexran_message::lc_config_request_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.lc_config_request_msg)
  return has_lc_config_request_msg()
      ? *msg_.lc_config_request_msg_
      : ::protocol::flex_lc_config_request::default_instance();
}
inline ::protocol::flex_lc_config_request* flexran_message::mutable_lc_config_request_msg() {
  if (!has_lc_config_request_msg()) {
    clear_msg();
    set_has_lc_config_request_msg();
    msg_.lc_config_request_msg_ = new ::protocol::flex_lc_config_request;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.lc_config_request_msg)
  return msg_.lc_config_request_msg_;
}
inline ::protocol::flex_lc_config_request* flexran_message::release_lc_config_request_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.lc_config_request_msg)
  if (has_lc_config_request_msg()) {
    clear_has_msg();
    ::protocol::flex_lc_config_request* temp = msg_.lc_config_request_msg_;
    msg_.lc_config_request_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_lc_config_request_msg(::protocol::flex_lc_config_request* lc_config_request_msg) {
  clear_msg();
  if (lc_config_request_msg) {
    set_has_lc_config_request_msg();
    msg_.lc_config_request_msg_ = lc_config_request_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.lc_config_request_msg)
}

// optional .protocol.flex_lc_config_reply lc_config_reply_msg = 13;
inline bool flexran_message::has_lc_config_reply_msg() const {
  return msg_case() == kLcConfigReplyMsg;
}
inline void flexran_message::set_has_lc_config_reply_msg() {
  _oneof_case_[0] = kLcConfigReplyMsg;
}
inline void flexran_message::clear_lc_config_reply_msg() {
  if (has_lc_config_reply_msg()) {
    delete msg_.lc_config_reply_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_lc_config_reply& flexran_message::lc_config_reply_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.lc_config_reply_msg)
  return has_lc_config_reply_msg()
      ? *msg_.lc_config_reply_msg_
      : ::protocol::flex_lc_config_reply::default_instance();
}
inline ::protocol::flex_lc_config_reply* flexran_message::mutable_lc_config_reply_msg() {
  if (!has_lc_config_reply_msg()) {
    clear_msg();
    set_has_lc_config_reply_msg();
    msg_.lc_config_reply_msg_ = new ::protocol::flex_lc_config_reply;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.lc_config_reply_msg)
  return msg_.lc_config_reply_msg_;
}
inline ::protocol::flex_lc_config_reply* flexran_message::release_lc_config_reply_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.lc_config_reply_msg)
  if (has_lc_config_reply_msg()) {
    clear_has_msg();
    ::protocol::flex_lc_config_reply* temp = msg_.lc_config_reply_msg_;
    msg_.lc_config_reply_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_lc_config_reply_msg(::protocol::flex_lc_config_reply* lc_config_reply_msg) {
  clear_msg();
  if (lc_config_reply_msg) {
    set_has_lc_config_reply_msg();
    msg_.lc_config_reply_msg_ = lc_config_reply_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.lc_config_reply_msg)
}

// optional .protocol.flex_dl_mac_config dl_mac_config_msg = 14;
inline bool flexran_message::has_dl_mac_config_msg() const {
  return msg_case() == kDlMacConfigMsg;
}
inline void flexran_message::set_has_dl_mac_config_msg() {
  _oneof_case_[0] = kDlMacConfigMsg;
}
inline void flexran_message::clear_dl_mac_config_msg() {
  if (has_dl_mac_config_msg()) {
    delete msg_.dl_mac_config_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_dl_mac_config& flexran_message::dl_mac_config_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.dl_mac_config_msg)
  return has_dl_mac_config_msg()
      ? *msg_.dl_mac_config_msg_
      : ::protocol::flex_dl_mac_config::default_instance();
}
inline ::protocol::flex_dl_mac_config* flexran_message::mutable_dl_mac_config_msg() {
  if (!has_dl_mac_config_msg()) {
    clear_msg();
    set_has_dl_mac_config_msg();
    msg_.dl_mac_config_msg_ = new ::protocol::flex_dl_mac_config;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.dl_mac_config_msg)
  return msg_.dl_mac_config_msg_;
}
inline ::protocol::flex_dl_mac_config* flexran_message::release_dl_mac_config_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.dl_mac_config_msg)
  if (has_dl_mac_config_msg()) {
    clear_has_msg();
    ::protocol::flex_dl_mac_config* temp = msg_.dl_mac_config_msg_;
    msg_.dl_mac_config_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_dl_mac_config_msg(::protocol::flex_dl_mac_config* dl_mac_config_msg) {
  clear_msg();
  if (dl_mac_config_msg) {
    set_has_dl_mac_config_msg();
    msg_.dl_mac_config_msg_ = dl_mac_config_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.dl_mac_config_msg)
}

// optional .protocol.flex_ue_state_change ue_state_change_msg = 15;
inline bool flexran_message::has_ue_state_change_msg() const {
  return msg_case() == kUeStateChangeMsg;
}
inline void flexran_message::set_has_ue_state_change_msg() {
  _oneof_case_[0] = kUeStateChangeMsg;
}
inline void flexran_message::clear_ue_state_change_msg() {
  if (has_ue_state_change_msg()) {
    delete msg_.ue_state_change_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_ue_state_change& flexran_message::ue_state_change_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ue_state_change_msg)
  return has_ue_state_change_msg()
      ? *msg_.ue_state_change_msg_
      : ::protocol::flex_ue_state_change::default_instance();
}
inline ::protocol::flex_ue_state_change* flexran_message::mutable_ue_state_change_msg() {
  if (!has_ue_state_change_msg()) {
    clear_msg();
    set_has_ue_state_change_msg();
    msg_.ue_state_change_msg_ = new ::protocol::flex_ue_state_change;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ue_state_change_msg)
  return msg_.ue_state_change_msg_;
}
inline ::protocol::flex_ue_state_change* flexran_message::release_ue_state_change_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ue_state_change_msg)
  if (has_ue_state_change_msg()) {
    clear_has_msg();
    ::protocol::flex_ue_state_change* temp = msg_.ue_state_change_msg_;
    msg_.ue_state_change_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_ue_state_change_msg(::protocol::flex_ue_state_change* ue_state_change_msg) {
  clear_msg();
  if (ue_state_change_msg) {
    set_has_ue_state_change_msg();
    msg_.ue_state_change_msg_ = ue_state_change_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.ue_state_change_msg)
}

// optional .protocol.flex_control_delegation control_delegation_msg = 16;
inline bool flexran_message::has_control_delegation_msg() const {
  return msg_case() == kControlDelegationMsg;
}
inline void flexran_message::set_has_control_delegation_msg() {
  _oneof_case_[0] = kControlDelegationMsg;
}
inline void flexran_message::clear_control_delegation_msg() {
  if (has_control_delegation_msg()) {
    delete msg_.control_delegation_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_control_delegation& flexran_message::control_delegation_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.control_delegation_msg)
  return has_control_delegation_msg()
      ? *msg_.control_delegation_msg_
      : ::protocol::flex_control_delegation::default_instance();
}
inline ::protocol::flex_control_delegation* flexran_message::mutable_control_delegation_msg() {
  if (!has_control_delegation_msg()) {
    clear_msg();
    set_has_control_delegation_msg();
    msg_.control_delegation_msg_ = new ::protocol::flex_control_delegation;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.control_delegation_msg)
  return msg_.control_delegation_msg_;
}
inline ::protocol::flex_control_delegation* flexran_message::release_control_delegation_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.control_delegation_msg)
  if (has_control_delegation_msg()) {
    clear_has_msg();
    ::protocol::flex_control_delegation* temp = msg_.control_delegation_msg_;
    msg_.control_delegation_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_control_delegation_msg(::protocol::flex_control_delegation* control_delegation_msg) {
  clear_msg();
  if (control_delegation_msg) {
    set_has_control_delegation_msg();
    msg_.control_delegation_msg_ = control_delegation_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.control_delegation_msg)
}

// optional .protocol.flex_agent_reconfiguration agent_reconfiguration_msg = 17;
inline bool flexran_message::has_agent_reconfiguration_msg() const {
  return msg_case() == kAgentReconfigurationMsg;
}
inline void flexran_message::set_has_agent_reconfiguration_msg() {
  _oneof_case_[0] = kAgentReconfigurationMsg;
}
inline void flexran_message::clear_agent_reconfiguration_msg() {
  if (has_agent_reconfiguration_msg()) {
    delete msg_.agent_reconfiguration_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_agent_reconfiguration& flexran_message::agent_reconfiguration_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.agent_reconfiguration_msg)
  return has_agent_reconfiguration_msg()
      ? *msg_.agent_reconfiguration_msg_
      : ::protocol::flex_agent_reconfiguration::default_instance();
}
inline ::protocol::flex_agent_reconfiguration* flexran_message::mutable_agent_reconfiguration_msg() {
  if (!has_agent_reconfiguration_msg()) {
    clear_msg();
    set_has_agent_reconfiguration_msg();
    msg_.agent_reconfiguration_msg_ = new ::protocol::flex_agent_reconfiguration;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.agent_reconfiguration_msg)
  return msg_.agent_reconfiguration_msg_;
}
inline ::protocol::flex_agent_reconfiguration* flexran_message::release_agent_reconfiguration_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.agent_reconfiguration_msg)
  if (has_agent_reconfiguration_msg()) {
    clear_has_msg();
    ::protocol::flex_agent_reconfiguration* temp = msg_.agent_reconfiguration_msg_;
    msg_.agent_reconfiguration_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_agent_reconfiguration_msg(::protocol::flex_agent_reconfiguration* agent_reconfiguration_msg) {
  clear_msg();
  if (agent_reconfiguration_msg) {
    set_has_agent_reconfiguration_msg();
    msg_.agent_reconfiguration_msg_ = agent_reconfiguration_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.agent_reconfiguration_msg)
}

// optional .protocol.flex_rrc_triggering rrc_triggering = 18;
inline bool flexran_message::has_rrc_triggering() const {
  return msg_case() == kRrcTriggering;
}
inline void flexran_message::set_has_rrc_triggering() {
  _oneof_case_[0] = kRrcTriggering;
}
inline void flexran_message::clear_rrc_triggering() {
  if (has_rrc_triggering()) {
    delete msg_.rrc_triggering_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_rrc_triggering& flexran_message::rrc_triggering() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.rrc_triggering)
  return has_rrc_triggering()
      ? *msg_.rrc_triggering_
      : ::protocol::flex_rrc_triggering::default_instance();
}
inline ::protocol::flex_rrc_triggering* flexran_message::mutable_rrc_triggering() {
  if (!has_rrc_triggering()) {
    clear_msg();
    set_has_rrc_triggering();
    msg_.rrc_triggering_ = new ::protocol::flex_rrc_triggering;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.rrc_triggering)
  return msg_.rrc_triggering_;
}
inline ::protocol::flex_rrc_triggering* flexran_message::release_rrc_triggering() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.rrc_triggering)
  if (has_rrc_triggering()) {
    clear_has_msg();
    ::protocol::flex_rrc_triggering* temp = msg_.rrc_triggering_;
    msg_.rrc_triggering_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_rrc_triggering(::protocol::flex_rrc_triggering* rrc_triggering) {
  clear_msg();
  if (rrc_triggering) {
    set_has_rrc_triggering();
    msg_.rrc_triggering_ = rrc_triggering;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.rrc_triggering)
}

// optional .protocol.flex_ul_mac_config ul_mac_config_msg = 19;
inline bool flexran_message::has_ul_mac_config_msg() const {
  return msg_case() == kUlMacConfigMsg;
}
inline void flexran_message::set_has_ul_mac_config_msg() {
  _oneof_case_[0] = kUlMacConfigMsg;
}
inline void flexran_message::clear_ul_mac_config_msg() {
  if (has_ul_mac_config_msg()) {
    delete msg_.ul_mac_config_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_ul_mac_config& flexran_message::ul_mac_config_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ul_mac_config_msg)
  return has_ul_mac_config_msg()
      ? *msg_.ul_mac_config_msg_
      : ::protocol::flex_ul_mac_config::default_instance();
}
inline ::protocol::flex_ul_mac_config* flexran_message::mutable_ul_mac_config_msg() {
  if (!has_ul_mac_config_msg()) {
    clear_msg();
    set_has_ul_mac_config_msg();
    msg_.ul_mac_config_msg_ = new ::protocol::flex_ul_mac_config;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ul_mac_config_msg)
  return msg_.ul_mac_config_msg_;
}
inline ::protocol::flex_ul_mac_config* flexran_message::release_ul_mac_config_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ul_mac_config_msg)
  if (has_ul_mac_config_msg()) {
    clear_has_msg();
    ::protocol::flex_ul_mac_config* temp = msg_.ul_mac_config_msg_;
    msg_.ul_mac_config_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_ul_mac_config_msg(::protocol::flex_ul_mac_config* ul_mac_config_msg) {
  clear_msg();
  if (ul_mac_config_msg) {
    set_has_ul_mac_config_msg();
    msg_.ul_mac_config_msg_ = ul_mac_config_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.ul_mac_config_msg)
}

// optional .protocol.flex_disconnect disconnect_msg = 20;
inline bool flexran_message::has_disconnect_msg() const {
  return msg_case() == kDisconnectMsg;
}
inline void flexran_message::set_has_disconnect_msg() {
  _oneof_case_[0] = kDisconnectMsg;
}
inline void flexran_message::clear_disconnect_msg() {
  if (has_disconnect_msg()) {
    delete msg_.disconnect_msg_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_disconnect& flexran_message::disconnect_msg() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.disconnect_msg)
  return has_disconnect_msg()
      ? *msg_.disconnect_msg_
      : ::protocol::flex_disconnect::default_instance();
}
inline ::protocol::flex_disconnect* flexran_message::mutable_disconnect_msg() {
  if (!has_disconnect_msg()) {
    clear_msg();
    set_has_disconnect_msg();
    msg_.disconnect_msg_ = new ::protocol::flex_disconnect;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.disconnect_msg)
  return msg_.disconnect_msg_;
}
inline ::protocol::flex_disconnect* flexran_message::release_disconnect_msg() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.disconnect_msg)
  if (has_disconnect_msg()) {
    clear_has_msg();
    ::protocol::flex_disconnect* temp = msg_.disconnect_msg_;
    msg_.disconnect_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_disconnect_msg(::protocol::flex_disconnect* disconnect_msg) {
  clear_msg();
  if (disconnect_msg) {
    set_has_disconnect_msg();
    msg_.disconnect_msg_ = disconnect_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.disconnect_msg)
}

// optional .protocol.flex_ho_command ho_command = 21;
inline bool flexran_message::has_ho_command() const {
  return msg_case() == kHoCommand;
}
inline void flexran_message::set_has_ho_command() {
  _oneof_case_[0] = kHoCommand;
}
inline void flexran_message::clear_ho_command() {
  if (has_ho_command()) {
    delete msg_.ho_command_;
    clear_has_msg();
  }
}
inline  const ::protocol::flex_ho_command& flexran_message::ho_command() const {
  // @@protoc_insertion_point(field_get:protocol.flexran_message.ho_command)
  return has_ho_command()
      ? *msg_.ho_command_
      : ::protocol::flex_ho_command::default_instance();
}
inline ::protocol::flex_ho_command* flexran_message::mutable_ho_command() {
  if (!has_ho_command()) {
    clear_msg();
    set_has_ho_command();
    msg_.ho_command_ = new ::protocol::flex_ho_command;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flexran_message.ho_command)
  return msg_.ho_command_;
}
inline ::protocol::flex_ho_command* flexran_message::release_ho_command() {
  // @@protoc_insertion_point(field_release:protocol.flexran_message.ho_command)
  if (has_ho_command()) {
    clear_has_msg();
    ::protocol::flex_ho_command* temp = msg_.ho_command_;
    msg_.ho_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flexran_message::set_allocated_ho_command(::protocol::flex_ho_command* ho_command) {
  clear_msg();
  if (ho_command) {
    set_has_ho_command();
    msg_.ho_command_ = ho_command;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flexran_message.ho_command)
}

inline bool flexran_message::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void flexran_message::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline flexran_message::MsgCase flexran_message::msg_case() const {
  return flexran_message::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// flex_hello

// optional .protocol.flex_header header = 1;
inline bool flex_hello::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_hello::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_hello::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_hello::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_hello::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_hello.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_hello::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_hello.header)
  return header_;
}
inline ::protocol::flex_header* flex_hello::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_hello.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_hello::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_hello.header)
}

// optional uint64 bs_id = 2;
inline bool flex_hello::has_bs_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_hello::set_has_bs_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_hello::clear_has_bs_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_hello::clear_bs_id() {
  bs_id_ = GOOGLE_ULONGLONG(0);
  clear_has_bs_id();
}
inline ::google::protobuf::uint64 flex_hello::bs_id() const {
  // @@protoc_insertion_point(field_get:protocol.flex_hello.bs_id)
  return bs_id_;
}
inline void flex_hello::set_bs_id(::google::protobuf::uint64 value) {
  set_has_bs_id();
  bs_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_hello.bs_id)
}

// repeated .protocol.flex_bs_capability capabilities = 3;
inline int flex_hello::capabilities_size() const {
  return capabilities_.size();
}
inline void flex_hello::clear_capabilities() {
  capabilities_.Clear();
}
inline ::protocol::flex_bs_capability flex_hello::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_hello.capabilities)
  return static_cast< ::protocol::flex_bs_capability >(capabilities_.Get(index));
}
inline void flex_hello::set_capabilities(int index, ::protocol::flex_bs_capability value) {
  assert(::protocol::flex_bs_capability_IsValid(value));
  capabilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.flex_hello.capabilities)
}
inline void flex_hello::add_capabilities(::protocol::flex_bs_capability value) {
  assert(::protocol::flex_bs_capability_IsValid(value));
  capabilities_.Add(value);
  // @@protoc_insertion_point(field_add:protocol.flex_hello.capabilities)
}
inline const ::google::protobuf::RepeatedField<int>&
flex_hello::capabilities() const {
  // @@protoc_insertion_point(field_list:protocol.flex_hello.capabilities)
  return capabilities_;
}
inline ::google::protobuf::RepeatedField<int>*
flex_hello::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_hello.capabilities)
  return &capabilities_;
}

// repeated .protocol.flex_bs_split splits = 4;
inline int flex_hello::splits_size() const {
  return splits_.size();
}
inline void flex_hello::clear_splits() {
  splits_.Clear();
}
inline ::protocol::flex_bs_split flex_hello::splits(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_hello.splits)
  return static_cast< ::protocol::flex_bs_split >(splits_.Get(index));
}
inline void flex_hello::set_splits(int index, ::protocol::flex_bs_split value) {
  assert(::protocol::flex_bs_split_IsValid(value));
  splits_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.flex_hello.splits)
}
inline void flex_hello::add_splits(::protocol::flex_bs_split value) {
  assert(::protocol::flex_bs_split_IsValid(value));
  splits_.Add(value);
  // @@protoc_insertion_point(field_add:protocol.flex_hello.splits)
}
inline const ::google::protobuf::RepeatedField<int>&
flex_hello::splits() const {
  // @@protoc_insertion_point(field_list:protocol.flex_hello.splits)
  return splits_;
}
inline ::google::protobuf::RepeatedField<int>*
flex_hello::mutable_splits() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_hello.splits)
  return &splits_;
}

// -------------------------------------------------------------------

// flex_echo_request

// optional .protocol.flex_header header = 1;
inline bool flex_echo_request::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_echo_request::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_echo_request::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_echo_request::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_echo_request::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_echo_request.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_echo_request::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_echo_request.header)
  return header_;
}
inline ::protocol::flex_header* flex_echo_request::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_echo_request.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_echo_request::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_echo_request.header)
}

// -------------------------------------------------------------------

// flex_echo_reply

// optional .protocol.flex_header header = 1;
inline bool flex_echo_reply::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_echo_reply::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_echo_reply::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_echo_reply::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_echo_reply::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_echo_reply.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_echo_reply::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_echo_reply.header)
  return header_;
}
inline ::protocol::flex_header* flex_echo_reply::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_echo_reply.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_echo_reply::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_echo_reply.header)
}

// -------------------------------------------------------------------

// flex_stats_request

// optional .protocol.flex_header header = 1;
inline bool flex_stats_request::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_stats_request::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_stats_request::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_stats_request::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_stats_request::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_request.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_stats_request::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_request.header)
  return header_;
}
inline ::protocol::flex_header* flex_stats_request::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_stats_request.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_stats_request::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_stats_request.header)
}

// optional .protocol.flex_stats_type type = 2;
inline bool flex_stats_request::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_stats_request::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_stats_request::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_stats_request::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::protocol::flex_stats_type flex_stats_request::type() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_request.type)
  return static_cast< ::protocol::flex_stats_type >(type_);
}
inline void flex_stats_request::set_type(::protocol::flex_stats_type value) {
  assert(::protocol::flex_stats_type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_stats_request.type)
}

// optional .protocol.flex_complete_stats_request complete_stats_request = 3;
inline bool flex_stats_request::has_complete_stats_request() const {
  return body_case() == kCompleteStatsRequest;
}
inline void flex_stats_request::set_has_complete_stats_request() {
  _oneof_case_[0] = kCompleteStatsRequest;
}
inline void flex_stats_request::clear_complete_stats_request() {
  if (has_complete_stats_request()) {
    delete body_.complete_stats_request_;
    clear_has_body();
  }
}
inline  const ::protocol::flex_complete_stats_request& flex_stats_request::complete_stats_request() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_request.complete_stats_request)
  return has_complete_stats_request()
      ? *body_.complete_stats_request_
      : ::protocol::flex_complete_stats_request::default_instance();
}
inline ::protocol::flex_complete_stats_request* flex_stats_request::mutable_complete_stats_request() {
  if (!has_complete_stats_request()) {
    clear_body();
    set_has_complete_stats_request();
    body_.complete_stats_request_ = new ::protocol::flex_complete_stats_request;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_request.complete_stats_request)
  return body_.complete_stats_request_;
}
inline ::protocol::flex_complete_stats_request* flex_stats_request::release_complete_stats_request() {
  // @@protoc_insertion_point(field_release:protocol.flex_stats_request.complete_stats_request)
  if (has_complete_stats_request()) {
    clear_has_body();
    ::protocol::flex_complete_stats_request* temp = body_.complete_stats_request_;
    body_.complete_stats_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flex_stats_request::set_allocated_complete_stats_request(::protocol::flex_complete_stats_request* complete_stats_request) {
  clear_body();
  if (complete_stats_request) {
    set_has_complete_stats_request();
    body_.complete_stats_request_ = complete_stats_request;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_stats_request.complete_stats_request)
}

// optional .protocol.flex_cell_stats_request cell_stats_request = 4;
inline bool flex_stats_request::has_cell_stats_request() const {
  return body_case() == kCellStatsRequest;
}
inline void flex_stats_request::set_has_cell_stats_request() {
  _oneof_case_[0] = kCellStatsRequest;
}
inline void flex_stats_request::clear_cell_stats_request() {
  if (has_cell_stats_request()) {
    delete body_.cell_stats_request_;
    clear_has_body();
  }
}
inline  const ::protocol::flex_cell_stats_request& flex_stats_request::cell_stats_request() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_request.cell_stats_request)
  return has_cell_stats_request()
      ? *body_.cell_stats_request_
      : ::protocol::flex_cell_stats_request::default_instance();
}
inline ::protocol::flex_cell_stats_request* flex_stats_request::mutable_cell_stats_request() {
  if (!has_cell_stats_request()) {
    clear_body();
    set_has_cell_stats_request();
    body_.cell_stats_request_ = new ::protocol::flex_cell_stats_request;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_request.cell_stats_request)
  return body_.cell_stats_request_;
}
inline ::protocol::flex_cell_stats_request* flex_stats_request::release_cell_stats_request() {
  // @@protoc_insertion_point(field_release:protocol.flex_stats_request.cell_stats_request)
  if (has_cell_stats_request()) {
    clear_has_body();
    ::protocol::flex_cell_stats_request* temp = body_.cell_stats_request_;
    body_.cell_stats_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flex_stats_request::set_allocated_cell_stats_request(::protocol::flex_cell_stats_request* cell_stats_request) {
  clear_body();
  if (cell_stats_request) {
    set_has_cell_stats_request();
    body_.cell_stats_request_ = cell_stats_request;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_stats_request.cell_stats_request)
}

// optional .protocol.flex_ue_stats_request ue_stats_request = 5;
inline bool flex_stats_request::has_ue_stats_request() const {
  return body_case() == kUeStatsRequest;
}
inline void flex_stats_request::set_has_ue_stats_request() {
  _oneof_case_[0] = kUeStatsRequest;
}
inline void flex_stats_request::clear_ue_stats_request() {
  if (has_ue_stats_request()) {
    delete body_.ue_stats_request_;
    clear_has_body();
  }
}
inline  const ::protocol::flex_ue_stats_request& flex_stats_request::ue_stats_request() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_request.ue_stats_request)
  return has_ue_stats_request()
      ? *body_.ue_stats_request_
      : ::protocol::flex_ue_stats_request::default_instance();
}
inline ::protocol::flex_ue_stats_request* flex_stats_request::mutable_ue_stats_request() {
  if (!has_ue_stats_request()) {
    clear_body();
    set_has_ue_stats_request();
    body_.ue_stats_request_ = new ::protocol::flex_ue_stats_request;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_request.ue_stats_request)
  return body_.ue_stats_request_;
}
inline ::protocol::flex_ue_stats_request* flex_stats_request::release_ue_stats_request() {
  // @@protoc_insertion_point(field_release:protocol.flex_stats_request.ue_stats_request)
  if (has_ue_stats_request()) {
    clear_has_body();
    ::protocol::flex_ue_stats_request* temp = body_.ue_stats_request_;
    body_.ue_stats_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flex_stats_request::set_allocated_ue_stats_request(::protocol::flex_ue_stats_request* ue_stats_request) {
  clear_body();
  if (ue_stats_request) {
    set_has_ue_stats_request();
    body_.ue_stats_request_ = ue_stats_request;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_stats_request.ue_stats_request)
}

inline bool flex_stats_request::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void flex_stats_request::clear_has_body() {
  _oneof_case_[0] = BODY_NOT_SET;
}
inline flex_stats_request::BodyCase flex_stats_request::body_case() const {
  return flex_stats_request::BodyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// flex_stats_reply

// optional .protocol.flex_header header = 1;
inline bool flex_stats_reply::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_stats_reply::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_stats_reply::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_stats_reply::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_stats_reply::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_reply.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_stats_reply::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_reply.header)
  return header_;
}
inline ::protocol::flex_header* flex_stats_reply::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_stats_reply.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_stats_reply::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_stats_reply.header)
}

// repeated .protocol.flex_ue_stats_report ue_report = 2;
inline int flex_stats_reply::ue_report_size() const {
  return ue_report_.size();
}
inline void flex_stats_reply::clear_ue_report() {
  ue_report_.Clear();
}
inline const ::protocol::flex_ue_stats_report& flex_stats_reply::ue_report(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_reply.ue_report)
  return ue_report_.Get(index);
}
inline ::protocol::flex_ue_stats_report* flex_stats_reply::mutable_ue_report(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_reply.ue_report)
  return ue_report_.Mutable(index);
}
inline ::protocol::flex_ue_stats_report* flex_stats_reply::add_ue_report() {
  // @@protoc_insertion_point(field_add:protocol.flex_stats_reply.ue_report)
  return ue_report_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_ue_stats_report >*
flex_stats_reply::mutable_ue_report() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_stats_reply.ue_report)
  return &ue_report_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_ue_stats_report >&
flex_stats_reply::ue_report() const {
  // @@protoc_insertion_point(field_list:protocol.flex_stats_reply.ue_report)
  return ue_report_;
}

// repeated .protocol.flex_cell_stats_report cell_report = 3;
inline int flex_stats_reply::cell_report_size() const {
  return cell_report_.size();
}
inline void flex_stats_reply::clear_cell_report() {
  cell_report_.Clear();
}
inline const ::protocol::flex_cell_stats_report& flex_stats_reply::cell_report(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_stats_reply.cell_report)
  return cell_report_.Get(index);
}
inline ::protocol::flex_cell_stats_report* flex_stats_reply::mutable_cell_report(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_stats_reply.cell_report)
  return cell_report_.Mutable(index);
}
inline ::protocol::flex_cell_stats_report* flex_stats_reply::add_cell_report() {
  // @@protoc_insertion_point(field_add:protocol.flex_stats_reply.cell_report)
  return cell_report_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_cell_stats_report >*
flex_stats_reply::mutable_cell_report() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_stats_reply.cell_report)
  return &cell_report_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_cell_stats_report >&
flex_stats_reply::cell_report() const {
  // @@protoc_insertion_point(field_list:protocol.flex_stats_reply.cell_report)
  return cell_report_;
}

// -------------------------------------------------------------------

// flex_sf_trigger

// optional .protocol.flex_header header = 1;
inline bool flex_sf_trigger::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_sf_trigger::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_sf_trigger::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_sf_trigger::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_sf_trigger::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_sf_trigger.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_sf_trigger::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_sf_trigger.header)
  return header_;
}
inline ::protocol::flex_header* flex_sf_trigger::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_sf_trigger.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_sf_trigger::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_sf_trigger.header)
}

// optional uint32 sfn_sf = 2;
inline bool flex_sf_trigger::has_sfn_sf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_sf_trigger::set_has_sfn_sf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_sf_trigger::clear_has_sfn_sf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_sf_trigger::clear_sfn_sf() {
  sfn_sf_ = 0u;
  clear_has_sfn_sf();
}
inline ::google::protobuf::uint32 flex_sf_trigger::sfn_sf() const {
  // @@protoc_insertion_point(field_get:protocol.flex_sf_trigger.sfn_sf)
  return sfn_sf_;
}
inline void flex_sf_trigger::set_sfn_sf(::google::protobuf::uint32 value) {
  set_has_sfn_sf();
  sfn_sf_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_sf_trigger.sfn_sf)
}

// repeated .protocol.flex_dl_info dl_info = 3;
inline int flex_sf_trigger::dl_info_size() const {
  return dl_info_.size();
}
inline void flex_sf_trigger::clear_dl_info() {
  dl_info_.Clear();
}
inline const ::protocol::flex_dl_info& flex_sf_trigger::dl_info(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_sf_trigger.dl_info)
  return dl_info_.Get(index);
}
inline ::protocol::flex_dl_info* flex_sf_trigger::mutable_dl_info(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_sf_trigger.dl_info)
  return dl_info_.Mutable(index);
}
inline ::protocol::flex_dl_info* flex_sf_trigger::add_dl_info() {
  // @@protoc_insertion_point(field_add:protocol.flex_sf_trigger.dl_info)
  return dl_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_info >*
flex_sf_trigger::mutable_dl_info() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_sf_trigger.dl_info)
  return &dl_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_info >&
flex_sf_trigger::dl_info() const {
  // @@protoc_insertion_point(field_list:protocol.flex_sf_trigger.dl_info)
  return dl_info_;
}

// repeated .protocol.flex_ul_info ul_info = 4;
inline int flex_sf_trigger::ul_info_size() const {
  return ul_info_.size();
}
inline void flex_sf_trigger::clear_ul_info() {
  ul_info_.Clear();
}
inline const ::protocol::flex_ul_info& flex_sf_trigger::ul_info(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_sf_trigger.ul_info)
  return ul_info_.Get(index);
}
inline ::protocol::flex_ul_info* flex_sf_trigger::mutable_ul_info(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_sf_trigger.ul_info)
  return ul_info_.Mutable(index);
}
inline ::protocol::flex_ul_info* flex_sf_trigger::add_ul_info() {
  // @@protoc_insertion_point(field_add:protocol.flex_sf_trigger.ul_info)
  return ul_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_ul_info >*
flex_sf_trigger::mutable_ul_info() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_sf_trigger.ul_info)
  return &ul_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_ul_info >&
flex_sf_trigger::ul_info() const {
  // @@protoc_insertion_point(field_list:protocol.flex_sf_trigger.ul_info)
  return ul_info_;
}

// -------------------------------------------------------------------

// flex_ul_sr_info

// optional .protocol.flex_header header = 1;
inline bool flex_ul_sr_info::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_ul_sr_info::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_ul_sr_info::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_ul_sr_info::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_ul_sr_info::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_sr_info.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_ul_sr_info::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_ul_sr_info.header)
  return header_;
}
inline ::protocol::flex_header* flex_ul_sr_info::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ul_sr_info.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_ul_sr_info::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ul_sr_info.header)
}

// optional uint32 sfn_sf = 2;
inline bool flex_ul_sr_info::has_sfn_sf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_ul_sr_info::set_has_sfn_sf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_ul_sr_info::clear_has_sfn_sf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_ul_sr_info::clear_sfn_sf() {
  sfn_sf_ = 0u;
  clear_has_sfn_sf();
}
inline ::google::protobuf::uint32 flex_ul_sr_info::sfn_sf() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_sr_info.sfn_sf)
  return sfn_sf_;
}
inline void flex_ul_sr_info::set_sfn_sf(::google::protobuf::uint32 value) {
  set_has_sfn_sf();
  sfn_sf_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_ul_sr_info.sfn_sf)
}

// repeated uint32 rnti = 3;
inline int flex_ul_sr_info::rnti_size() const {
  return rnti_.size();
}
inline void flex_ul_sr_info::clear_rnti() {
  rnti_.Clear();
}
inline ::google::protobuf::uint32 flex_ul_sr_info::rnti(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_sr_info.rnti)
  return rnti_.Get(index);
}
inline void flex_ul_sr_info::set_rnti(int index, ::google::protobuf::uint32 value) {
  rnti_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.flex_ul_sr_info.rnti)
}
inline void flex_ul_sr_info::add_rnti(::google::protobuf::uint32 value) {
  rnti_.Add(value);
  // @@protoc_insertion_point(field_add:protocol.flex_ul_sr_info.rnti)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
flex_ul_sr_info::rnti() const {
  // @@protoc_insertion_point(field_list:protocol.flex_ul_sr_info.rnti)
  return rnti_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
flex_ul_sr_info::mutable_rnti() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_ul_sr_info.rnti)
  return &rnti_;
}

// -------------------------------------------------------------------

// flex_enb_config_request

// optional .protocol.flex_header header = 1;
inline bool flex_enb_config_request::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_enb_config_request::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_enb_config_request::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_enb_config_request::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_enb_config_request::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_request.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_enb_config_request::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_enb_config_request.header)
  return header_;
}
inline ::protocol::flex_header* flex_enb_config_request::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_enb_config_request.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_enb_config_request::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_enb_config_request.header)
}

// -------------------------------------------------------------------

// flex_enb_config_reply

// optional .protocol.flex_header header = 1;
inline bool flex_enb_config_reply::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_enb_config_reply::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_enb_config_reply::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_enb_config_reply::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_enb_config_reply::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_reply.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_enb_config_reply::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_enb_config_reply.header)
  return header_;
}
inline ::protocol::flex_header* flex_enb_config_reply::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_enb_config_reply.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_enb_config_reply::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_enb_config_reply.header)
}

// optional uint64 eNB_id = 2;
inline bool flex_enb_config_reply::has_enb_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_enb_config_reply::set_has_enb_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_enb_config_reply::clear_has_enb_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_enb_config_reply::clear_enb_id() {
  enb_id_ = GOOGLE_ULONGLONG(0);
  clear_has_enb_id();
}
inline ::google::protobuf::uint64 flex_enb_config_reply::enb_id() const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_reply.eNB_id)
  return enb_id_;
}
inline void flex_enb_config_reply::set_enb_id(::google::protobuf::uint64 value) {
  set_has_enb_id();
  enb_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_enb_config_reply.eNB_id)
}

// repeated .protocol.flex_cell_config cell_config = 3;
inline int flex_enb_config_reply::cell_config_size() const {
  return cell_config_.size();
}
inline void flex_enb_config_reply::clear_cell_config() {
  cell_config_.Clear();
}
inline const ::protocol::flex_cell_config& flex_enb_config_reply::cell_config(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_reply.cell_config)
  return cell_config_.Get(index);
}
inline ::protocol::flex_cell_config* flex_enb_config_reply::mutable_cell_config(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_enb_config_reply.cell_config)
  return cell_config_.Mutable(index);
}
inline ::protocol::flex_cell_config* flex_enb_config_reply::add_cell_config() {
  // @@protoc_insertion_point(field_add:protocol.flex_enb_config_reply.cell_config)
  return cell_config_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_cell_config >*
flex_enb_config_reply::mutable_cell_config() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_enb_config_reply.cell_config)
  return &cell_config_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_cell_config >&
flex_enb_config_reply::cell_config() const {
  // @@protoc_insertion_point(field_list:protocol.flex_enb_config_reply.cell_config)
  return cell_config_;
}

// optional uint32 device_spec = 4;
inline bool flex_enb_config_reply::has_device_spec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_enb_config_reply::set_has_device_spec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_enb_config_reply::clear_has_device_spec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_enb_config_reply::clear_device_spec() {
  device_spec_ = 0u;
  clear_has_device_spec();
}
inline ::google::protobuf::uint32 flex_enb_config_reply::device_spec() const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_reply.device_spec)
  return device_spec_;
}
inline void flex_enb_config_reply::set_device_spec(::google::protobuf::uint32 value) {
  set_has_device_spec();
  device_spec_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_enb_config_reply.device_spec)
}

// optional .protocol.flex_s1ap_config s1ap = 5;
inline bool flex_enb_config_reply::has_s1ap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_enb_config_reply::set_has_s1ap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_enb_config_reply::clear_has_s1ap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_enb_config_reply::clear_s1ap() {
  if (s1ap_ != NULL) s1ap_->::protocol::flex_s1ap_config::Clear();
  clear_has_s1ap();
}
inline const ::protocol::flex_s1ap_config& flex_enb_config_reply::s1ap() const {
  // @@protoc_insertion_point(field_get:protocol.flex_enb_config_reply.s1ap)
  return s1ap_ != NULL ? *s1ap_
                         : *::protocol::flex_s1ap_config::internal_default_instance();
}
inline ::protocol::flex_s1ap_config* flex_enb_config_reply::mutable_s1ap() {
  set_has_s1ap();
  if (s1ap_ == NULL) {
    s1ap_ = new ::protocol::flex_s1ap_config;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_enb_config_reply.s1ap)
  return s1ap_;
}
inline ::protocol::flex_s1ap_config* flex_enb_config_reply::release_s1ap() {
  // @@protoc_insertion_point(field_release:protocol.flex_enb_config_reply.s1ap)
  clear_has_s1ap();
  ::protocol::flex_s1ap_config* temp = s1ap_;
  s1ap_ = NULL;
  return temp;
}
inline void flex_enb_config_reply::set_allocated_s1ap(::protocol::flex_s1ap_config* s1ap) {
  delete s1ap_;
  s1ap_ = s1ap;
  if (s1ap) {
    set_has_s1ap();
  } else {
    clear_has_s1ap();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_enb_config_reply.s1ap)
}

// -------------------------------------------------------------------

// flex_ue_config_request

// optional .protocol.flex_header header = 1;
inline bool flex_ue_config_request::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_ue_config_request::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_ue_config_request::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_ue_config_request::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_ue_config_request::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_config_request.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_ue_config_request::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_ue_config_request.header)
  return header_;
}
inline ::protocol::flex_header* flex_ue_config_request::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ue_config_request.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_ue_config_request::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ue_config_request.header)
}

// -------------------------------------------------------------------

// flex_ue_config_reply

// optional .protocol.flex_header header = 1;
inline bool flex_ue_config_reply::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_ue_config_reply::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_ue_config_reply::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_ue_config_reply::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_ue_config_reply::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_config_reply.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_ue_config_reply::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_ue_config_reply.header)
  return header_;
}
inline ::protocol::flex_header* flex_ue_config_reply::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ue_config_reply.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_ue_config_reply::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ue_config_reply.header)
}

// repeated .protocol.flex_ue_config ue_config = 2;
inline int flex_ue_config_reply::ue_config_size() const {
  return ue_config_.size();
}
inline void flex_ue_config_reply::clear_ue_config() {
  ue_config_.Clear();
}
inline const ::protocol::flex_ue_config& flex_ue_config_reply::ue_config(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_config_reply.ue_config)
  return ue_config_.Get(index);
}
inline ::protocol::flex_ue_config* flex_ue_config_reply::mutable_ue_config(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_ue_config_reply.ue_config)
  return ue_config_.Mutable(index);
}
inline ::protocol::flex_ue_config* flex_ue_config_reply::add_ue_config() {
  // @@protoc_insertion_point(field_add:protocol.flex_ue_config_reply.ue_config)
  return ue_config_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_ue_config >*
flex_ue_config_reply::mutable_ue_config() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_ue_config_reply.ue_config)
  return &ue_config_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_ue_config >&
flex_ue_config_reply::ue_config() const {
  // @@protoc_insertion_point(field_list:protocol.flex_ue_config_reply.ue_config)
  return ue_config_;
}

// -------------------------------------------------------------------

// flex_lc_config_request

// optional .protocol.flex_header header = 1;
inline bool flex_lc_config_request::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_lc_config_request::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_lc_config_request::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_lc_config_request::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_lc_config_request::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config_request.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_lc_config_request::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_lc_config_request.header)
  return header_;
}
inline ::protocol::flex_header* flex_lc_config_request::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_lc_config_request.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_lc_config_request::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_lc_config_request.header)
}

// -------------------------------------------------------------------

// flex_lc_config_reply

// optional .protocol.flex_header header = 1;
inline bool flex_lc_config_reply::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_lc_config_reply::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_lc_config_reply::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_lc_config_reply::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_lc_config_reply::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config_reply.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_lc_config_reply::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_lc_config_reply.header)
  return header_;
}
inline ::protocol::flex_header* flex_lc_config_reply::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_lc_config_reply.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_lc_config_reply::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_lc_config_reply.header)
}

// repeated .protocol.flex_lc_ue_config lc_ue_config = 2;
inline int flex_lc_config_reply::lc_ue_config_size() const {
  return lc_ue_config_.size();
}
inline void flex_lc_config_reply::clear_lc_ue_config() {
  lc_ue_config_.Clear();
}
inline const ::protocol::flex_lc_ue_config& flex_lc_config_reply::lc_ue_config(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config_reply.lc_ue_config)
  return lc_ue_config_.Get(index);
}
inline ::protocol::flex_lc_ue_config* flex_lc_config_reply::mutable_lc_ue_config(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_lc_config_reply.lc_ue_config)
  return lc_ue_config_.Mutable(index);
}
inline ::protocol::flex_lc_ue_config* flex_lc_config_reply::add_lc_ue_config() {
  // @@protoc_insertion_point(field_add:protocol.flex_lc_config_reply.lc_ue_config)
  return lc_ue_config_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_lc_ue_config >*
flex_lc_config_reply::mutable_lc_ue_config() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_lc_config_reply.lc_ue_config)
  return &lc_ue_config_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_lc_ue_config >&
flex_lc_config_reply::lc_ue_config() const {
  // @@protoc_insertion_point(field_list:protocol.flex_lc_config_reply.lc_ue_config)
  return lc_ue_config_;
}

// -------------------------------------------------------------------

// flex_dl_mac_config

// optional .protocol.flex_header header = 1;
inline bool flex_dl_mac_config::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_dl_mac_config::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_dl_mac_config::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_dl_mac_config::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_dl_mac_config::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_dl_mac_config::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_dl_mac_config.header)
  return header_;
}
inline ::protocol::flex_header* flex_dl_mac_config::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_dl_mac_config.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_dl_mac_config::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_dl_mac_config.header)
}

// optional uint32 sfn_sf = 2;
inline bool flex_dl_mac_config::has_sfn_sf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_dl_mac_config::set_has_sfn_sf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_dl_mac_config::clear_has_sfn_sf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_dl_mac_config::clear_sfn_sf() {
  sfn_sf_ = 0u;
  clear_has_sfn_sf();
}
inline ::google::protobuf::uint32 flex_dl_mac_config::sfn_sf() const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.sfn_sf)
  return sfn_sf_;
}
inline void flex_dl_mac_config::set_sfn_sf(::google::protobuf::uint32 value) {
  set_has_sfn_sf();
  sfn_sf_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_dl_mac_config.sfn_sf)
}

// repeated .protocol.flex_dl_data dl_ue_data = 3;
inline int flex_dl_mac_config::dl_ue_data_size() const {
  return dl_ue_data_.size();
}
inline void flex_dl_mac_config::clear_dl_ue_data() {
  dl_ue_data_.Clear();
}
inline const ::protocol::flex_dl_data& flex_dl_mac_config::dl_ue_data(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.dl_ue_data)
  return dl_ue_data_.Get(index);
}
inline ::protocol::flex_dl_data* flex_dl_mac_config::mutable_dl_ue_data(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_dl_mac_config.dl_ue_data)
  return dl_ue_data_.Mutable(index);
}
inline ::protocol::flex_dl_data* flex_dl_mac_config::add_dl_ue_data() {
  // @@protoc_insertion_point(field_add:protocol.flex_dl_mac_config.dl_ue_data)
  return dl_ue_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_data >*
flex_dl_mac_config::mutable_dl_ue_data() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_dl_mac_config.dl_ue_data)
  return &dl_ue_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_data >&
flex_dl_mac_config::dl_ue_data() const {
  // @@protoc_insertion_point(field_list:protocol.flex_dl_mac_config.dl_ue_data)
  return dl_ue_data_;
}

// repeated .protocol.flex_dl_rar dl_rar = 4;
inline int flex_dl_mac_config::dl_rar_size() const {
  return dl_rar_.size();
}
inline void flex_dl_mac_config::clear_dl_rar() {
  dl_rar_.Clear();
}
inline const ::protocol::flex_dl_rar& flex_dl_mac_config::dl_rar(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.dl_rar)
  return dl_rar_.Get(index);
}
inline ::protocol::flex_dl_rar* flex_dl_mac_config::mutable_dl_rar(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_dl_mac_config.dl_rar)
  return dl_rar_.Mutable(index);
}
inline ::protocol::flex_dl_rar* flex_dl_mac_config::add_dl_rar() {
  // @@protoc_insertion_point(field_add:protocol.flex_dl_mac_config.dl_rar)
  return dl_rar_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_rar >*
flex_dl_mac_config::mutable_dl_rar() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_dl_mac_config.dl_rar)
  return &dl_rar_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_rar >&
flex_dl_mac_config::dl_rar() const {
  // @@protoc_insertion_point(field_list:protocol.flex_dl_mac_config.dl_rar)
  return dl_rar_;
}

// repeated .protocol.flex_dl_broadcast dl_broadcast = 5;
inline int flex_dl_mac_config::dl_broadcast_size() const {
  return dl_broadcast_.size();
}
inline void flex_dl_mac_config::clear_dl_broadcast() {
  dl_broadcast_.Clear();
}
inline const ::protocol::flex_dl_broadcast& flex_dl_mac_config::dl_broadcast(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.dl_broadcast)
  return dl_broadcast_.Get(index);
}
inline ::protocol::flex_dl_broadcast* flex_dl_mac_config::mutable_dl_broadcast(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_dl_mac_config.dl_broadcast)
  return dl_broadcast_.Mutable(index);
}
inline ::protocol::flex_dl_broadcast* flex_dl_mac_config::add_dl_broadcast() {
  // @@protoc_insertion_point(field_add:protocol.flex_dl_mac_config.dl_broadcast)
  return dl_broadcast_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_broadcast >*
flex_dl_mac_config::mutable_dl_broadcast() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_dl_mac_config.dl_broadcast)
  return &dl_broadcast_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_dl_broadcast >&
flex_dl_mac_config::dl_broadcast() const {
  // @@protoc_insertion_point(field_list:protocol.flex_dl_mac_config.dl_broadcast)
  return dl_broadcast_;
}

// repeated .protocol.flex_pdcch_ofdm_sym_count ofdm_sym = 6;
inline int flex_dl_mac_config::ofdm_sym_size() const {
  return ofdm_sym_.size();
}
inline void flex_dl_mac_config::clear_ofdm_sym() {
  ofdm_sym_.Clear();
}
inline const ::protocol::flex_pdcch_ofdm_sym_count& flex_dl_mac_config::ofdm_sym(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_dl_mac_config.ofdm_sym)
  return ofdm_sym_.Get(index);
}
inline ::protocol::flex_pdcch_ofdm_sym_count* flex_dl_mac_config::mutable_ofdm_sym(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_dl_mac_config.ofdm_sym)
  return ofdm_sym_.Mutable(index);
}
inline ::protocol::flex_pdcch_ofdm_sym_count* flex_dl_mac_config::add_ofdm_sym() {
  // @@protoc_insertion_point(field_add:protocol.flex_dl_mac_config.ofdm_sym)
  return ofdm_sym_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_pdcch_ofdm_sym_count >*
flex_dl_mac_config::mutable_ofdm_sym() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_dl_mac_config.ofdm_sym)
  return &ofdm_sym_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_pdcch_ofdm_sym_count >&
flex_dl_mac_config::ofdm_sym() const {
  // @@protoc_insertion_point(field_list:protocol.flex_dl_mac_config.ofdm_sym)
  return ofdm_sym_;
}

// -------------------------------------------------------------------

// flex_ul_mac_config

// optional .protocol.flex_header header = 1;
inline bool flex_ul_mac_config::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_ul_mac_config::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_ul_mac_config::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_ul_mac_config::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_ul_mac_config::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_mac_config.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_ul_mac_config::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_ul_mac_config.header)
  return header_;
}
inline ::protocol::flex_header* flex_ul_mac_config::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ul_mac_config.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_ul_mac_config::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ul_mac_config.header)
}

// optional uint32 sfn_sf = 2;
inline bool flex_ul_mac_config::has_sfn_sf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_ul_mac_config::set_has_sfn_sf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_ul_mac_config::clear_has_sfn_sf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_ul_mac_config::clear_sfn_sf() {
  sfn_sf_ = 0u;
  clear_has_sfn_sf();
}
inline ::google::protobuf::uint32 flex_ul_mac_config::sfn_sf() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_mac_config.sfn_sf)
  return sfn_sf_;
}
inline void flex_ul_mac_config::set_sfn_sf(::google::protobuf::uint32 value) {
  set_has_sfn_sf();
  sfn_sf_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_ul_mac_config.sfn_sf)
}

// repeated .protocol.flex_ul_data ul_ue_data = 3;
inline int flex_ul_mac_config::ul_ue_data_size() const {
  return ul_ue_data_.size();
}
inline void flex_ul_mac_config::clear_ul_ue_data() {
  ul_ue_data_.Clear();
}
inline const ::protocol::flex_ul_data& flex_ul_mac_config::ul_ue_data(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_ul_mac_config.ul_ue_data)
  return ul_ue_data_.Get(index);
}
inline ::protocol::flex_ul_data* flex_ul_mac_config::mutable_ul_ue_data(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_ul_mac_config.ul_ue_data)
  return ul_ue_data_.Mutable(index);
}
inline ::protocol::flex_ul_data* flex_ul_mac_config::add_ul_ue_data() {
  // @@protoc_insertion_point(field_add:protocol.flex_ul_mac_config.ul_ue_data)
  return ul_ue_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_ul_data >*
flex_ul_mac_config::mutable_ul_ue_data() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_ul_mac_config.ul_ue_data)
  return &ul_ue_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_ul_data >&
flex_ul_mac_config::ul_ue_data() const {
  // @@protoc_insertion_point(field_list:protocol.flex_ul_mac_config.ul_ue_data)
  return ul_ue_data_;
}

// -------------------------------------------------------------------

// flex_rrc_triggering

// optional .protocol.flex_header header = 1;
inline bool flex_rrc_triggering::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_rrc_triggering::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_rrc_triggering::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_rrc_triggering::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_rrc_triggering::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_rrc_triggering.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_rrc_triggering::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_rrc_triggering.header)
  return header_;
}
inline ::protocol::flex_header* flex_rrc_triggering::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_rrc_triggering.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_rrc_triggering::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_rrc_triggering.header)
}

// optional string rrc_trigger = 2;
inline bool flex_rrc_triggering::has_rrc_trigger() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_rrc_triggering::set_has_rrc_trigger() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_rrc_triggering::clear_has_rrc_trigger() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_rrc_triggering::clear_rrc_trigger() {
  rrc_trigger_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rrc_trigger();
}
inline const ::std::string& flex_rrc_triggering::rrc_trigger() const {
  // @@protoc_insertion_point(field_get:protocol.flex_rrc_triggering.rrc_trigger)
  return rrc_trigger_.GetNoArena();
}
inline void flex_rrc_triggering::set_rrc_trigger(const ::std::string& value) {
  set_has_rrc_trigger();
  rrc_trigger_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.flex_rrc_triggering.rrc_trigger)
}
#if LANG_CXX11
inline void flex_rrc_triggering::set_rrc_trigger(::std::string&& value) {
  set_has_rrc_trigger();
  rrc_trigger_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_rrc_triggering.rrc_trigger)
}
#endif
inline void flex_rrc_triggering::set_rrc_trigger(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rrc_trigger();
  rrc_trigger_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.flex_rrc_triggering.rrc_trigger)
}
inline void flex_rrc_triggering::set_rrc_trigger(const char* value, size_t size) {
  set_has_rrc_trigger();
  rrc_trigger_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_rrc_triggering.rrc_trigger)
}
inline ::std::string* flex_rrc_triggering::mutable_rrc_trigger() {
  set_has_rrc_trigger();
  // @@protoc_insertion_point(field_mutable:protocol.flex_rrc_triggering.rrc_trigger)
  return rrc_trigger_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* flex_rrc_triggering::release_rrc_trigger() {
  // @@protoc_insertion_point(field_release:protocol.flex_rrc_triggering.rrc_trigger)
  clear_has_rrc_trigger();
  return rrc_trigger_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void flex_rrc_triggering::set_allocated_rrc_trigger(::std::string* rrc_trigger) {
  if (rrc_trigger != NULL) {
    set_has_rrc_trigger();
  } else {
    clear_has_rrc_trigger();
  }
  rrc_trigger_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rrc_trigger);
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_rrc_triggering.rrc_trigger)
}

// optional .protocol.flex_measurement_info meas_info = 3;
inline bool flex_rrc_triggering::has_meas_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_rrc_triggering::set_has_meas_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_rrc_triggering::clear_has_meas_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_rrc_triggering::clear_meas_info() {
  if (meas_info_ != NULL) meas_info_->::protocol::flex_measurement_info::Clear();
  clear_has_meas_info();
}
inline const ::protocol::flex_measurement_info& flex_rrc_triggering::meas_info() const {
  // @@protoc_insertion_point(field_get:protocol.flex_rrc_triggering.meas_info)
  return meas_info_ != NULL ? *meas_info_
                         : *::protocol::flex_measurement_info::internal_default_instance();
}
inline ::protocol::flex_measurement_info* flex_rrc_triggering::mutable_meas_info() {
  set_has_meas_info();
  if (meas_info_ == NULL) {
    meas_info_ = new ::protocol::flex_measurement_info;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_rrc_triggering.meas_info)
  return meas_info_;
}
inline ::protocol::flex_measurement_info* flex_rrc_triggering::release_meas_info() {
  // @@protoc_insertion_point(field_release:protocol.flex_rrc_triggering.meas_info)
  clear_has_meas_info();
  ::protocol::flex_measurement_info* temp = meas_info_;
  meas_info_ = NULL;
  return temp;
}
inline void flex_rrc_triggering::set_allocated_meas_info(::protocol::flex_measurement_info* meas_info) {
  delete meas_info_;
  meas_info_ = meas_info;
  if (meas_info) {
    set_has_meas_info();
  } else {
    clear_has_meas_info();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_rrc_triggering.meas_info)
}

// -------------------------------------------------------------------

// flex_ho_command

// optional .protocol.flex_header header = 1;
inline bool flex_ho_command::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_ho_command::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_ho_command::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_ho_command::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_ho_command::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ho_command.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_ho_command::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_ho_command.header)
  return header_;
}
inline ::protocol::flex_header* flex_ho_command::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ho_command.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_ho_command::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ho_command.header)
}

// optional uint32 rnti = 2;
inline bool flex_ho_command::has_rnti() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_ho_command::set_has_rnti() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_ho_command::clear_has_rnti() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_ho_command::clear_rnti() {
  rnti_ = 0u;
  clear_has_rnti();
}
inline ::google::protobuf::uint32 flex_ho_command::rnti() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ho_command.rnti)
  return rnti_;
}
inline void flex_ho_command::set_rnti(::google::protobuf::uint32 value) {
  set_has_rnti();
  rnti_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_ho_command.rnti)
}

// optional uint32 target_phy_cell_id = 3;
inline bool flex_ho_command::has_target_phy_cell_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_ho_command::set_has_target_phy_cell_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_ho_command::clear_has_target_phy_cell_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_ho_command::clear_target_phy_cell_id() {
  target_phy_cell_id_ = 0u;
  clear_has_target_phy_cell_id();
}
inline ::google::protobuf::uint32 flex_ho_command::target_phy_cell_id() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ho_command.target_phy_cell_id)
  return target_phy_cell_id_;
}
inline void flex_ho_command::set_target_phy_cell_id(::google::protobuf::uint32 value) {
  set_has_target_phy_cell_id();
  target_phy_cell_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_ho_command.target_phy_cell_id)
}

// -------------------------------------------------------------------

// flex_ue_state_change

// optional .protocol.flex_header header = 1;
inline bool flex_ue_state_change::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_ue_state_change::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_ue_state_change::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_ue_state_change::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_ue_state_change::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_state_change.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_ue_state_change::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_ue_state_change.header)
  return header_;
}
inline ::protocol::flex_header* flex_ue_state_change::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_ue_state_change.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_ue_state_change::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ue_state_change.header)
}

// optional uint32 type = 2;
inline bool flex_ue_state_change::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_ue_state_change::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_ue_state_change::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_ue_state_change::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 flex_ue_state_change::type() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_state_change.type)
  return type_;
}
inline void flex_ue_state_change::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_ue_state_change.type)
}

// optional .protocol.flex_ue_config config = 3;
inline bool flex_ue_state_change::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_ue_state_change::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_ue_state_change::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_ue_state_change::clear_config() {
  if (config_ != NULL) config_->::protocol::flex_ue_config::Clear();
  clear_has_config();
}
inline const ::protocol::flex_ue_config& flex_ue_state_change::config() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_state_change.config)
  return config_ != NULL ? *config_
                         : *::protocol::flex_ue_config::internal_default_instance();
}
inline ::protocol::flex_ue_config* flex_ue_state_change::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::protocol::flex_ue_config;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_ue_state_change.config)
  return config_;
}
inline ::protocol::flex_ue_config* flex_ue_state_change::release_config() {
  // @@protoc_insertion_point(field_release:protocol.flex_ue_state_change.config)
  clear_has_config();
  ::protocol::flex_ue_config* temp = config_;
  config_ = NULL;
  return temp;
}
inline void flex_ue_state_change::set_allocated_config(::protocol::flex_ue_config* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_ue_state_change.config)
}

// -------------------------------------------------------------------

// flex_control_delegation

// optional .protocol.flex_header header = 1;
inline bool flex_control_delegation::has_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_control_delegation::set_has_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_control_delegation::clear_has_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_control_delegation::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_control_delegation::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_control_delegation.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_control_delegation::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_control_delegation.header)
  return header_;
}
inline ::protocol::flex_header* flex_control_delegation::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_control_delegation.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_control_delegation::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_control_delegation.header)
}

// optional uint32 delegation_type = 2;
inline bool flex_control_delegation::has_delegation_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_control_delegation::set_has_delegation_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_control_delegation::clear_has_delegation_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_control_delegation::clear_delegation_type() {
  delegation_type_ = 0u;
  clear_has_delegation_type();
}
inline ::google::protobuf::uint32 flex_control_delegation::delegation_type() const {
  // @@protoc_insertion_point(field_get:protocol.flex_control_delegation.delegation_type)
  return delegation_type_;
}
inline void flex_control_delegation::set_delegation_type(::google::protobuf::uint32 value) {
  set_has_delegation_type();
  delegation_type_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_control_delegation.delegation_type)
}

// optional bytes payload = 3;
inline bool flex_control_delegation::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_control_delegation::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_control_delegation::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_control_delegation::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& flex_control_delegation::payload() const {
  // @@protoc_insertion_point(field_get:protocol.flex_control_delegation.payload)
  return payload_.GetNoArena();
}
inline void flex_control_delegation::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.flex_control_delegation.payload)
}
#if LANG_CXX11
inline void flex_control_delegation::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_control_delegation.payload)
}
#endif
inline void flex_control_delegation::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.flex_control_delegation.payload)
}
inline void flex_control_delegation::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_control_delegation.payload)
}
inline ::std::string* flex_control_delegation::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:protocol.flex_control_delegation.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* flex_control_delegation::release_payload() {
  // @@protoc_insertion_point(field_release:protocol.flex_control_delegation.payload)
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void flex_control_delegation::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_control_delegation.payload)
}

// optional string name = 4;
inline bool flex_control_delegation::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_control_delegation::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_control_delegation::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_control_delegation::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& flex_control_delegation::name() const {
  // @@protoc_insertion_point(field_get:protocol.flex_control_delegation.name)
  return name_.GetNoArena();
}
inline void flex_control_delegation::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.flex_control_delegation.name)
}
#if LANG_CXX11
inline void flex_control_delegation::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_control_delegation.name)
}
#endif
inline void flex_control_delegation::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.flex_control_delegation.name)
}
inline void flex_control_delegation::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_control_delegation.name)
}
inline ::std::string* flex_control_delegation::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:protocol.flex_control_delegation.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* flex_control_delegation::release_name() {
  // @@protoc_insertion_point(field_release:protocol.flex_control_delegation.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void flex_control_delegation::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_control_delegation.name)
}

// -------------------------------------------------------------------

// flex_agent_reconfiguration

// optional .protocol.flex_header header = 1;
inline bool flex_agent_reconfiguration::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_agent_reconfiguration::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_agent_reconfiguration::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_agent_reconfiguration::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_agent_reconfiguration::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_agent_reconfiguration.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_agent_reconfiguration::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_agent_reconfiguration.header)
  return header_;
}
inline ::protocol::flex_header* flex_agent_reconfiguration::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_agent_reconfiguration.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_agent_reconfiguration::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_agent_reconfiguration.header)
}

// optional string policy = 2;
inline bool flex_agent_reconfiguration::has_policy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_agent_reconfiguration::set_has_policy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_agent_reconfiguration::clear_has_policy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_agent_reconfiguration::clear_policy() {
  policy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_policy();
}
inline const ::std::string& flex_agent_reconfiguration::policy() const {
  // @@protoc_insertion_point(field_get:protocol.flex_agent_reconfiguration.policy)
  return policy_.GetNoArena();
}
inline void flex_agent_reconfiguration::set_policy(const ::std::string& value) {
  set_has_policy();
  policy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.flex_agent_reconfiguration.policy)
}
#if LANG_CXX11
inline void flex_agent_reconfiguration::set_policy(::std::string&& value) {
  set_has_policy();
  policy_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_agent_reconfiguration.policy)
}
#endif
inline void flex_agent_reconfiguration::set_policy(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_policy();
  policy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.flex_agent_reconfiguration.policy)
}
inline void flex_agent_reconfiguration::set_policy(const char* value, size_t size) {
  set_has_policy();
  policy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_agent_reconfiguration.policy)
}
inline ::std::string* flex_agent_reconfiguration::mutable_policy() {
  set_has_policy();
  // @@protoc_insertion_point(field_mutable:protocol.flex_agent_reconfiguration.policy)
  return policy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* flex_agent_reconfiguration::release_policy() {
  // @@protoc_insertion_point(field_release:protocol.flex_agent_reconfiguration.policy)
  clear_has_policy();
  return policy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void flex_agent_reconfiguration::set_allocated_policy(::std::string* policy) {
  if (policy != NULL) {
    set_has_policy();
  } else {
    clear_has_policy();
  }
  policy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), policy);
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_agent_reconfiguration.policy)
}

// -------------------------------------------------------------------

// flex_echo_request_latency

// -------------------------------------------------------------------

// flex_echo_reply_latency

// -------------------------------------------------------------------

// flex_disconnect

// optional .protocol.flex_header header = 1;
inline bool flex_disconnect::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_disconnect::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_disconnect::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_disconnect::clear_header() {
  if (header_ != NULL) header_->::protocol::flex_header::Clear();
  clear_has_header();
}
inline const ::protocol::flex_header& flex_disconnect::header() const {
  // @@protoc_insertion_point(field_get:protocol.flex_disconnect.header)
  return header_ != NULL ? *header_
                         : *::protocol::flex_header::internal_default_instance();
}
inline ::protocol::flex_header* flex_disconnect::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::protocol::flex_header;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_disconnect.header)
  return header_;
}
inline ::protocol::flex_header* flex_disconnect::release_header() {
  // @@protoc_insertion_point(field_release:protocol.flex_disconnect.header)
  clear_has_header();
  ::protocol::flex_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void flex_disconnect::set_allocated_header(::protocol::flex_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_disconnect.header)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace protocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::flexran_direction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flexran_direction>() {
  return ::protocol::flexran_direction_descriptor();
}
template <> struct is_proto_enum< ::protocol::flexran_err> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flexran_err>() {
  return ::protocol::flexran_err_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_bs_capability> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_bs_capability>() {
  return ::protocol::flex_bs_capability_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_bs_split> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_bs_split>() {
  return ::protocol::flex_bs_split_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_flexran_2eproto__INCLUDED
