// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config_common.proto

#ifndef PROTOBUF_config_5fcommon_2eproto__INCLUDED
#define PROTOBUF_config_5fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace protocol {
class flex_a1_event;
class flex_a1_eventDefaultTypeInternal;
extern flex_a1_eventDefaultTypeInternal _flex_a1_event_default_instance_;
class flex_a2_event;
class flex_a2_eventDefaultTypeInternal;
extern flex_a2_eventDefaultTypeInternal _flex_a2_event_default_instance_;
class flex_a3_event;
class flex_a3_eventDefaultTypeInternal;
extern flex_a3_eventDefaultTypeInternal _flex_a3_event_default_instance_;
class flex_a4_event;
class flex_a4_eventDefaultTypeInternal;
extern flex_a4_eventDefaultTypeInternal _flex_a4_event_default_instance_;
class flex_a5_event;
class flex_a5_eventDefaultTypeInternal;
extern flex_a5_eventDefaultTypeInternal _flex_a5_event_default_instance_;
class flex_cqi_config;
class flex_cqi_configDefaultTypeInternal;
extern flex_cqi_configDefaultTypeInternal _flex_cqi_config_default_instance_;
class flex_drx_config;
class flex_drx_configDefaultTypeInternal;
extern flex_drx_configDefaultTypeInternal _flex_drx_config_default_instance_;
class flex_gummei;
class flex_gummeiDefaultTypeInternal;
extern flex_gummeiDefaultTypeInternal _flex_gummei_default_instance_;
class flex_lc_config;
class flex_lc_configDefaultTypeInternal;
extern flex_lc_configDefaultTypeInternal _flex_lc_config_default_instance_;
class flex_measurement_event;
class flex_measurement_eventDefaultTypeInternal;
extern flex_measurement_eventDefaultTypeInternal _flex_measurement_event_default_instance_;
class flex_measurement_info;
class flex_measurement_infoDefaultTypeInternal;
extern flex_measurement_infoDefaultTypeInternal _flex_measurement_info_default_instance_;
class flex_per_event;
class flex_per_eventDefaultTypeInternal;
extern flex_per_eventDefaultTypeInternal _flex_per_event_default_instance_;
class flex_plmn;
class flex_plmnDefaultTypeInternal;
extern flex_plmnDefaultTypeInternal _flex_plmn_default_instance_;
class flex_s1ap_mme;
class flex_s1ap_mmeDefaultTypeInternal;
extern flex_s1ap_mmeDefaultTypeInternal _flex_s1ap_mme_default_instance_;
class flex_scell_config;
class flex_scell_configDefaultTypeInternal;
extern flex_scell_configDefaultTypeInternal _flex_scell_config_default_instance_;
class flex_si_config;
class flex_si_configDefaultTypeInternal;
extern flex_si_configDefaultTypeInternal _flex_si_config_default_instance_;
class flex_si_message;
class flex_si_messageDefaultTypeInternal;
extern flex_si_messageDefaultTypeInternal _flex_si_message_default_instance_;
class flex_slice;
class flex_sliceDefaultTypeInternal;
extern flex_sliceDefaultTypeInternal _flex_slice_default_instance_;
class flex_slice_dl_ul_config;
class flex_slice_dl_ul_configDefaultTypeInternal;
extern flex_slice_dl_ul_configDefaultTypeInternal _flex_slice_dl_ul_config_default_instance_;
class flex_slice_static;
class flex_slice_staticDefaultTypeInternal;
extern flex_slice_staticDefaultTypeInternal _flex_slice_static_default_instance_;
class flex_sps_config;
class flex_sps_configDefaultTypeInternal;
extern flex_sps_configDefaultTypeInternal _flex_sps_config_default_instance_;
class flex_sr_config;
class flex_sr_configDefaultTypeInternal;
extern flex_sr_configDefaultTypeInternal _flex_sr_config_default_instance_;
class flex_ue_capabilities;
class flex_ue_capabilitiesDefaultTypeInternal;
extern flex_ue_capabilitiesDefaultTypeInternal _flex_ue_capabilities_default_instance_;
}  // namespace protocol

namespace protocol {

namespace protobuf_config_5fcommon_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_config_5fcommon_2eproto

enum flex_hopping_mode {
  FLHM_INTER = 0,
  FLHM_INTERINTRA = 1
};
bool flex_hopping_mode_IsValid(int value);
const flex_hopping_mode flex_hopping_mode_MIN = FLHM_INTER;
const flex_hopping_mode flex_hopping_mode_MAX = FLHM_INTERINTRA;
const int flex_hopping_mode_ARRAYSIZE = flex_hopping_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_hopping_mode_descriptor();
inline const ::std::string& flex_hopping_mode_Name(flex_hopping_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_hopping_mode_descriptor(), value);
}
inline bool flex_hopping_mode_Parse(
    const ::std::string& name, flex_hopping_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_hopping_mode>(
    flex_hopping_mode_descriptor(), name, value);
}
enum flex_phich_resource {
  FLPR_ONE_SIXTH = 0,
  FLPR_HALF = 1,
  FLPR_ONE = 2,
  FLPR_TWO = 3
};
bool flex_phich_resource_IsValid(int value);
const flex_phich_resource flex_phich_resource_MIN = FLPR_ONE_SIXTH;
const flex_phich_resource flex_phich_resource_MAX = FLPR_TWO;
const int flex_phich_resource_ARRAYSIZE = flex_phich_resource_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_phich_resource_descriptor();
inline const ::std::string& flex_phich_resource_Name(flex_phich_resource value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_phich_resource_descriptor(), value);
}
inline bool flex_phich_resource_Parse(
    const ::std::string& name, flex_phich_resource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_phich_resource>(
    flex_phich_resource_descriptor(), name, value);
}
enum flex_phich_duration {
  FLPD_NORMAL = 0,
  FLPD_EXTENDED = 1
};
bool flex_phich_duration_IsValid(int value);
const flex_phich_duration flex_phich_duration_MIN = FLPD_NORMAL;
const flex_phich_duration flex_phich_duration_MAX = FLPD_EXTENDED;
const int flex_phich_duration_ARRAYSIZE = flex_phich_duration_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_phich_duration_descriptor();
inline const ::std::string& flex_phich_duration_Name(flex_phich_duration value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_phich_duration_descriptor(), value);
}
inline bool flex_phich_duration_Parse(
    const ::std::string& name, flex_phich_duration* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_phich_duration>(
    flex_phich_duration_descriptor(), name, value);
}
enum flex_ul_cyclic_prefix_length {
  FLUCPL_NORMAL = 0,
  FLUCPL_EXTENDED = 1
};
bool flex_ul_cyclic_prefix_length_IsValid(int value);
const flex_ul_cyclic_prefix_length flex_ul_cyclic_prefix_length_MIN = FLUCPL_NORMAL;
const flex_ul_cyclic_prefix_length flex_ul_cyclic_prefix_length_MAX = FLUCPL_EXTENDED;
const int flex_ul_cyclic_prefix_length_ARRAYSIZE = flex_ul_cyclic_prefix_length_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_ul_cyclic_prefix_length_descriptor();
inline const ::std::string& flex_ul_cyclic_prefix_length_Name(flex_ul_cyclic_prefix_length value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_ul_cyclic_prefix_length_descriptor(), value);
}
inline bool flex_ul_cyclic_prefix_length_Parse(
    const ::std::string& name, flex_ul_cyclic_prefix_length* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_ul_cyclic_prefix_length>(
    flex_ul_cyclic_prefix_length_descriptor(), name, value);
}
enum flex_dl_cyclic_prefix_length {
  FLDCPL_NORMAL = 0,
  FLDCPL_EXTENDED = 1
};
bool flex_dl_cyclic_prefix_length_IsValid(int value);
const flex_dl_cyclic_prefix_length flex_dl_cyclic_prefix_length_MIN = FLDCPL_NORMAL;
const flex_dl_cyclic_prefix_length flex_dl_cyclic_prefix_length_MAX = FLDCPL_EXTENDED;
const int flex_dl_cyclic_prefix_length_ARRAYSIZE = flex_dl_cyclic_prefix_length_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_dl_cyclic_prefix_length_descriptor();
inline const ::std::string& flex_dl_cyclic_prefix_length_Name(flex_dl_cyclic_prefix_length value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_dl_cyclic_prefix_length_descriptor(), value);
}
inline bool flex_dl_cyclic_prefix_length_Parse(
    const ::std::string& name, flex_dl_cyclic_prefix_length* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_dl_cyclic_prefix_length>(
    flex_dl_cyclic_prefix_length_descriptor(), name, value);
}
enum flex_duplex_mode {
  FLDM_TDD = 0,
  FLDM_FDD = 1
};
bool flex_duplex_mode_IsValid(int value);
const flex_duplex_mode flex_duplex_mode_MIN = FLDM_TDD;
const flex_duplex_mode flex_duplex_mode_MAX = FLDM_FDD;
const int flex_duplex_mode_ARRAYSIZE = flex_duplex_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_duplex_mode_descriptor();
inline const ::std::string& flex_duplex_mode_Name(flex_duplex_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_duplex_mode_descriptor(), value);
}
inline bool flex_duplex_mode_Parse(
    const ::std::string& name, flex_duplex_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_duplex_mode>(
    flex_duplex_mode_descriptor(), name, value);
}
enum flex_qam {
  FLEQ_MOD_16QAM = 0,
  FLEQ_MOD_64QAM = 1
};
bool flex_qam_IsValid(int value);
const flex_qam flex_qam_MIN = FLEQ_MOD_16QAM;
const flex_qam flex_qam_MAX = FLEQ_MOD_64QAM;
const int flex_qam_ARRAYSIZE = flex_qam_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_qam_descriptor();
inline const ::std::string& flex_qam_Name(flex_qam value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_qam_descriptor(), value);
}
inline bool flex_qam_Parse(
    const ::std::string& name, flex_qam* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_qam>(
    flex_qam_descriptor(), name, value);
}
enum flex_slice_algorithm {
  None = 0,
  Static = 1,
  NVS = 2
};
bool flex_slice_algorithm_IsValid(int value);
const flex_slice_algorithm flex_slice_algorithm_MIN = None;
const flex_slice_algorithm flex_slice_algorithm_MAX = NVS;
const int flex_slice_algorithm_ARRAYSIZE = flex_slice_algorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_slice_algorithm_descriptor();
inline const ::std::string& flex_slice_algorithm_Name(flex_slice_algorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_slice_algorithm_descriptor(), value);
}
inline bool flex_slice_algorithm_Parse(
    const ::std::string& name, flex_slice_algorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_slice_algorithm>(
    flex_slice_algorithm_descriptor(), name, value);
}
enum flex_meas_gap_config_pattern {
  FLMGCP_GP1 = 0,
  FLMGCP_GP2 = 1,
  FLMGCP_OFF = 2
};
bool flex_meas_gap_config_pattern_IsValid(int value);
const flex_meas_gap_config_pattern flex_meas_gap_config_pattern_MIN = FLMGCP_GP1;
const flex_meas_gap_config_pattern flex_meas_gap_config_pattern_MAX = FLMGCP_OFF;
const int flex_meas_gap_config_pattern_ARRAYSIZE = flex_meas_gap_config_pattern_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_meas_gap_config_pattern_descriptor();
inline const ::std::string& flex_meas_gap_config_pattern_Name(flex_meas_gap_config_pattern value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_meas_gap_config_pattern_descriptor(), value);
}
inline bool flex_meas_gap_config_pattern_Parse(
    const ::std::string& name, flex_meas_gap_config_pattern* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_meas_gap_config_pattern>(
    flex_meas_gap_config_pattern_descriptor(), name, value);
}
enum flex_setup_release_action {
  FLSRA_SETUP = 0,
  FLSRA_RELEASE = 1
};
bool flex_setup_release_action_IsValid(int value);
const flex_setup_release_action flex_setup_release_action_MIN = FLSRA_SETUP;
const flex_setup_release_action flex_setup_release_action_MAX = FLSRA_RELEASE;
const int flex_setup_release_action_ARRAYSIZE = flex_setup_release_action_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_setup_release_action_descriptor();
inline const ::std::string& flex_setup_release_action_Name(flex_setup_release_action value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_setup_release_action_descriptor(), value);
}
inline bool flex_setup_release_action_Parse(
    const ::std::string& name, flex_setup_release_action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_setup_release_action>(
    flex_setup_release_action_descriptor(), name, value);
}
enum flex_ue_transmission_antenna {
  FLUTA_NONE = 0,
  FLUTA_OPEN_LOOP = 1,
  FLUTA_CLOSED_LOOP = 2
};
bool flex_ue_transmission_antenna_IsValid(int value);
const flex_ue_transmission_antenna flex_ue_transmission_antenna_MIN = FLUTA_NONE;
const flex_ue_transmission_antenna flex_ue_transmission_antenna_MAX = FLUTA_CLOSED_LOOP;
const int flex_ue_transmission_antenna_ARRAYSIZE = flex_ue_transmission_antenna_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_ue_transmission_antenna_descriptor();
inline const ::std::string& flex_ue_transmission_antenna_Name(flex_ue_transmission_antenna value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_ue_transmission_antenna_descriptor(), value);
}
inline bool flex_ue_transmission_antenna_Parse(
    const ::std::string& name, flex_ue_transmission_antenna* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_ue_transmission_antenna>(
    flex_ue_transmission_antenna_descriptor(), name, value);
}
enum flex_aperiodic_cqi_report_mode {
  FLACRM_RM12 = 0,
  FLACRM_RM20 = 1,
  FLACRM_RM22 = 2,
  FLACRM_RM30 = 3,
  FLACRM_RM31 = 4,
  FLACRM_NONE = 5
};
bool flex_aperiodic_cqi_report_mode_IsValid(int value);
const flex_aperiodic_cqi_report_mode flex_aperiodic_cqi_report_mode_MIN = FLACRM_RM12;
const flex_aperiodic_cqi_report_mode flex_aperiodic_cqi_report_mode_MAX = FLACRM_NONE;
const int flex_aperiodic_cqi_report_mode_ARRAYSIZE = flex_aperiodic_cqi_report_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_aperiodic_cqi_report_mode_descriptor();
inline const ::std::string& flex_aperiodic_cqi_report_mode_Name(flex_aperiodic_cqi_report_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_aperiodic_cqi_report_mode_descriptor(), value);
}
inline bool flex_aperiodic_cqi_report_mode_Parse(
    const ::std::string& name, flex_aperiodic_cqi_report_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_aperiodic_cqi_report_mode>(
    flex_aperiodic_cqi_report_mode_descriptor(), name, value);
}
enum flex_tdd_ack_nack_feedback_mode {
  FLTANFM_BUNDLING = 0,
  FLTANFM_MULTIPLEXING = 1
};
bool flex_tdd_ack_nack_feedback_mode_IsValid(int value);
const flex_tdd_ack_nack_feedback_mode flex_tdd_ack_nack_feedback_mode_MIN = FLTANFM_BUNDLING;
const flex_tdd_ack_nack_feedback_mode flex_tdd_ack_nack_feedback_mode_MAX = FLTANFM_MULTIPLEXING;
const int flex_tdd_ack_nack_feedback_mode_ARRAYSIZE = flex_tdd_ack_nack_feedback_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_tdd_ack_nack_feedback_mode_descriptor();
inline const ::std::string& flex_tdd_ack_nack_feedback_mode_Name(flex_tdd_ack_nack_feedback_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_tdd_ack_nack_feedback_mode_descriptor(), value);
}
inline bool flex_tdd_ack_nack_feedback_mode_Parse(
    const ::std::string& name, flex_tdd_ack_nack_feedback_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_tdd_ack_nack_feedback_mode>(
    flex_tdd_ack_nack_feedback_mode_descriptor(), name, value);
}
enum flex_lc_direction {
  FLLCD_UL = 0,
  FLLCD_DL = 1,
  FLLCD_BOTH = 2
};
bool flex_lc_direction_IsValid(int value);
const flex_lc_direction flex_lc_direction_MIN = FLLCD_UL;
const flex_lc_direction flex_lc_direction_MAX = FLLCD_BOTH;
const int flex_lc_direction_ARRAYSIZE = flex_lc_direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_lc_direction_descriptor();
inline const ::std::string& flex_lc_direction_Name(flex_lc_direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_lc_direction_descriptor(), value);
}
inline bool flex_lc_direction_Parse(
    const ::std::string& name, flex_lc_direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_lc_direction>(
    flex_lc_direction_descriptor(), name, value);
}
enum flex_qos_bearer_type {
  FLQBT_NON_GBR = 0,
  FLQBT_GBR = 1
};
bool flex_qos_bearer_type_IsValid(int value);
const flex_qos_bearer_type flex_qos_bearer_type_MIN = FLQBT_NON_GBR;
const flex_qos_bearer_type flex_qos_bearer_type_MAX = FLQBT_GBR;
const int flex_qos_bearer_type_ARRAYSIZE = flex_qos_bearer_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_qos_bearer_type_descriptor();
inline const ::std::string& flex_qos_bearer_type_Name(flex_qos_bearer_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_qos_bearer_type_descriptor(), value);
}
inline bool flex_qos_bearer_type_Parse(
    const ::std::string& name, flex_qos_bearer_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_qos_bearer_type>(
    flex_qos_bearer_type_descriptor(), name, value);
}
enum flex_ue_state_change_type {
  FLUESC_UPDATED = 0,
  FLUESC_ACTIVATED = 1,
  FLUESC_DEACTIVATED = 2,
  FLUESC_MOVED = 3
};
bool flex_ue_state_change_type_IsValid(int value);
const flex_ue_state_change_type flex_ue_state_change_type_MIN = FLUESC_UPDATED;
const flex_ue_state_change_type flex_ue_state_change_type_MAX = FLUESC_MOVED;
const int flex_ue_state_change_type_ARRAYSIZE = flex_ue_state_change_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_ue_state_change_type_descriptor();
inline const ::std::string& flex_ue_state_change_type_Name(flex_ue_state_change_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_ue_state_change_type_descriptor(), value);
}
inline bool flex_ue_state_change_type_Parse(
    const ::std::string& name, flex_ue_state_change_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_ue_state_change_type>(
    flex_ue_state_change_type_descriptor(), name, value);
}
enum flex_mme_state {
  FLMMES_DISCONNECTED = 0,
  FLMMES_WAITING = 1,
  FLMMES_CONNECTED = 2,
  FLMMES_OVERLOAD = 3
};
bool flex_mme_state_IsValid(int value);
const flex_mme_state flex_mme_state_MIN = FLMMES_DISCONNECTED;
const flex_mme_state flex_mme_state_MAX = FLMMES_OVERLOAD;
const int flex_mme_state_ARRAYSIZE = flex_mme_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* flex_mme_state_descriptor();
inline const ::std::string& flex_mme_state_Name(flex_mme_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    flex_mme_state_descriptor(), value);
}
inline bool flex_mme_state_Parse(
    const ::std::string& name, flex_mme_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flex_mme_state>(
    flex_mme_state_descriptor(), name, value);
}
// ===================================================================

class flex_si_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_si_config) */ {
 public:
  flex_si_config();
  virtual ~flex_si_config();

  flex_si_config(const flex_si_config& from);

  inline flex_si_config& operator=(const flex_si_config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_si_config& default_instance();

  static inline const flex_si_config* internal_default_instance() {
    return reinterpret_cast<const flex_si_config*>(
               &_flex_si_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(flex_si_config* other);

  // implements Message ----------------------------------------------

  inline flex_si_config* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_si_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_si_config& from);
  void MergeFrom(const flex_si_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_si_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.flex_si_message si_message = 4;
  int si_message_size() const;
  void clear_si_message();
  static const int kSiMessageFieldNumber = 4;
  const ::protocol::flex_si_message& si_message(int index) const;
  ::protocol::flex_si_message* mutable_si_message(int index);
  ::protocol::flex_si_message* add_si_message();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_si_message >*
      mutable_si_message();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_si_message >&
      si_message() const;

  // optional uint32 sfn = 1;
  bool has_sfn() const;
  void clear_sfn();
  static const int kSfnFieldNumber = 1;
  ::google::protobuf::uint32 sfn() const;
  void set_sfn(::google::protobuf::uint32 value);

  // optional uint32 sib1_length = 2;
  bool has_sib1_length() const;
  void clear_sib1_length();
  static const int kSib1LengthFieldNumber = 2;
  ::google::protobuf::uint32 sib1_length() const;
  void set_sib1_length(::google::protobuf::uint32 value);

  // optional uint32 si_window_length = 3;
  bool has_si_window_length() const;
  void clear_si_window_length();
  static const int kSiWindowLengthFieldNumber = 3;
  ::google::protobuf::uint32 si_window_length() const;
  void set_si_window_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_si_config)
 private:
  void set_has_sfn();
  void clear_has_sfn();
  void set_has_sib1_length();
  void clear_has_sib1_length();
  void set_has_si_window_length();
  void clear_has_si_window_length();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_si_message > si_message_;
  ::google::protobuf::uint32 sfn_;
  ::google::protobuf::uint32 sib1_length_;
  ::google::protobuf::uint32 si_window_length_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_si_message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_si_message) */ {
 public:
  flex_si_message();
  virtual ~flex_si_message();

  flex_si_message(const flex_si_message& from);

  inline flex_si_message& operator=(const flex_si_message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_si_message& default_instance();

  static inline const flex_si_message* internal_default_instance() {
    return reinterpret_cast<const flex_si_message*>(
               &_flex_si_message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(flex_si_message* other);

  // implements Message ----------------------------------------------

  inline flex_si_message* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_si_message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_si_message& from);
  void MergeFrom(const flex_si_message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_si_message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 periodicity = 1;
  bool has_periodicity() const;
  void clear_periodicity();
  static const int kPeriodicityFieldNumber = 1;
  ::google::protobuf::uint32 periodicity() const;
  void set_periodicity(::google::protobuf::uint32 value);

  // optional uint32 length = 2;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_si_message)
 private:
  void set_has_periodicity();
  void clear_has_periodicity();
  void set_has_length();
  void clear_has_length();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 periodicity_;
  ::google::protobuf::uint32 length_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_slice_static : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_slice_static) */ {
 public:
  flex_slice_static();
  virtual ~flex_slice_static();

  flex_slice_static(const flex_slice_static& from);

  inline flex_slice_static& operator=(const flex_slice_static& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_slice_static& default_instance();

  static inline const flex_slice_static* internal_default_instance() {
    return reinterpret_cast<const flex_slice_static*>(
               &_flex_slice_static_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(flex_slice_static* other);

  // implements Message ----------------------------------------------

  inline flex_slice_static* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_slice_static* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_slice_static& from);
  void MergeFrom(const flex_slice_static& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_slice_static* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 posLow = 1;
  bool has_poslow() const;
  void clear_poslow();
  static const int kPosLowFieldNumber = 1;
  ::google::protobuf::uint32 poslow() const;
  void set_poslow(::google::protobuf::uint32 value);

  // optional uint32 posHigh = 2;
  bool has_poshigh() const;
  void clear_poshigh();
  static const int kPosHighFieldNumber = 2;
  ::google::protobuf::uint32 poshigh() const;
  void set_poshigh(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_slice_static)
 private:
  void set_has_poslow();
  void clear_has_poslow();
  void set_has_poshigh();
  void clear_has_poshigh();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 poslow_;
  ::google::protobuf::uint32 poshigh_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_slice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_slice) */ {
 public:
  flex_slice();
  virtual ~flex_slice();

  flex_slice(const flex_slice& from);

  inline flex_slice& operator=(const flex_slice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_slice& default_instance();

  enum ParamsCase {
    kStatic = 10,
    PARAMS_NOT_SET = 0,
  };

  static inline const flex_slice* internal_default_instance() {
    return reinterpret_cast<const flex_slice*>(
               &_flex_slice_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(flex_slice* other);

  // implements Message ----------------------------------------------

  inline flex_slice* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_slice* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_slice& from);
  void MergeFrom(const flex_slice& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_slice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string label = 2;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional string scheduler = 3;
  bool has_scheduler() const;
  void clear_scheduler();
  static const int kSchedulerFieldNumber = 3;
  const ::std::string& scheduler() const;
  void set_scheduler(const ::std::string& value);
  #if LANG_CXX11
  void set_scheduler(::std::string&& value);
  #endif
  void set_scheduler(const char* value);
  void set_scheduler(const char* value, size_t size);
  ::std::string* mutable_scheduler();
  ::std::string* release_scheduler();
  void set_allocated_scheduler(::std::string* scheduler);

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional .protocol.flex_slice_static static = 10;
  bool has_static_() const;
  void clear_static_();
  static const int kStaticFieldNumber = 10;
  const ::protocol::flex_slice_static& static_() const;
  ::protocol::flex_slice_static* mutable_static_();
  ::protocol::flex_slice_static* release_static_();
  void set_allocated_static_(::protocol::flex_slice_static* static_);

  ParamsCase params_case() const;
  // @@protoc_insertion_point(class_scope:protocol.flex_slice)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_label();
  void clear_has_label();
  void set_has_scheduler();
  void clear_has_scheduler();
  void set_has_static_();

  inline bool has_params() const;
  void clear_params();
  inline void clear_has_params();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr scheduler_;
  ::google::protobuf::uint32 id_;
  union ParamsUnion {
    ParamsUnion() {}
    ::protocol::flex_slice_static* static__;
  } params_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_slice_dl_ul_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_slice_dl_ul_config) */ {
 public:
  flex_slice_dl_ul_config();
  virtual ~flex_slice_dl_ul_config();

  flex_slice_dl_ul_config(const flex_slice_dl_ul_config& from);

  inline flex_slice_dl_ul_config& operator=(const flex_slice_dl_ul_config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_slice_dl_ul_config& default_instance();

  static inline const flex_slice_dl_ul_config* internal_default_instance() {
    return reinterpret_cast<const flex_slice_dl_ul_config*>(
               &_flex_slice_dl_ul_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(flex_slice_dl_ul_config* other);

  // implements Message ----------------------------------------------

  inline flex_slice_dl_ul_config* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_slice_dl_ul_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_slice_dl_ul_config& from);
  void MergeFrom(const flex_slice_dl_ul_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_slice_dl_ul_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.flex_slice slices = 2;
  int slices_size() const;
  void clear_slices();
  static const int kSlicesFieldNumber = 2;
  const ::protocol::flex_slice& slices(int index) const;
  ::protocol::flex_slice* mutable_slices(int index);
  ::protocol::flex_slice* add_slices();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_slice >*
      mutable_slices();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_slice >&
      slices() const;

  // optional string scheduler = 3;
  bool has_scheduler() const;
  void clear_scheduler();
  static const int kSchedulerFieldNumber = 3;
  const ::std::string& scheduler() const;
  void set_scheduler(const ::std::string& value);
  #if LANG_CXX11
  void set_scheduler(::std::string&& value);
  #endif
  void set_scheduler(const char* value);
  void set_scheduler(const char* value, size_t size);
  ::std::string* mutable_scheduler();
  ::std::string* release_scheduler();
  void set_allocated_scheduler(::std::string* scheduler);

  // optional .protocol.flex_slice_algorithm algorithm = 1;
  bool has_algorithm() const;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 1;
  ::protocol::flex_slice_algorithm algorithm() const;
  void set_algorithm(::protocol::flex_slice_algorithm value);

  // @@protoc_insertion_point(class_scope:protocol.flex_slice_dl_ul_config)
 private:
  void set_has_algorithm();
  void clear_has_algorithm();
  void set_has_scheduler();
  void clear_has_scheduler();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_slice > slices_;
  ::google::protobuf::internal::ArenaStringPtr scheduler_;
  int algorithm_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_drx_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_drx_config) */ {
 public:
  flex_drx_config();
  virtual ~flex_drx_config();

  flex_drx_config(const flex_drx_config& from);

  inline flex_drx_config& operator=(const flex_drx_config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_drx_config& default_instance();

  static inline const flex_drx_config* internal_default_instance() {
    return reinterpret_cast<const flex_drx_config*>(
               &_flex_drx_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(flex_drx_config* other);

  // implements Message ----------------------------------------------

  inline flex_drx_config* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_drx_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_drx_config& from);
  void MergeFrom(const flex_drx_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_drx_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 on_duration_timer = 1;
  bool has_on_duration_timer() const;
  void clear_on_duration_timer();
  static const int kOnDurationTimerFieldNumber = 1;
  ::google::protobuf::uint32 on_duration_timer() const;
  void set_on_duration_timer(::google::protobuf::uint32 value);

  // optional uint32 drx_inactivity_timer = 2;
  bool has_drx_inactivity_timer() const;
  void clear_drx_inactivity_timer();
  static const int kDrxInactivityTimerFieldNumber = 2;
  ::google::protobuf::uint32 drx_inactivity_timer() const;
  void set_drx_inactivity_timer(::google::protobuf::uint32 value);

  // optional uint32 drx_retransmission_timer = 3;
  bool has_drx_retransmission_timer() const;
  void clear_drx_retransmission_timer();
  static const int kDrxRetransmissionTimerFieldNumber = 3;
  ::google::protobuf::uint32 drx_retransmission_timer() const;
  void set_drx_retransmission_timer(::google::protobuf::uint32 value);

  // optional uint32 long_drx_cycle = 4;
  bool has_long_drx_cycle() const;
  void clear_long_drx_cycle();
  static const int kLongDrxCycleFieldNumber = 4;
  ::google::protobuf::uint32 long_drx_cycle() const;
  void set_long_drx_cycle(::google::protobuf::uint32 value);

  // optional uint32 long_drx_cycle_start_offset = 5;
  bool has_long_drx_cycle_start_offset() const;
  void clear_long_drx_cycle_start_offset();
  static const int kLongDrxCycleStartOffsetFieldNumber = 5;
  ::google::protobuf::uint32 long_drx_cycle_start_offset() const;
  void set_long_drx_cycle_start_offset(::google::protobuf::uint32 value);

  // optional uint32 short_drx_cycle = 6;
  bool has_short_drx_cycle() const;
  void clear_short_drx_cycle();
  static const int kShortDrxCycleFieldNumber = 6;
  ::google::protobuf::uint32 short_drx_cycle() const;
  void set_short_drx_cycle(::google::protobuf::uint32 value);

  // optional uint32 drx_short_cycle_timer = 7;
  bool has_drx_short_cycle_timer() const;
  void clear_drx_short_cycle_timer();
  static const int kDrxShortCycleTimerFieldNumber = 7;
  ::google::protobuf::uint32 drx_short_cycle_timer() const;
  void set_drx_short_cycle_timer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_drx_config)
 private:
  void set_has_on_duration_timer();
  void clear_has_on_duration_timer();
  void set_has_drx_inactivity_timer();
  void clear_has_drx_inactivity_timer();
  void set_has_drx_retransmission_timer();
  void clear_has_drx_retransmission_timer();
  void set_has_long_drx_cycle();
  void clear_has_long_drx_cycle();
  void set_has_long_drx_cycle_start_offset();
  void clear_has_long_drx_cycle_start_offset();
  void set_has_short_drx_cycle();
  void clear_has_short_drx_cycle();
  void set_has_drx_short_cycle_timer();
  void clear_has_drx_short_cycle_timer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 on_duration_timer_;
  ::google::protobuf::uint32 drx_inactivity_timer_;
  ::google::protobuf::uint32 drx_retransmission_timer_;
  ::google::protobuf::uint32 long_drx_cycle_;
  ::google::protobuf::uint32 long_drx_cycle_start_offset_;
  ::google::protobuf::uint32 short_drx_cycle_;
  ::google::protobuf::uint32 drx_short_cycle_timer_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_sps_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_sps_config) */ {
 public:
  flex_sps_config();
  virtual ~flex_sps_config();

  flex_sps_config(const flex_sps_config& from);

  inline flex_sps_config& operator=(const flex_sps_config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_sps_config& default_instance();

  static inline const flex_sps_config* internal_default_instance() {
    return reinterpret_cast<const flex_sps_config*>(
               &_flex_sps_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(flex_sps_config* other);

  // implements Message ----------------------------------------------

  inline flex_sps_config* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_sps_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_sps_config& from);
  void MergeFrom(const flex_sps_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_sps_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 n1_PUCCH_AN_persistent_element = 4;
  int n1_pucch_an_persistent_element_size() const;
  void clear_n1_pucch_an_persistent_element();
  static const int kN1PUCCHANPersistentElementFieldNumber = 4;
  ::google::protobuf::uint32 n1_pucch_an_persistent_element(int index) const;
  void set_n1_pucch_an_persistent_element(int index, ::google::protobuf::uint32 value);
  void add_n1_pucch_an_persistent_element(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      n1_pucch_an_persistent_element() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_n1_pucch_an_persistent_element();

  // optional uint32 semi_persistent_sched_interval_UL = 1;
  bool has_semi_persistent_sched_interval_ul() const;
  void clear_semi_persistent_sched_interval_ul();
  static const int kSemiPersistentSchedIntervalULFieldNumber = 1;
  ::google::protobuf::uint32 semi_persistent_sched_interval_ul() const;
  void set_semi_persistent_sched_interval_ul(::google::protobuf::uint32 value);

  // optional uint32 semi_persistent_sched_interval_DL = 2;
  bool has_semi_persistent_sched_interval_dl() const;
  void clear_semi_persistent_sched_interval_dl();
  static const int kSemiPersistentSchedIntervalDLFieldNumber = 2;
  ::google::protobuf::uint32 semi_persistent_sched_interval_dl() const;
  void set_semi_persistent_sched_interval_dl(::google::protobuf::uint32 value);

  // optional uint32 num_of_conf_sps_proc = 3;
  bool has_num_of_conf_sps_proc() const;
  void clear_num_of_conf_sps_proc();
  static const int kNumOfConfSpsProcFieldNumber = 3;
  ::google::protobuf::uint32 num_of_conf_sps_proc() const;
  void set_num_of_conf_sps_proc(::google::protobuf::uint32 value);

  // optional uint32 implicit_release_after = 5;
  bool has_implicit_release_after() const;
  void clear_implicit_release_after();
  static const int kImplicitReleaseAfterFieldNumber = 5;
  ::google::protobuf::uint32 implicit_release_after() const;
  void set_implicit_release_after(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_sps_config)
 private:
  void set_has_semi_persistent_sched_interval_ul();
  void clear_has_semi_persistent_sched_interval_ul();
  void set_has_semi_persistent_sched_interval_dl();
  void clear_has_semi_persistent_sched_interval_dl();
  void set_has_num_of_conf_sps_proc();
  void clear_has_num_of_conf_sps_proc();
  void set_has_implicit_release_after();
  void clear_has_implicit_release_after();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > n1_pucch_an_persistent_element_;
  ::google::protobuf::uint32 semi_persistent_sched_interval_ul_;
  ::google::protobuf::uint32 semi_persistent_sched_interval_dl_;
  ::google::protobuf::uint32 num_of_conf_sps_proc_;
  ::google::protobuf::uint32 implicit_release_after_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_sr_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_sr_config) */ {
 public:
  flex_sr_config();
  virtual ~flex_sr_config();

  flex_sr_config(const flex_sr_config& from);

  inline flex_sr_config& operator=(const flex_sr_config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_sr_config& default_instance();

  static inline const flex_sr_config* internal_default_instance() {
    return reinterpret_cast<const flex_sr_config*>(
               &_flex_sr_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(flex_sr_config* other);

  // implements Message ----------------------------------------------

  inline flex_sr_config* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_sr_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_sr_config& from);
  void MergeFrom(const flex_sr_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_sr_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sr_action = 1;
  bool has_sr_action() const;
  void clear_sr_action();
  static const int kSrActionFieldNumber = 1;
  ::google::protobuf::uint32 sr_action() const;
  void set_sr_action(::google::protobuf::uint32 value);

  // optional uint32 sched_interval = 2;
  bool has_sched_interval() const;
  void clear_sched_interval();
  static const int kSchedIntervalFieldNumber = 2;
  ::google::protobuf::uint32 sched_interval() const;
  void set_sched_interval(::google::protobuf::uint32 value);

  // optional uint32 dsr_trans_max = 3;
  bool has_dsr_trans_max() const;
  void clear_dsr_trans_max();
  static const int kDsrTransMaxFieldNumber = 3;
  ::google::protobuf::uint32 dsr_trans_max() const;
  void set_dsr_trans_max(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_sr_config)
 private:
  void set_has_sr_action();
  void clear_has_sr_action();
  void set_has_sched_interval();
  void clear_has_sched_interval();
  void set_has_dsr_trans_max();
  void clear_has_dsr_trans_max();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 sr_action_;
  ::google::protobuf::uint32 sched_interval_;
  ::google::protobuf::uint32 dsr_trans_max_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_cqi_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_cqi_config) */ {
 public:
  flex_cqi_config();
  virtual ~flex_cqi_config();

  flex_cqi_config(const flex_cqi_config& from);

  inline flex_cqi_config& operator=(const flex_cqi_config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_cqi_config& default_instance();

  static inline const flex_cqi_config* internal_default_instance() {
    return reinterpret_cast<const flex_cqi_config*>(
               &_flex_cqi_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(flex_cqi_config* other);

  // implements Message ----------------------------------------------

  inline flex_cqi_config* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_cqi_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_cqi_config& from);
  void MergeFrom(const flex_cqi_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_cqi_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cqi_action = 1;
  bool has_cqi_action() const;
  void clear_cqi_action();
  static const int kCqiActionFieldNumber = 1;
  ::google::protobuf::uint32 cqi_action() const;
  void set_cqi_action(::google::protobuf::uint32 value);

  // optional uint32 cqi_sched_interval = 2;
  bool has_cqi_sched_interval() const;
  void clear_cqi_sched_interval();
  static const int kCqiSchedIntervalFieldNumber = 2;
  ::google::protobuf::uint32 cqi_sched_interval() const;
  void set_cqi_sched_interval(::google::protobuf::uint32 value);

  // optional uint32 ri_sched_interval = 3;
  bool has_ri_sched_interval() const;
  void clear_ri_sched_interval();
  static const int kRiSchedIntervalFieldNumber = 3;
  ::google::protobuf::uint32 ri_sched_interval() const;
  void set_ri_sched_interval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_cqi_config)
 private:
  void set_has_cqi_action();
  void clear_has_cqi_action();
  void set_has_cqi_sched_interval();
  void clear_has_cqi_sched_interval();
  void set_has_ri_sched_interval();
  void clear_has_ri_sched_interval();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 cqi_action_;
  ::google::protobuf::uint32 cqi_sched_interval_;
  ::google::protobuf::uint32 ri_sched_interval_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_ue_capabilities : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_ue_capabilities) */ {
 public:
  flex_ue_capabilities();
  virtual ~flex_ue_capabilities();

  flex_ue_capabilities(const flex_ue_capabilities& from);

  inline flex_ue_capabilities& operator=(const flex_ue_capabilities& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_ue_capabilities& default_instance();

  static inline const flex_ue_capabilities* internal_default_instance() {
    return reinterpret_cast<const flex_ue_capabilities*>(
               &_flex_ue_capabilities_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(flex_ue_capabilities* other);

  // implements Message ----------------------------------------------

  inline flex_ue_capabilities* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_ue_capabilities* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_ue_capabilities& from);
  void MergeFrom(const flex_ue_capabilities& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_ue_capabilities* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 half_duplex = 1;
  bool has_half_duplex() const;
  void clear_half_duplex();
  static const int kHalfDuplexFieldNumber = 1;
  ::google::protobuf::uint32 half_duplex() const;
  void set_half_duplex(::google::protobuf::uint32 value);

  // optional uint32 intra_SF_hopping = 2;
  bool has_intra_sf_hopping() const;
  void clear_intra_sf_hopping();
  static const int kIntraSFHoppingFieldNumber = 2;
  ::google::protobuf::uint32 intra_sf_hopping() const;
  void set_intra_sf_hopping(::google::protobuf::uint32 value);

  // optional uint32 type2_sb_1 = 3;
  bool has_type2_sb_1() const;
  void clear_type2_sb_1();
  static const int kType2Sb1FieldNumber = 3;
  ::google::protobuf::uint32 type2_sb_1() const;
  void set_type2_sb_1(::google::protobuf::uint32 value);

  // optional uint32 ue_category = 4;
  bool has_ue_category() const;
  void clear_ue_category();
  static const int kUeCategoryFieldNumber = 4;
  ::google::protobuf::uint32 ue_category() const;
  void set_ue_category(::google::protobuf::uint32 value);

  // optional uint32 res_alloc_type1 = 5;
  bool has_res_alloc_type1() const;
  void clear_res_alloc_type1();
  static const int kResAllocType1FieldNumber = 5;
  ::google::protobuf::uint32 res_alloc_type1() const;
  void set_res_alloc_type1(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_ue_capabilities)
 private:
  void set_has_half_duplex();
  void clear_has_half_duplex();
  void set_has_intra_sf_hopping();
  void clear_has_intra_sf_hopping();
  void set_has_type2_sb_1();
  void clear_has_type2_sb_1();
  void set_has_ue_category();
  void clear_has_ue_category();
  void set_has_res_alloc_type1();
  void clear_has_res_alloc_type1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 half_duplex_;
  ::google::protobuf::uint32 intra_sf_hopping_;
  ::google::protobuf::uint32 type2_sb_1_;
  ::google::protobuf::uint32 ue_category_;
  ::google::protobuf::uint32 res_alloc_type1_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_scell_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_scell_config) */ {
 public:
  flex_scell_config();
  virtual ~flex_scell_config();

  flex_scell_config(const flex_scell_config& from);

  inline flex_scell_config& operator=(const flex_scell_config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_scell_config& default_instance();

  static inline const flex_scell_config* internal_default_instance() {
    return reinterpret_cast<const flex_scell_config*>(
               &_flex_scell_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(flex_scell_config* other);

  // implements Message ----------------------------------------------

  inline flex_scell_config* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_scell_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_scell_config& from);
  void MergeFrom(const flex_scell_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_scell_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 carrier_index = 1;
  bool has_carrier_index() const;
  void clear_carrier_index();
  static const int kCarrierIndexFieldNumber = 1;
  ::google::protobuf::uint32 carrier_index() const;
  void set_carrier_index(::google::protobuf::uint32 value);

  // optional uint32 scell_index = 2;
  bool has_scell_index() const;
  void clear_scell_index();
  static const int kScellIndexFieldNumber = 2;
  ::google::protobuf::uint32 scell_index() const;
  void set_scell_index(::google::protobuf::uint32 value);

  // optional uint32 use_ccs = 3;
  bool has_use_ccs() const;
  void clear_use_ccs();
  static const int kUseCcsFieldNumber = 3;
  ::google::protobuf::uint32 use_ccs() const;
  void set_use_ccs(::google::protobuf::uint32 value);

  // optional uint32 sched_cell_index = 4;
  bool has_sched_cell_index() const;
  void clear_sched_cell_index();
  static const int kSchedCellIndexFieldNumber = 4;
  ::google::protobuf::uint32 sched_cell_index() const;
  void set_sched_cell_index(::google::protobuf::uint32 value);

  // optional uint32 pdsch_start = 5;
  bool has_pdsch_start() const;
  void clear_pdsch_start();
  static const int kPdschStartFieldNumber = 5;
  ::google::protobuf::uint32 pdsch_start() const;
  void set_pdsch_start(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_scell_config)
 private:
  void set_has_carrier_index();
  void clear_has_carrier_index();
  void set_has_scell_index();
  void clear_has_scell_index();
  void set_has_use_ccs();
  void clear_has_use_ccs();
  void set_has_sched_cell_index();
  void clear_has_sched_cell_index();
  void set_has_pdsch_start();
  void clear_has_pdsch_start();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 carrier_index_;
  ::google::protobuf::uint32 scell_index_;
  ::google::protobuf::uint32 use_ccs_;
  ::google::protobuf::uint32 sched_cell_index_;
  ::google::protobuf::uint32 pdsch_start_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_lc_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_lc_config) */ {
 public:
  flex_lc_config();
  virtual ~flex_lc_config();

  flex_lc_config(const flex_lc_config& from);

  inline flex_lc_config& operator=(const flex_lc_config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_lc_config& default_instance();

  static inline const flex_lc_config* internal_default_instance() {
    return reinterpret_cast<const flex_lc_config*>(
               &_flex_lc_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(flex_lc_config* other);

  // implements Message ----------------------------------------------

  inline flex_lc_config* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_lc_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_lc_config& from);
  void MergeFrom(const flex_lc_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_lc_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 lcid = 1;
  bool has_lcid() const;
  void clear_lcid();
  static const int kLcidFieldNumber = 1;
  ::google::protobuf::uint32 lcid() const;
  void set_lcid(::google::protobuf::uint32 value);

  // optional uint32 lcg = 2;
  bool has_lcg() const;
  void clear_lcg();
  static const int kLcgFieldNumber = 2;
  ::google::protobuf::uint32 lcg() const;
  void set_lcg(::google::protobuf::uint32 value);

  // optional uint32 direction = 3;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 3;
  ::google::protobuf::uint32 direction() const;
  void set_direction(::google::protobuf::uint32 value);

  // optional uint32 qos_bearer_type = 4;
  bool has_qos_bearer_type() const;
  void clear_qos_bearer_type();
  static const int kQosBearerTypeFieldNumber = 4;
  ::google::protobuf::uint32 qos_bearer_type() const;
  void set_qos_bearer_type(::google::protobuf::uint32 value);

  // optional uint64 e_RAB_max_bitrate_UL = 6;
  bool has_e_rab_max_bitrate_ul() const;
  void clear_e_rab_max_bitrate_ul();
  static const int kERABMaxBitrateULFieldNumber = 6;
  ::google::protobuf::uint64 e_rab_max_bitrate_ul() const;
  void set_e_rab_max_bitrate_ul(::google::protobuf::uint64 value);

  // optional uint64 e_RAB_max_bitrate_DL = 7;
  bool has_e_rab_max_bitrate_dl() const;
  void clear_e_rab_max_bitrate_dl();
  static const int kERABMaxBitrateDLFieldNumber = 7;
  ::google::protobuf::uint64 e_rab_max_bitrate_dl() const;
  void set_e_rab_max_bitrate_dl(::google::protobuf::uint64 value);

  // optional uint64 e_RAB_guaranteed_bitrate_UL = 8;
  bool has_e_rab_guaranteed_bitrate_ul() const;
  void clear_e_rab_guaranteed_bitrate_ul();
  static const int kERABGuaranteedBitrateULFieldNumber = 8;
  ::google::protobuf::uint64 e_rab_guaranteed_bitrate_ul() const;
  void set_e_rab_guaranteed_bitrate_ul(::google::protobuf::uint64 value);

  // optional uint64 e_RAB_guaranteed_bitrate_DL = 9;
  bool has_e_rab_guaranteed_bitrate_dl() const;
  void clear_e_rab_guaranteed_bitrate_dl();
  static const int kERABGuaranteedBitrateDLFieldNumber = 9;
  ::google::protobuf::uint64 e_rab_guaranteed_bitrate_dl() const;
  void set_e_rab_guaranteed_bitrate_dl(::google::protobuf::uint64 value);

  // optional uint32 qci = 5;
  bool has_qci() const;
  void clear_qci();
  static const int kQciFieldNumber = 5;
  ::google::protobuf::uint32 qci() const;
  void set_qci(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_lc_config)
 private:
  void set_has_lcid();
  void clear_has_lcid();
  void set_has_lcg();
  void clear_has_lcg();
  void set_has_direction();
  void clear_has_direction();
  void set_has_qos_bearer_type();
  void clear_has_qos_bearer_type();
  void set_has_qci();
  void clear_has_qci();
  void set_has_e_rab_max_bitrate_ul();
  void clear_has_e_rab_max_bitrate_ul();
  void set_has_e_rab_max_bitrate_dl();
  void clear_has_e_rab_max_bitrate_dl();
  void set_has_e_rab_guaranteed_bitrate_ul();
  void clear_has_e_rab_guaranteed_bitrate_ul();
  void set_has_e_rab_guaranteed_bitrate_dl();
  void clear_has_e_rab_guaranteed_bitrate_dl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 lcid_;
  ::google::protobuf::uint32 lcg_;
  ::google::protobuf::uint32 direction_;
  ::google::protobuf::uint32 qos_bearer_type_;
  ::google::protobuf::uint64 e_rab_max_bitrate_ul_;
  ::google::protobuf::uint64 e_rab_max_bitrate_dl_;
  ::google::protobuf::uint64 e_rab_guaranteed_bitrate_ul_;
  ::google::protobuf::uint64 e_rab_guaranteed_bitrate_dl_;
  ::google::protobuf::uint32 qci_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_plmn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_plmn) */ {
 public:
  flex_plmn();
  virtual ~flex_plmn();

  flex_plmn(const flex_plmn& from);

  inline flex_plmn& operator=(const flex_plmn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_plmn& default_instance();

  static inline const flex_plmn* internal_default_instance() {
    return reinterpret_cast<const flex_plmn*>(
               &_flex_plmn_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(flex_plmn* other);

  // implements Message ----------------------------------------------

  inline flex_plmn* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_plmn* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_plmn& from);
  void MergeFrom(const flex_plmn& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_plmn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 mcc = 1;
  bool has_mcc() const;
  void clear_mcc();
  static const int kMccFieldNumber = 1;
  ::google::protobuf::uint32 mcc() const;
  void set_mcc(::google::protobuf::uint32 value);

  // optional uint32 mnc = 2;
  bool has_mnc() const;
  void clear_mnc();
  static const int kMncFieldNumber = 2;
  ::google::protobuf::uint32 mnc() const;
  void set_mnc(::google::protobuf::uint32 value);

  // optional uint32 mnc_length = 3;
  bool has_mnc_length() const;
  void clear_mnc_length();
  static const int kMncLengthFieldNumber = 3;
  ::google::protobuf::uint32 mnc_length() const;
  void set_mnc_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_plmn)
 private:
  void set_has_mcc();
  void clear_has_mcc();
  void set_has_mnc();
  void clear_has_mnc();
  void set_has_mnc_length();
  void clear_has_mnc_length();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 mcc_;
  ::google::protobuf::uint32 mnc_;
  ::google::protobuf::uint32 mnc_length_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_measurement_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_measurement_info) */ {
 public:
  flex_measurement_info();
  virtual ~flex_measurement_info();

  flex_measurement_info(const flex_measurement_info& from);

  inline flex_measurement_info& operator=(const flex_measurement_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_measurement_info& default_instance();

  static inline const flex_measurement_info* internal_default_instance() {
    return reinterpret_cast<const flex_measurement_info*>(
               &_flex_measurement_info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(flex_measurement_info* other);

  // implements Message ----------------------------------------------

  inline flex_measurement_info* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_measurement_info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_measurement_info& from);
  void MergeFrom(const flex_measurement_info& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_measurement_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 cell_individual_offset = 3;
  int cell_individual_offset_size() const;
  void clear_cell_individual_offset();
  static const int kCellIndividualOffsetFieldNumber = 3;
  ::google::protobuf::int64 cell_individual_offset(int index) const;
  void set_cell_individual_offset(int index, ::google::protobuf::int64 value);
  void add_cell_individual_offset(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      cell_individual_offset() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_cell_individual_offset();

  // optional .protocol.flex_measurement_event event = 6;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 6;
  const ::protocol::flex_measurement_event& event() const;
  ::protocol::flex_measurement_event* mutable_event();
  ::protocol::flex_measurement_event* release_event();
  void set_allocated_event(::protocol::flex_measurement_event* event);

  // optional int64 offset_freq_serving = 1;
  bool has_offset_freq_serving() const;
  void clear_offset_freq_serving();
  static const int kOffsetFreqServingFieldNumber = 1;
  ::google::protobuf::int64 offset_freq_serving() const;
  void set_offset_freq_serving(::google::protobuf::int64 value);

  // optional int64 offset_freq_neighbouring = 2;
  bool has_offset_freq_neighbouring() const;
  void clear_offset_freq_neighbouring();
  static const int kOffsetFreqNeighbouringFieldNumber = 2;
  ::google::protobuf::int64 offset_freq_neighbouring() const;
  void set_offset_freq_neighbouring(::google::protobuf::int64 value);

  // optional int64 filter_coefficient_rsrp = 4;
  bool has_filter_coefficient_rsrp() const;
  void clear_filter_coefficient_rsrp();
  static const int kFilterCoefficientRsrpFieldNumber = 4;
  ::google::protobuf::int64 filter_coefficient_rsrp() const;
  void set_filter_coefficient_rsrp(::google::protobuf::int64 value);

  // optional int64 filter_coefficient_rsrq = 5;
  bool has_filter_coefficient_rsrq() const;
  void clear_filter_coefficient_rsrq();
  static const int kFilterCoefficientRsrqFieldNumber = 5;
  ::google::protobuf::int64 filter_coefficient_rsrq() const;
  void set_filter_coefficient_rsrq(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_measurement_info)
 private:
  void set_has_offset_freq_serving();
  void clear_has_offset_freq_serving();
  void set_has_offset_freq_neighbouring();
  void clear_has_offset_freq_neighbouring();
  void set_has_filter_coefficient_rsrp();
  void clear_has_filter_coefficient_rsrp();
  void set_has_filter_coefficient_rsrq();
  void clear_has_filter_coefficient_rsrq();
  void set_has_event();
  void clear_has_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > cell_individual_offset_;
  ::protocol::flex_measurement_event* event_;
  ::google::protobuf::int64 offset_freq_serving_;
  ::google::protobuf::int64 offset_freq_neighbouring_;
  ::google::protobuf::int64 filter_coefficient_rsrp_;
  ::google::protobuf::int64 filter_coefficient_rsrq_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_measurement_event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_measurement_event) */ {
 public:
  flex_measurement_event();
  virtual ~flex_measurement_event();

  flex_measurement_event(const flex_measurement_event& from);

  inline flex_measurement_event& operator=(const flex_measurement_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_measurement_event& default_instance();

  static inline const flex_measurement_event* internal_default_instance() {
    return reinterpret_cast<const flex_measurement_event*>(
               &_flex_measurement_event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(flex_measurement_event* other);

  // implements Message ----------------------------------------------

  inline flex_measurement_event* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_measurement_event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_measurement_event& from);
  void MergeFrom(const flex_measurement_event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_measurement_event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flex_per_event periodical = 1;
  bool has_periodical() const;
  void clear_periodical();
  static const int kPeriodicalFieldNumber = 1;
  const ::protocol::flex_per_event& periodical() const;
  ::protocol::flex_per_event* mutable_periodical();
  ::protocol::flex_per_event* release_periodical();
  void set_allocated_periodical(::protocol::flex_per_event* periodical);

  // optional .protocol.flex_a1_event a1 = 2;
  bool has_a1() const;
  void clear_a1();
  static const int kA1FieldNumber = 2;
  const ::protocol::flex_a1_event& a1() const;
  ::protocol::flex_a1_event* mutable_a1();
  ::protocol::flex_a1_event* release_a1();
  void set_allocated_a1(::protocol::flex_a1_event* a1);

  // optional .protocol.flex_a2_event a2 = 3;
  bool has_a2() const;
  void clear_a2();
  static const int kA2FieldNumber = 3;
  const ::protocol::flex_a2_event& a2() const;
  ::protocol::flex_a2_event* mutable_a2();
  ::protocol::flex_a2_event* release_a2();
  void set_allocated_a2(::protocol::flex_a2_event* a2);

  // optional .protocol.flex_a3_event a3 = 4;
  bool has_a3() const;
  void clear_a3();
  static const int kA3FieldNumber = 4;
  const ::protocol::flex_a3_event& a3() const;
  ::protocol::flex_a3_event* mutable_a3();
  ::protocol::flex_a3_event* release_a3();
  void set_allocated_a3(::protocol::flex_a3_event* a3);

  // optional .protocol.flex_a4_event a4 = 5;
  bool has_a4() const;
  void clear_a4();
  static const int kA4FieldNumber = 5;
  const ::protocol::flex_a4_event& a4() const;
  ::protocol::flex_a4_event* mutable_a4();
  ::protocol::flex_a4_event* release_a4();
  void set_allocated_a4(::protocol::flex_a4_event* a4);

  // optional .protocol.flex_a5_event a5 = 6;
  bool has_a5() const;
  void clear_a5();
  static const int kA5FieldNumber = 6;
  const ::protocol::flex_a5_event& a5() const;
  ::protocol::flex_a5_event* mutable_a5();
  ::protocol::flex_a5_event* release_a5();
  void set_allocated_a5(::protocol::flex_a5_event* a5);

  // @@protoc_insertion_point(class_scope:protocol.flex_measurement_event)
 private:
  void set_has_periodical();
  void clear_has_periodical();
  void set_has_a1();
  void clear_has_a1();
  void set_has_a2();
  void clear_has_a2();
  void set_has_a3();
  void clear_has_a3();
  void set_has_a4();
  void clear_has_a4();
  void set_has_a5();
  void clear_has_a5();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::flex_per_event* periodical_;
  ::protocol::flex_a1_event* a1_;
  ::protocol::flex_a2_event* a2_;
  ::protocol::flex_a3_event* a3_;
  ::protocol::flex_a4_event* a4_;
  ::protocol::flex_a5_event* a5_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_per_event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_per_event) */ {
 public:
  flex_per_event();
  virtual ~flex_per_event();

  flex_per_event(const flex_per_event& from);

  inline flex_per_event& operator=(const flex_per_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_per_event& default_instance();

  static inline const flex_per_event* internal_default_instance() {
    return reinterpret_cast<const flex_per_event*>(
               &_flex_per_event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(flex_per_event* other);

  // implements Message ----------------------------------------------

  inline flex_per_event* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_per_event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_per_event& from);
  void MergeFrom(const flex_per_event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_per_event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 max_report_cells = 1;
  bool has_max_report_cells() const;
  void clear_max_report_cells();
  static const int kMaxReportCellsFieldNumber = 1;
  ::google::protobuf::int64 max_report_cells() const;
  void set_max_report_cells(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_per_event)
 private:
  void set_has_max_report_cells();
  void clear_has_max_report_cells();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 max_report_cells_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_a1_event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_a1_event) */ {
 public:
  flex_a1_event();
  virtual ~flex_a1_event();

  flex_a1_event(const flex_a1_event& from);

  inline flex_a1_event& operator=(const flex_a1_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_a1_event& default_instance();

  static inline const flex_a1_event* internal_default_instance() {
    return reinterpret_cast<const flex_a1_event*>(
               &_flex_a1_event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(flex_a1_event* other);

  // implements Message ----------------------------------------------

  inline flex_a1_event* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_a1_event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_a1_event& from);
  void MergeFrom(const flex_a1_event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_a1_event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 threshold_rsrp = 1;
  bool has_threshold_rsrp() const;
  void clear_threshold_rsrp();
  static const int kThresholdRsrpFieldNumber = 1;
  ::google::protobuf::int64 threshold_rsrp() const;
  void set_threshold_rsrp(::google::protobuf::int64 value);

  // optional int64 hysteresis = 2;
  bool has_hysteresis() const;
  void clear_hysteresis();
  static const int kHysteresisFieldNumber = 2;
  ::google::protobuf::int64 hysteresis() const;
  void set_hysteresis(::google::protobuf::int64 value);

  // optional int64 time_to_trigger = 3;
  bool has_time_to_trigger() const;
  void clear_time_to_trigger();
  static const int kTimeToTriggerFieldNumber = 3;
  ::google::protobuf::int64 time_to_trigger() const;
  void set_time_to_trigger(::google::protobuf::int64 value);

  // optional int64 max_report_cells = 4;
  bool has_max_report_cells() const;
  void clear_max_report_cells();
  static const int kMaxReportCellsFieldNumber = 4;
  ::google::protobuf::int64 max_report_cells() const;
  void set_max_report_cells(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_a1_event)
 private:
  void set_has_threshold_rsrp();
  void clear_has_threshold_rsrp();
  void set_has_hysteresis();
  void clear_has_hysteresis();
  void set_has_time_to_trigger();
  void clear_has_time_to_trigger();
  void set_has_max_report_cells();
  void clear_has_max_report_cells();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 threshold_rsrp_;
  ::google::protobuf::int64 hysteresis_;
  ::google::protobuf::int64 time_to_trigger_;
  ::google::protobuf::int64 max_report_cells_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_a2_event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_a2_event) */ {
 public:
  flex_a2_event();
  virtual ~flex_a2_event();

  flex_a2_event(const flex_a2_event& from);

  inline flex_a2_event& operator=(const flex_a2_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_a2_event& default_instance();

  static inline const flex_a2_event* internal_default_instance() {
    return reinterpret_cast<const flex_a2_event*>(
               &_flex_a2_event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(flex_a2_event* other);

  // implements Message ----------------------------------------------

  inline flex_a2_event* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_a2_event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_a2_event& from);
  void MergeFrom(const flex_a2_event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_a2_event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 threshold_rsrp = 1;
  bool has_threshold_rsrp() const;
  void clear_threshold_rsrp();
  static const int kThresholdRsrpFieldNumber = 1;
  ::google::protobuf::int64 threshold_rsrp() const;
  void set_threshold_rsrp(::google::protobuf::int64 value);

  // optional int64 hysteresis = 2;
  bool has_hysteresis() const;
  void clear_hysteresis();
  static const int kHysteresisFieldNumber = 2;
  ::google::protobuf::int64 hysteresis() const;
  void set_hysteresis(::google::protobuf::int64 value);

  // optional int64 time_to_trigger = 3;
  bool has_time_to_trigger() const;
  void clear_time_to_trigger();
  static const int kTimeToTriggerFieldNumber = 3;
  ::google::protobuf::int64 time_to_trigger() const;
  void set_time_to_trigger(::google::protobuf::int64 value);

  // optional int64 max_report_cells = 4;
  bool has_max_report_cells() const;
  void clear_max_report_cells();
  static const int kMaxReportCellsFieldNumber = 4;
  ::google::protobuf::int64 max_report_cells() const;
  void set_max_report_cells(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_a2_event)
 private:
  void set_has_threshold_rsrp();
  void clear_has_threshold_rsrp();
  void set_has_hysteresis();
  void clear_has_hysteresis();
  void set_has_time_to_trigger();
  void clear_has_time_to_trigger();
  void set_has_max_report_cells();
  void clear_has_max_report_cells();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 threshold_rsrp_;
  ::google::protobuf::int64 hysteresis_;
  ::google::protobuf::int64 time_to_trigger_;
  ::google::protobuf::int64 max_report_cells_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_a3_event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_a3_event) */ {
 public:
  flex_a3_event();
  virtual ~flex_a3_event();

  flex_a3_event(const flex_a3_event& from);

  inline flex_a3_event& operator=(const flex_a3_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_a3_event& default_instance();

  static inline const flex_a3_event* internal_default_instance() {
    return reinterpret_cast<const flex_a3_event*>(
               &_flex_a3_event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(flex_a3_event* other);

  // implements Message ----------------------------------------------

  inline flex_a3_event* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_a3_event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_a3_event& from);
  void MergeFrom(const flex_a3_event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_a3_event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 a3_offset = 1;
  bool has_a3_offset() const;
  void clear_a3_offset();
  static const int kA3OffsetFieldNumber = 1;
  ::google::protobuf::int64 a3_offset() const;
  void set_a3_offset(::google::protobuf::int64 value);

  // optional int64 hysteresis = 3;
  bool has_hysteresis() const;
  void clear_hysteresis();
  static const int kHysteresisFieldNumber = 3;
  ::google::protobuf::int64 hysteresis() const;
  void set_hysteresis(::google::protobuf::int64 value);

  // optional int64 time_to_trigger = 4;
  bool has_time_to_trigger() const;
  void clear_time_to_trigger();
  static const int kTimeToTriggerFieldNumber = 4;
  ::google::protobuf::int64 time_to_trigger() const;
  void set_time_to_trigger(::google::protobuf::int64 value);

  // optional int64 max_report_cells = 5;
  bool has_max_report_cells() const;
  void clear_max_report_cells();
  static const int kMaxReportCellsFieldNumber = 5;
  ::google::protobuf::int64 max_report_cells() const;
  void set_max_report_cells(::google::protobuf::int64 value);

  // optional int32 report_on_leave = 2;
  bool has_report_on_leave() const;
  void clear_report_on_leave();
  static const int kReportOnLeaveFieldNumber = 2;
  ::google::protobuf::int32 report_on_leave() const;
  void set_report_on_leave(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_a3_event)
 private:
  void set_has_a3_offset();
  void clear_has_a3_offset();
  void set_has_report_on_leave();
  void clear_has_report_on_leave();
  void set_has_hysteresis();
  void clear_has_hysteresis();
  void set_has_time_to_trigger();
  void clear_has_time_to_trigger();
  void set_has_max_report_cells();
  void clear_has_max_report_cells();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 a3_offset_;
  ::google::protobuf::int64 hysteresis_;
  ::google::protobuf::int64 time_to_trigger_;
  ::google::protobuf::int64 max_report_cells_;
  ::google::protobuf::int32 report_on_leave_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_a4_event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_a4_event) */ {
 public:
  flex_a4_event();
  virtual ~flex_a4_event();

  flex_a4_event(const flex_a4_event& from);

  inline flex_a4_event& operator=(const flex_a4_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_a4_event& default_instance();

  static inline const flex_a4_event* internal_default_instance() {
    return reinterpret_cast<const flex_a4_event*>(
               &_flex_a4_event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(flex_a4_event* other);

  // implements Message ----------------------------------------------

  inline flex_a4_event* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_a4_event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_a4_event& from);
  void MergeFrom(const flex_a4_event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_a4_event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 threshold_rsrp = 1;
  bool has_threshold_rsrp() const;
  void clear_threshold_rsrp();
  static const int kThresholdRsrpFieldNumber = 1;
  ::google::protobuf::int64 threshold_rsrp() const;
  void set_threshold_rsrp(::google::protobuf::int64 value);

  // optional int64 hysteresis = 2;
  bool has_hysteresis() const;
  void clear_hysteresis();
  static const int kHysteresisFieldNumber = 2;
  ::google::protobuf::int64 hysteresis() const;
  void set_hysteresis(::google::protobuf::int64 value);

  // optional int64 time_to_trigger = 3;
  bool has_time_to_trigger() const;
  void clear_time_to_trigger();
  static const int kTimeToTriggerFieldNumber = 3;
  ::google::protobuf::int64 time_to_trigger() const;
  void set_time_to_trigger(::google::protobuf::int64 value);

  // optional int64 max_report_cells = 4;
  bool has_max_report_cells() const;
  void clear_max_report_cells();
  static const int kMaxReportCellsFieldNumber = 4;
  ::google::protobuf::int64 max_report_cells() const;
  void set_max_report_cells(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_a4_event)
 private:
  void set_has_threshold_rsrp();
  void clear_has_threshold_rsrp();
  void set_has_hysteresis();
  void clear_has_hysteresis();
  void set_has_time_to_trigger();
  void clear_has_time_to_trigger();
  void set_has_max_report_cells();
  void clear_has_max_report_cells();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 threshold_rsrp_;
  ::google::protobuf::int64 hysteresis_;
  ::google::protobuf::int64 time_to_trigger_;
  ::google::protobuf::int64 max_report_cells_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_a5_event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_a5_event) */ {
 public:
  flex_a5_event();
  virtual ~flex_a5_event();

  flex_a5_event(const flex_a5_event& from);

  inline flex_a5_event& operator=(const flex_a5_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_a5_event& default_instance();

  static inline const flex_a5_event* internal_default_instance() {
    return reinterpret_cast<const flex_a5_event*>(
               &_flex_a5_event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(flex_a5_event* other);

  // implements Message ----------------------------------------------

  inline flex_a5_event* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_a5_event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_a5_event& from);
  void MergeFrom(const flex_a5_event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_a5_event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 threshold_rsrp_1 = 1;
  bool has_threshold_rsrp_1() const;
  void clear_threshold_rsrp_1();
  static const int kThresholdRsrp1FieldNumber = 1;
  ::google::protobuf::int64 threshold_rsrp_1() const;
  void set_threshold_rsrp_1(::google::protobuf::int64 value);

  // optional int64 threshold_rsrp_2 = 2;
  bool has_threshold_rsrp_2() const;
  void clear_threshold_rsrp_2();
  static const int kThresholdRsrp2FieldNumber = 2;
  ::google::protobuf::int64 threshold_rsrp_2() const;
  void set_threshold_rsrp_2(::google::protobuf::int64 value);

  // optional int64 hysteresis = 3;
  bool has_hysteresis() const;
  void clear_hysteresis();
  static const int kHysteresisFieldNumber = 3;
  ::google::protobuf::int64 hysteresis() const;
  void set_hysteresis(::google::protobuf::int64 value);

  // optional int64 time_to_trigger = 4;
  bool has_time_to_trigger() const;
  void clear_time_to_trigger();
  static const int kTimeToTriggerFieldNumber = 4;
  ::google::protobuf::int64 time_to_trigger() const;
  void set_time_to_trigger(::google::protobuf::int64 value);

  // optional int64 max_report_cells = 5;
  bool has_max_report_cells() const;
  void clear_max_report_cells();
  static const int kMaxReportCellsFieldNumber = 5;
  ::google::protobuf::int64 max_report_cells() const;
  void set_max_report_cells(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_a5_event)
 private:
  void set_has_threshold_rsrp_1();
  void clear_has_threshold_rsrp_1();
  void set_has_threshold_rsrp_2();
  void clear_has_threshold_rsrp_2();
  void set_has_hysteresis();
  void clear_has_hysteresis();
  void set_has_time_to_trigger();
  void clear_has_time_to_trigger();
  void set_has_max_report_cells();
  void clear_has_max_report_cells();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 threshold_rsrp_1_;
  ::google::protobuf::int64 threshold_rsrp_2_;
  ::google::protobuf::int64 hysteresis_;
  ::google::protobuf::int64 time_to_trigger_;
  ::google::protobuf::int64 max_report_cells_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_gummei : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_gummei) */ {
 public:
  flex_gummei();
  virtual ~flex_gummei();

  flex_gummei(const flex_gummei& from);

  inline flex_gummei& operator=(const flex_gummei& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_gummei& default_instance();

  static inline const flex_gummei* internal_default_instance() {
    return reinterpret_cast<const flex_gummei*>(
               &_flex_gummei_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(flex_gummei* other);

  // implements Message ----------------------------------------------

  inline flex_gummei* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_gummei* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_gummei& from);
  void MergeFrom(const flex_gummei& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_gummei* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.flex_plmn plmn = 1;
  bool has_plmn() const;
  void clear_plmn();
  static const int kPlmnFieldNumber = 1;
  const ::protocol::flex_plmn& plmn() const;
  ::protocol::flex_plmn* mutable_plmn();
  ::protocol::flex_plmn* release_plmn();
  void set_allocated_plmn(::protocol::flex_plmn* plmn);

  // optional uint32 mme_group_id = 2;
  bool has_mme_group_id() const;
  void clear_mme_group_id();
  static const int kMmeGroupIdFieldNumber = 2;
  ::google::protobuf::uint32 mme_group_id() const;
  void set_mme_group_id(::google::protobuf::uint32 value);

  // optional uint32 mme_code = 3;
  bool has_mme_code() const;
  void clear_mme_code();
  static const int kMmeCodeFieldNumber = 3;
  ::google::protobuf::uint32 mme_code() const;
  void set_mme_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_gummei)
 private:
  void set_has_plmn();
  void clear_has_plmn();
  void set_has_mme_group_id();
  void clear_has_mme_group_id();
  void set_has_mme_code();
  void clear_has_mme_code();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::flex_plmn* plmn_;
  ::google::protobuf::uint32 mme_group_id_;
  ::google::protobuf::uint32 mme_code_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class flex_s1ap_mme : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.flex_s1ap_mme) */ {
 public:
  flex_s1ap_mme();
  virtual ~flex_s1ap_mme();

  flex_s1ap_mme(const flex_s1ap_mme& from);

  inline flex_s1ap_mme& operator=(const flex_s1ap_mme& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const flex_s1ap_mme& default_instance();

  static inline const flex_s1ap_mme* internal_default_instance() {
    return reinterpret_cast<const flex_s1ap_mme*>(
               &_flex_s1ap_mme_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(flex_s1ap_mme* other);

  // implements Message ----------------------------------------------

  inline flex_s1ap_mme* New() const PROTOBUF_FINAL { return New(NULL); }

  flex_s1ap_mme* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const flex_s1ap_mme& from);
  void MergeFrom(const flex_s1ap_mme& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(flex_s1ap_mme* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.flex_gummei served_gummeis = 4;
  int served_gummeis_size() const;
  void clear_served_gummeis();
  static const int kServedGummeisFieldNumber = 4;
  const ::protocol::flex_gummei& served_gummeis(int index) const;
  ::protocol::flex_gummei* mutable_served_gummeis(int index);
  ::protocol::flex_gummei* add_served_gummeis();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_gummei >*
      mutable_served_gummeis();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_gummei >&
      served_gummeis() const;

  // repeated .protocol.flex_plmn requested_plmns = 5;
  int requested_plmns_size() const;
  void clear_requested_plmns();
  static const int kRequestedPlmnsFieldNumber = 5;
  const ::protocol::flex_plmn& requested_plmns(int index) const;
  ::protocol::flex_plmn* mutable_requested_plmns(int index);
  ::protocol::flex_plmn* add_requested_plmns();
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_plmn >*
      mutable_requested_plmns();
  const ::google::protobuf::RepeatedPtrField< ::protocol::flex_plmn >&
      requested_plmns() const;

  // optional string s1_ip = 1;
  bool has_s1_ip() const;
  void clear_s1_ip();
  static const int kS1IpFieldNumber = 1;
  const ::std::string& s1_ip() const;
  void set_s1_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_s1_ip(::std::string&& value);
  #endif
  void set_s1_ip(const char* value);
  void set_s1_ip(const char* value, size_t size);
  ::std::string* mutable_s1_ip();
  ::std::string* release_s1_ip();
  void set_allocated_s1_ip(::std::string* s1_ip);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .protocol.flex_mme_state state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::protocol::flex_mme_state state() const;
  void set_state(::protocol::flex_mme_state value);

  // optional uint32 rel_capacity = 6;
  bool has_rel_capacity() const;
  void clear_rel_capacity();
  static const int kRelCapacityFieldNumber = 6;
  ::google::protobuf::uint32 rel_capacity() const;
  void set_rel_capacity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.flex_s1ap_mme)
 private:
  void set_has_s1_ip();
  void clear_has_s1_ip();
  void set_has_name();
  void clear_has_name();
  void set_has_state();
  void clear_has_state();
  void set_has_rel_capacity();
  void clear_has_rel_capacity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_gummei > served_gummeis_;
  ::google::protobuf::RepeatedPtrField< ::protocol::flex_plmn > requested_plmns_;
  ::google::protobuf::internal::ArenaStringPtr s1_ip_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int state_;
  ::google::protobuf::uint32 rel_capacity_;
  friend struct protobuf_config_5fcommon_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// flex_si_config

// optional uint32 sfn = 1;
inline bool flex_si_config::has_sfn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_si_config::set_has_sfn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_si_config::clear_has_sfn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_si_config::clear_sfn() {
  sfn_ = 0u;
  clear_has_sfn();
}
inline ::google::protobuf::uint32 flex_si_config::sfn() const {
  // @@protoc_insertion_point(field_get:protocol.flex_si_config.sfn)
  return sfn_;
}
inline void flex_si_config::set_sfn(::google::protobuf::uint32 value) {
  set_has_sfn();
  sfn_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_si_config.sfn)
}

// optional uint32 sib1_length = 2;
inline bool flex_si_config::has_sib1_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_si_config::set_has_sib1_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_si_config::clear_has_sib1_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_si_config::clear_sib1_length() {
  sib1_length_ = 0u;
  clear_has_sib1_length();
}
inline ::google::protobuf::uint32 flex_si_config::sib1_length() const {
  // @@protoc_insertion_point(field_get:protocol.flex_si_config.sib1_length)
  return sib1_length_;
}
inline void flex_si_config::set_sib1_length(::google::protobuf::uint32 value) {
  set_has_sib1_length();
  sib1_length_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_si_config.sib1_length)
}

// optional uint32 si_window_length = 3;
inline bool flex_si_config::has_si_window_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_si_config::set_has_si_window_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_si_config::clear_has_si_window_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_si_config::clear_si_window_length() {
  si_window_length_ = 0u;
  clear_has_si_window_length();
}
inline ::google::protobuf::uint32 flex_si_config::si_window_length() const {
  // @@protoc_insertion_point(field_get:protocol.flex_si_config.si_window_length)
  return si_window_length_;
}
inline void flex_si_config::set_si_window_length(::google::protobuf::uint32 value) {
  set_has_si_window_length();
  si_window_length_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_si_config.si_window_length)
}

// repeated .protocol.flex_si_message si_message = 4;
inline int flex_si_config::si_message_size() const {
  return si_message_.size();
}
inline void flex_si_config::clear_si_message() {
  si_message_.Clear();
}
inline const ::protocol::flex_si_message& flex_si_config::si_message(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_si_config.si_message)
  return si_message_.Get(index);
}
inline ::protocol::flex_si_message* flex_si_config::mutable_si_message(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_si_config.si_message)
  return si_message_.Mutable(index);
}
inline ::protocol::flex_si_message* flex_si_config::add_si_message() {
  // @@protoc_insertion_point(field_add:protocol.flex_si_config.si_message)
  return si_message_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_si_message >*
flex_si_config::mutable_si_message() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_si_config.si_message)
  return &si_message_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_si_message >&
flex_si_config::si_message() const {
  // @@protoc_insertion_point(field_list:protocol.flex_si_config.si_message)
  return si_message_;
}

// -------------------------------------------------------------------

// flex_si_message

// optional uint32 periodicity = 1;
inline bool flex_si_message::has_periodicity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_si_message::set_has_periodicity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_si_message::clear_has_periodicity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_si_message::clear_periodicity() {
  periodicity_ = 0u;
  clear_has_periodicity();
}
inline ::google::protobuf::uint32 flex_si_message::periodicity() const {
  // @@protoc_insertion_point(field_get:protocol.flex_si_message.periodicity)
  return periodicity_;
}
inline void flex_si_message::set_periodicity(::google::protobuf::uint32 value) {
  set_has_periodicity();
  periodicity_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_si_message.periodicity)
}

// optional uint32 length = 2;
inline bool flex_si_message::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_si_message::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_si_message::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_si_message::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 flex_si_message::length() const {
  // @@protoc_insertion_point(field_get:protocol.flex_si_message.length)
  return length_;
}
inline void flex_si_message::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_si_message.length)
}

// -------------------------------------------------------------------

// flex_slice_static

// optional uint32 posLow = 1;
inline bool flex_slice_static::has_poslow() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_slice_static::set_has_poslow() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_slice_static::clear_has_poslow() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_slice_static::clear_poslow() {
  poslow_ = 0u;
  clear_has_poslow();
}
inline ::google::protobuf::uint32 flex_slice_static::poslow() const {
  // @@protoc_insertion_point(field_get:protocol.flex_slice_static.posLow)
  return poslow_;
}
inline void flex_slice_static::set_poslow(::google::protobuf::uint32 value) {
  set_has_poslow();
  poslow_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_slice_static.posLow)
}

// optional uint32 posHigh = 2;
inline bool flex_slice_static::has_poshigh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_slice_static::set_has_poshigh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_slice_static::clear_has_poshigh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_slice_static::clear_poshigh() {
  poshigh_ = 0u;
  clear_has_poshigh();
}
inline ::google::protobuf::uint32 flex_slice_static::poshigh() const {
  // @@protoc_insertion_point(field_get:protocol.flex_slice_static.posHigh)
  return poshigh_;
}
inline void flex_slice_static::set_poshigh(::google::protobuf::uint32 value) {
  set_has_poshigh();
  poshigh_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_slice_static.posHigh)
}

// -------------------------------------------------------------------

// flex_slice

// optional uint32 id = 1;
inline bool flex_slice::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_slice::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_slice::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_slice::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 flex_slice::id() const {
  // @@protoc_insertion_point(field_get:protocol.flex_slice.id)
  return id_;
}
inline void flex_slice::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_slice.id)
}

// optional string label = 2;
inline bool flex_slice::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_slice::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_slice::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_slice::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& flex_slice::label() const {
  // @@protoc_insertion_point(field_get:protocol.flex_slice.label)
  return label_.GetNoArena();
}
inline void flex_slice::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.flex_slice.label)
}
#if LANG_CXX11
inline void flex_slice::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_slice.label)
}
#endif
inline void flex_slice::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.flex_slice.label)
}
inline void flex_slice::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_slice.label)
}
inline ::std::string* flex_slice::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:protocol.flex_slice.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* flex_slice::release_label() {
  // @@protoc_insertion_point(field_release:protocol.flex_slice.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void flex_slice::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_slice.label)
}

// optional string scheduler = 3;
inline bool flex_slice::has_scheduler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_slice::set_has_scheduler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_slice::clear_has_scheduler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_slice::clear_scheduler() {
  scheduler_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_scheduler();
}
inline const ::std::string& flex_slice::scheduler() const {
  // @@protoc_insertion_point(field_get:protocol.flex_slice.scheduler)
  return scheduler_.GetNoArena();
}
inline void flex_slice::set_scheduler(const ::std::string& value) {
  set_has_scheduler();
  scheduler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.flex_slice.scheduler)
}
#if LANG_CXX11
inline void flex_slice::set_scheduler(::std::string&& value) {
  set_has_scheduler();
  scheduler_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_slice.scheduler)
}
#endif
inline void flex_slice::set_scheduler(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_scheduler();
  scheduler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.flex_slice.scheduler)
}
inline void flex_slice::set_scheduler(const char* value, size_t size) {
  set_has_scheduler();
  scheduler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_slice.scheduler)
}
inline ::std::string* flex_slice::mutable_scheduler() {
  set_has_scheduler();
  // @@protoc_insertion_point(field_mutable:protocol.flex_slice.scheduler)
  return scheduler_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* flex_slice::release_scheduler() {
  // @@protoc_insertion_point(field_release:protocol.flex_slice.scheduler)
  clear_has_scheduler();
  return scheduler_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void flex_slice::set_allocated_scheduler(::std::string* scheduler) {
  if (scheduler != NULL) {
    set_has_scheduler();
  } else {
    clear_has_scheduler();
  }
  scheduler_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scheduler);
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_slice.scheduler)
}

// optional .protocol.flex_slice_static static = 10;
inline bool flex_slice::has_static_() const {
  return params_case() == kStatic;
}
inline void flex_slice::set_has_static_() {
  _oneof_case_[0] = kStatic;
}
inline void flex_slice::clear_static_() {
  if (has_static_()) {
    delete params_.static__;
    clear_has_params();
  }
}
inline  const ::protocol::flex_slice_static& flex_slice::static_() const {
  // @@protoc_insertion_point(field_get:protocol.flex_slice.static)
  return has_static_()
      ? *params_.static__
      : ::protocol::flex_slice_static::default_instance();
}
inline ::protocol::flex_slice_static* flex_slice::mutable_static_() {
  if (!has_static_()) {
    clear_params();
    set_has_static_();
    params_.static__ = new ::protocol::flex_slice_static;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_slice.static)
  return params_.static__;
}
inline ::protocol::flex_slice_static* flex_slice::release_static_() {
  // @@protoc_insertion_point(field_release:protocol.flex_slice.static)
  if (has_static_()) {
    clear_has_params();
    ::protocol::flex_slice_static* temp = params_.static__;
    params_.static__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void flex_slice::set_allocated_static_(::protocol::flex_slice_static* static_) {
  clear_params();
  if (static_) {
    set_has_static_();
    params_.static__ = static_;
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_slice.static)
}

inline bool flex_slice::has_params() const {
  return params_case() != PARAMS_NOT_SET;
}
inline void flex_slice::clear_has_params() {
  _oneof_case_[0] = PARAMS_NOT_SET;
}
inline flex_slice::ParamsCase flex_slice::params_case() const {
  return flex_slice::ParamsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// flex_slice_dl_ul_config

// optional .protocol.flex_slice_algorithm algorithm = 1;
inline bool flex_slice_dl_ul_config::has_algorithm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_slice_dl_ul_config::set_has_algorithm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_slice_dl_ul_config::clear_has_algorithm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_slice_dl_ul_config::clear_algorithm() {
  algorithm_ = 0;
  clear_has_algorithm();
}
inline ::protocol::flex_slice_algorithm flex_slice_dl_ul_config::algorithm() const {
  // @@protoc_insertion_point(field_get:protocol.flex_slice_dl_ul_config.algorithm)
  return static_cast< ::protocol::flex_slice_algorithm >(algorithm_);
}
inline void flex_slice_dl_ul_config::set_algorithm(::protocol::flex_slice_algorithm value) {
  assert(::protocol::flex_slice_algorithm_IsValid(value));
  set_has_algorithm();
  algorithm_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_slice_dl_ul_config.algorithm)
}

// repeated .protocol.flex_slice slices = 2;
inline int flex_slice_dl_ul_config::slices_size() const {
  return slices_.size();
}
inline void flex_slice_dl_ul_config::clear_slices() {
  slices_.Clear();
}
inline const ::protocol::flex_slice& flex_slice_dl_ul_config::slices(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_slice_dl_ul_config.slices)
  return slices_.Get(index);
}
inline ::protocol::flex_slice* flex_slice_dl_ul_config::mutable_slices(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_slice_dl_ul_config.slices)
  return slices_.Mutable(index);
}
inline ::protocol::flex_slice* flex_slice_dl_ul_config::add_slices() {
  // @@protoc_insertion_point(field_add:protocol.flex_slice_dl_ul_config.slices)
  return slices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_slice >*
flex_slice_dl_ul_config::mutable_slices() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_slice_dl_ul_config.slices)
  return &slices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_slice >&
flex_slice_dl_ul_config::slices() const {
  // @@protoc_insertion_point(field_list:protocol.flex_slice_dl_ul_config.slices)
  return slices_;
}

// optional string scheduler = 3;
inline bool flex_slice_dl_ul_config::has_scheduler() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_slice_dl_ul_config::set_has_scheduler() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_slice_dl_ul_config::clear_has_scheduler() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_slice_dl_ul_config::clear_scheduler() {
  scheduler_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_scheduler();
}
inline const ::std::string& flex_slice_dl_ul_config::scheduler() const {
  // @@protoc_insertion_point(field_get:protocol.flex_slice_dl_ul_config.scheduler)
  return scheduler_.GetNoArena();
}
inline void flex_slice_dl_ul_config::set_scheduler(const ::std::string& value) {
  set_has_scheduler();
  scheduler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.flex_slice_dl_ul_config.scheduler)
}
#if LANG_CXX11
inline void flex_slice_dl_ul_config::set_scheduler(::std::string&& value) {
  set_has_scheduler();
  scheduler_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_slice_dl_ul_config.scheduler)
}
#endif
inline void flex_slice_dl_ul_config::set_scheduler(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_scheduler();
  scheduler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.flex_slice_dl_ul_config.scheduler)
}
inline void flex_slice_dl_ul_config::set_scheduler(const char* value, size_t size) {
  set_has_scheduler();
  scheduler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_slice_dl_ul_config.scheduler)
}
inline ::std::string* flex_slice_dl_ul_config::mutable_scheduler() {
  set_has_scheduler();
  // @@protoc_insertion_point(field_mutable:protocol.flex_slice_dl_ul_config.scheduler)
  return scheduler_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* flex_slice_dl_ul_config::release_scheduler() {
  // @@protoc_insertion_point(field_release:protocol.flex_slice_dl_ul_config.scheduler)
  clear_has_scheduler();
  return scheduler_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void flex_slice_dl_ul_config::set_allocated_scheduler(::std::string* scheduler) {
  if (scheduler != NULL) {
    set_has_scheduler();
  } else {
    clear_has_scheduler();
  }
  scheduler_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scheduler);
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_slice_dl_ul_config.scheduler)
}

// -------------------------------------------------------------------

// flex_drx_config

// optional uint32 on_duration_timer = 1;
inline bool flex_drx_config::has_on_duration_timer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_drx_config::set_has_on_duration_timer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_drx_config::clear_has_on_duration_timer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_drx_config::clear_on_duration_timer() {
  on_duration_timer_ = 0u;
  clear_has_on_duration_timer();
}
inline ::google::protobuf::uint32 flex_drx_config::on_duration_timer() const {
  // @@protoc_insertion_point(field_get:protocol.flex_drx_config.on_duration_timer)
  return on_duration_timer_;
}
inline void flex_drx_config::set_on_duration_timer(::google::protobuf::uint32 value) {
  set_has_on_duration_timer();
  on_duration_timer_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_drx_config.on_duration_timer)
}

// optional uint32 drx_inactivity_timer = 2;
inline bool flex_drx_config::has_drx_inactivity_timer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_drx_config::set_has_drx_inactivity_timer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_drx_config::clear_has_drx_inactivity_timer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_drx_config::clear_drx_inactivity_timer() {
  drx_inactivity_timer_ = 0u;
  clear_has_drx_inactivity_timer();
}
inline ::google::protobuf::uint32 flex_drx_config::drx_inactivity_timer() const {
  // @@protoc_insertion_point(field_get:protocol.flex_drx_config.drx_inactivity_timer)
  return drx_inactivity_timer_;
}
inline void flex_drx_config::set_drx_inactivity_timer(::google::protobuf::uint32 value) {
  set_has_drx_inactivity_timer();
  drx_inactivity_timer_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_drx_config.drx_inactivity_timer)
}

// optional uint32 drx_retransmission_timer = 3;
inline bool flex_drx_config::has_drx_retransmission_timer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_drx_config::set_has_drx_retransmission_timer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_drx_config::clear_has_drx_retransmission_timer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_drx_config::clear_drx_retransmission_timer() {
  drx_retransmission_timer_ = 0u;
  clear_has_drx_retransmission_timer();
}
inline ::google::protobuf::uint32 flex_drx_config::drx_retransmission_timer() const {
  // @@protoc_insertion_point(field_get:protocol.flex_drx_config.drx_retransmission_timer)
  return drx_retransmission_timer_;
}
inline void flex_drx_config::set_drx_retransmission_timer(::google::protobuf::uint32 value) {
  set_has_drx_retransmission_timer();
  drx_retransmission_timer_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_drx_config.drx_retransmission_timer)
}

// optional uint32 long_drx_cycle = 4;
inline bool flex_drx_config::has_long_drx_cycle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_drx_config::set_has_long_drx_cycle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_drx_config::clear_has_long_drx_cycle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_drx_config::clear_long_drx_cycle() {
  long_drx_cycle_ = 0u;
  clear_has_long_drx_cycle();
}
inline ::google::protobuf::uint32 flex_drx_config::long_drx_cycle() const {
  // @@protoc_insertion_point(field_get:protocol.flex_drx_config.long_drx_cycle)
  return long_drx_cycle_;
}
inline void flex_drx_config::set_long_drx_cycle(::google::protobuf::uint32 value) {
  set_has_long_drx_cycle();
  long_drx_cycle_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_drx_config.long_drx_cycle)
}

// optional uint32 long_drx_cycle_start_offset = 5;
inline bool flex_drx_config::has_long_drx_cycle_start_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void flex_drx_config::set_has_long_drx_cycle_start_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void flex_drx_config::clear_has_long_drx_cycle_start_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void flex_drx_config::clear_long_drx_cycle_start_offset() {
  long_drx_cycle_start_offset_ = 0u;
  clear_has_long_drx_cycle_start_offset();
}
inline ::google::protobuf::uint32 flex_drx_config::long_drx_cycle_start_offset() const {
  // @@protoc_insertion_point(field_get:protocol.flex_drx_config.long_drx_cycle_start_offset)
  return long_drx_cycle_start_offset_;
}
inline void flex_drx_config::set_long_drx_cycle_start_offset(::google::protobuf::uint32 value) {
  set_has_long_drx_cycle_start_offset();
  long_drx_cycle_start_offset_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_drx_config.long_drx_cycle_start_offset)
}

// optional uint32 short_drx_cycle = 6;
inline bool flex_drx_config::has_short_drx_cycle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void flex_drx_config::set_has_short_drx_cycle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void flex_drx_config::clear_has_short_drx_cycle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void flex_drx_config::clear_short_drx_cycle() {
  short_drx_cycle_ = 0u;
  clear_has_short_drx_cycle();
}
inline ::google::protobuf::uint32 flex_drx_config::short_drx_cycle() const {
  // @@protoc_insertion_point(field_get:protocol.flex_drx_config.short_drx_cycle)
  return short_drx_cycle_;
}
inline void flex_drx_config::set_short_drx_cycle(::google::protobuf::uint32 value) {
  set_has_short_drx_cycle();
  short_drx_cycle_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_drx_config.short_drx_cycle)
}

// optional uint32 drx_short_cycle_timer = 7;
inline bool flex_drx_config::has_drx_short_cycle_timer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void flex_drx_config::set_has_drx_short_cycle_timer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void flex_drx_config::clear_has_drx_short_cycle_timer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void flex_drx_config::clear_drx_short_cycle_timer() {
  drx_short_cycle_timer_ = 0u;
  clear_has_drx_short_cycle_timer();
}
inline ::google::protobuf::uint32 flex_drx_config::drx_short_cycle_timer() const {
  // @@protoc_insertion_point(field_get:protocol.flex_drx_config.drx_short_cycle_timer)
  return drx_short_cycle_timer_;
}
inline void flex_drx_config::set_drx_short_cycle_timer(::google::protobuf::uint32 value) {
  set_has_drx_short_cycle_timer();
  drx_short_cycle_timer_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_drx_config.drx_short_cycle_timer)
}

// -------------------------------------------------------------------

// flex_sps_config

// optional uint32 semi_persistent_sched_interval_UL = 1;
inline bool flex_sps_config::has_semi_persistent_sched_interval_ul() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_sps_config::set_has_semi_persistent_sched_interval_ul() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_sps_config::clear_has_semi_persistent_sched_interval_ul() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_sps_config::clear_semi_persistent_sched_interval_ul() {
  semi_persistent_sched_interval_ul_ = 0u;
  clear_has_semi_persistent_sched_interval_ul();
}
inline ::google::protobuf::uint32 flex_sps_config::semi_persistent_sched_interval_ul() const {
  // @@protoc_insertion_point(field_get:protocol.flex_sps_config.semi_persistent_sched_interval_UL)
  return semi_persistent_sched_interval_ul_;
}
inline void flex_sps_config::set_semi_persistent_sched_interval_ul(::google::protobuf::uint32 value) {
  set_has_semi_persistent_sched_interval_ul();
  semi_persistent_sched_interval_ul_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_sps_config.semi_persistent_sched_interval_UL)
}

// optional uint32 semi_persistent_sched_interval_DL = 2;
inline bool flex_sps_config::has_semi_persistent_sched_interval_dl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_sps_config::set_has_semi_persistent_sched_interval_dl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_sps_config::clear_has_semi_persistent_sched_interval_dl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_sps_config::clear_semi_persistent_sched_interval_dl() {
  semi_persistent_sched_interval_dl_ = 0u;
  clear_has_semi_persistent_sched_interval_dl();
}
inline ::google::protobuf::uint32 flex_sps_config::semi_persistent_sched_interval_dl() const {
  // @@protoc_insertion_point(field_get:protocol.flex_sps_config.semi_persistent_sched_interval_DL)
  return semi_persistent_sched_interval_dl_;
}
inline void flex_sps_config::set_semi_persistent_sched_interval_dl(::google::protobuf::uint32 value) {
  set_has_semi_persistent_sched_interval_dl();
  semi_persistent_sched_interval_dl_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_sps_config.semi_persistent_sched_interval_DL)
}

// optional uint32 num_of_conf_sps_proc = 3;
inline bool flex_sps_config::has_num_of_conf_sps_proc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_sps_config::set_has_num_of_conf_sps_proc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_sps_config::clear_has_num_of_conf_sps_proc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_sps_config::clear_num_of_conf_sps_proc() {
  num_of_conf_sps_proc_ = 0u;
  clear_has_num_of_conf_sps_proc();
}
inline ::google::protobuf::uint32 flex_sps_config::num_of_conf_sps_proc() const {
  // @@protoc_insertion_point(field_get:protocol.flex_sps_config.num_of_conf_sps_proc)
  return num_of_conf_sps_proc_;
}
inline void flex_sps_config::set_num_of_conf_sps_proc(::google::protobuf::uint32 value) {
  set_has_num_of_conf_sps_proc();
  num_of_conf_sps_proc_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_sps_config.num_of_conf_sps_proc)
}

// repeated uint32 n1_PUCCH_AN_persistent_element = 4;
inline int flex_sps_config::n1_pucch_an_persistent_element_size() const {
  return n1_pucch_an_persistent_element_.size();
}
inline void flex_sps_config::clear_n1_pucch_an_persistent_element() {
  n1_pucch_an_persistent_element_.Clear();
}
inline ::google::protobuf::uint32 flex_sps_config::n1_pucch_an_persistent_element(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_sps_config.n1_PUCCH_AN_persistent_element)
  return n1_pucch_an_persistent_element_.Get(index);
}
inline void flex_sps_config::set_n1_pucch_an_persistent_element(int index, ::google::protobuf::uint32 value) {
  n1_pucch_an_persistent_element_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.flex_sps_config.n1_PUCCH_AN_persistent_element)
}
inline void flex_sps_config::add_n1_pucch_an_persistent_element(::google::protobuf::uint32 value) {
  n1_pucch_an_persistent_element_.Add(value);
  // @@protoc_insertion_point(field_add:protocol.flex_sps_config.n1_PUCCH_AN_persistent_element)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
flex_sps_config::n1_pucch_an_persistent_element() const {
  // @@protoc_insertion_point(field_list:protocol.flex_sps_config.n1_PUCCH_AN_persistent_element)
  return n1_pucch_an_persistent_element_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
flex_sps_config::mutable_n1_pucch_an_persistent_element() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_sps_config.n1_PUCCH_AN_persistent_element)
  return &n1_pucch_an_persistent_element_;
}

// optional uint32 implicit_release_after = 5;
inline bool flex_sps_config::has_implicit_release_after() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_sps_config::set_has_implicit_release_after() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_sps_config::clear_has_implicit_release_after() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_sps_config::clear_implicit_release_after() {
  implicit_release_after_ = 0u;
  clear_has_implicit_release_after();
}
inline ::google::protobuf::uint32 flex_sps_config::implicit_release_after() const {
  // @@protoc_insertion_point(field_get:protocol.flex_sps_config.implicit_release_after)
  return implicit_release_after_;
}
inline void flex_sps_config::set_implicit_release_after(::google::protobuf::uint32 value) {
  set_has_implicit_release_after();
  implicit_release_after_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_sps_config.implicit_release_after)
}

// -------------------------------------------------------------------

// flex_sr_config

// optional uint32 sr_action = 1;
inline bool flex_sr_config::has_sr_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_sr_config::set_has_sr_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_sr_config::clear_has_sr_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_sr_config::clear_sr_action() {
  sr_action_ = 0u;
  clear_has_sr_action();
}
inline ::google::protobuf::uint32 flex_sr_config::sr_action() const {
  // @@protoc_insertion_point(field_get:protocol.flex_sr_config.sr_action)
  return sr_action_;
}
inline void flex_sr_config::set_sr_action(::google::protobuf::uint32 value) {
  set_has_sr_action();
  sr_action_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_sr_config.sr_action)
}

// optional uint32 sched_interval = 2;
inline bool flex_sr_config::has_sched_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_sr_config::set_has_sched_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_sr_config::clear_has_sched_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_sr_config::clear_sched_interval() {
  sched_interval_ = 0u;
  clear_has_sched_interval();
}
inline ::google::protobuf::uint32 flex_sr_config::sched_interval() const {
  // @@protoc_insertion_point(field_get:protocol.flex_sr_config.sched_interval)
  return sched_interval_;
}
inline void flex_sr_config::set_sched_interval(::google::protobuf::uint32 value) {
  set_has_sched_interval();
  sched_interval_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_sr_config.sched_interval)
}

// optional uint32 dsr_trans_max = 3;
inline bool flex_sr_config::has_dsr_trans_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_sr_config::set_has_dsr_trans_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_sr_config::clear_has_dsr_trans_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_sr_config::clear_dsr_trans_max() {
  dsr_trans_max_ = 0u;
  clear_has_dsr_trans_max();
}
inline ::google::protobuf::uint32 flex_sr_config::dsr_trans_max() const {
  // @@protoc_insertion_point(field_get:protocol.flex_sr_config.dsr_trans_max)
  return dsr_trans_max_;
}
inline void flex_sr_config::set_dsr_trans_max(::google::protobuf::uint32 value) {
  set_has_dsr_trans_max();
  dsr_trans_max_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_sr_config.dsr_trans_max)
}

// -------------------------------------------------------------------

// flex_cqi_config

// optional uint32 cqi_action = 1;
inline bool flex_cqi_config::has_cqi_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_cqi_config::set_has_cqi_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_cqi_config::clear_has_cqi_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_cqi_config::clear_cqi_action() {
  cqi_action_ = 0u;
  clear_has_cqi_action();
}
inline ::google::protobuf::uint32 flex_cqi_config::cqi_action() const {
  // @@protoc_insertion_point(field_get:protocol.flex_cqi_config.cqi_action)
  return cqi_action_;
}
inline void flex_cqi_config::set_cqi_action(::google::protobuf::uint32 value) {
  set_has_cqi_action();
  cqi_action_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_cqi_config.cqi_action)
}

// optional uint32 cqi_sched_interval = 2;
inline bool flex_cqi_config::has_cqi_sched_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_cqi_config::set_has_cqi_sched_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_cqi_config::clear_has_cqi_sched_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_cqi_config::clear_cqi_sched_interval() {
  cqi_sched_interval_ = 0u;
  clear_has_cqi_sched_interval();
}
inline ::google::protobuf::uint32 flex_cqi_config::cqi_sched_interval() const {
  // @@protoc_insertion_point(field_get:protocol.flex_cqi_config.cqi_sched_interval)
  return cqi_sched_interval_;
}
inline void flex_cqi_config::set_cqi_sched_interval(::google::protobuf::uint32 value) {
  set_has_cqi_sched_interval();
  cqi_sched_interval_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_cqi_config.cqi_sched_interval)
}

// optional uint32 ri_sched_interval = 3;
inline bool flex_cqi_config::has_ri_sched_interval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_cqi_config::set_has_ri_sched_interval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_cqi_config::clear_has_ri_sched_interval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_cqi_config::clear_ri_sched_interval() {
  ri_sched_interval_ = 0u;
  clear_has_ri_sched_interval();
}
inline ::google::protobuf::uint32 flex_cqi_config::ri_sched_interval() const {
  // @@protoc_insertion_point(field_get:protocol.flex_cqi_config.ri_sched_interval)
  return ri_sched_interval_;
}
inline void flex_cqi_config::set_ri_sched_interval(::google::protobuf::uint32 value) {
  set_has_ri_sched_interval();
  ri_sched_interval_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_cqi_config.ri_sched_interval)
}

// -------------------------------------------------------------------

// flex_ue_capabilities

// optional uint32 half_duplex = 1;
inline bool flex_ue_capabilities::has_half_duplex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_ue_capabilities::set_has_half_duplex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_ue_capabilities::clear_has_half_duplex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_ue_capabilities::clear_half_duplex() {
  half_duplex_ = 0u;
  clear_has_half_duplex();
}
inline ::google::protobuf::uint32 flex_ue_capabilities::half_duplex() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_capabilities.half_duplex)
  return half_duplex_;
}
inline void flex_ue_capabilities::set_half_duplex(::google::protobuf::uint32 value) {
  set_has_half_duplex();
  half_duplex_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_ue_capabilities.half_duplex)
}

// optional uint32 intra_SF_hopping = 2;
inline bool flex_ue_capabilities::has_intra_sf_hopping() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_ue_capabilities::set_has_intra_sf_hopping() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_ue_capabilities::clear_has_intra_sf_hopping() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_ue_capabilities::clear_intra_sf_hopping() {
  intra_sf_hopping_ = 0u;
  clear_has_intra_sf_hopping();
}
inline ::google::protobuf::uint32 flex_ue_capabilities::intra_sf_hopping() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_capabilities.intra_SF_hopping)
  return intra_sf_hopping_;
}
inline void flex_ue_capabilities::set_intra_sf_hopping(::google::protobuf::uint32 value) {
  set_has_intra_sf_hopping();
  intra_sf_hopping_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_ue_capabilities.intra_SF_hopping)
}

// optional uint32 type2_sb_1 = 3;
inline bool flex_ue_capabilities::has_type2_sb_1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_ue_capabilities::set_has_type2_sb_1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_ue_capabilities::clear_has_type2_sb_1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_ue_capabilities::clear_type2_sb_1() {
  type2_sb_1_ = 0u;
  clear_has_type2_sb_1();
}
inline ::google::protobuf::uint32 flex_ue_capabilities::type2_sb_1() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_capabilities.type2_sb_1)
  return type2_sb_1_;
}
inline void flex_ue_capabilities::set_type2_sb_1(::google::protobuf::uint32 value) {
  set_has_type2_sb_1();
  type2_sb_1_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_ue_capabilities.type2_sb_1)
}

// optional uint32 ue_category = 4;
inline bool flex_ue_capabilities::has_ue_category() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_ue_capabilities::set_has_ue_category() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_ue_capabilities::clear_has_ue_category() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_ue_capabilities::clear_ue_category() {
  ue_category_ = 0u;
  clear_has_ue_category();
}
inline ::google::protobuf::uint32 flex_ue_capabilities::ue_category() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_capabilities.ue_category)
  return ue_category_;
}
inline void flex_ue_capabilities::set_ue_category(::google::protobuf::uint32 value) {
  set_has_ue_category();
  ue_category_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_ue_capabilities.ue_category)
}

// optional uint32 res_alloc_type1 = 5;
inline bool flex_ue_capabilities::has_res_alloc_type1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void flex_ue_capabilities::set_has_res_alloc_type1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void flex_ue_capabilities::clear_has_res_alloc_type1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void flex_ue_capabilities::clear_res_alloc_type1() {
  res_alloc_type1_ = 0u;
  clear_has_res_alloc_type1();
}
inline ::google::protobuf::uint32 flex_ue_capabilities::res_alloc_type1() const {
  // @@protoc_insertion_point(field_get:protocol.flex_ue_capabilities.res_alloc_type1)
  return res_alloc_type1_;
}
inline void flex_ue_capabilities::set_res_alloc_type1(::google::protobuf::uint32 value) {
  set_has_res_alloc_type1();
  res_alloc_type1_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_ue_capabilities.res_alloc_type1)
}

// -------------------------------------------------------------------

// flex_scell_config

// optional uint32 carrier_index = 1;
inline bool flex_scell_config::has_carrier_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_scell_config::set_has_carrier_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_scell_config::clear_has_carrier_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_scell_config::clear_carrier_index() {
  carrier_index_ = 0u;
  clear_has_carrier_index();
}
inline ::google::protobuf::uint32 flex_scell_config::carrier_index() const {
  // @@protoc_insertion_point(field_get:protocol.flex_scell_config.carrier_index)
  return carrier_index_;
}
inline void flex_scell_config::set_carrier_index(::google::protobuf::uint32 value) {
  set_has_carrier_index();
  carrier_index_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_scell_config.carrier_index)
}

// optional uint32 scell_index = 2;
inline bool flex_scell_config::has_scell_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_scell_config::set_has_scell_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_scell_config::clear_has_scell_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_scell_config::clear_scell_index() {
  scell_index_ = 0u;
  clear_has_scell_index();
}
inline ::google::protobuf::uint32 flex_scell_config::scell_index() const {
  // @@protoc_insertion_point(field_get:protocol.flex_scell_config.scell_index)
  return scell_index_;
}
inline void flex_scell_config::set_scell_index(::google::protobuf::uint32 value) {
  set_has_scell_index();
  scell_index_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_scell_config.scell_index)
}

// optional uint32 use_ccs = 3;
inline bool flex_scell_config::has_use_ccs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_scell_config::set_has_use_ccs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_scell_config::clear_has_use_ccs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_scell_config::clear_use_ccs() {
  use_ccs_ = 0u;
  clear_has_use_ccs();
}
inline ::google::protobuf::uint32 flex_scell_config::use_ccs() const {
  // @@protoc_insertion_point(field_get:protocol.flex_scell_config.use_ccs)
  return use_ccs_;
}
inline void flex_scell_config::set_use_ccs(::google::protobuf::uint32 value) {
  set_has_use_ccs();
  use_ccs_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_scell_config.use_ccs)
}

// optional uint32 sched_cell_index = 4;
inline bool flex_scell_config::has_sched_cell_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_scell_config::set_has_sched_cell_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_scell_config::clear_has_sched_cell_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_scell_config::clear_sched_cell_index() {
  sched_cell_index_ = 0u;
  clear_has_sched_cell_index();
}
inline ::google::protobuf::uint32 flex_scell_config::sched_cell_index() const {
  // @@protoc_insertion_point(field_get:protocol.flex_scell_config.sched_cell_index)
  return sched_cell_index_;
}
inline void flex_scell_config::set_sched_cell_index(::google::protobuf::uint32 value) {
  set_has_sched_cell_index();
  sched_cell_index_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_scell_config.sched_cell_index)
}

// optional uint32 pdsch_start = 5;
inline bool flex_scell_config::has_pdsch_start() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void flex_scell_config::set_has_pdsch_start() {
  _has_bits_[0] |= 0x00000010u;
}
inline void flex_scell_config::clear_has_pdsch_start() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void flex_scell_config::clear_pdsch_start() {
  pdsch_start_ = 0u;
  clear_has_pdsch_start();
}
inline ::google::protobuf::uint32 flex_scell_config::pdsch_start() const {
  // @@protoc_insertion_point(field_get:protocol.flex_scell_config.pdsch_start)
  return pdsch_start_;
}
inline void flex_scell_config::set_pdsch_start(::google::protobuf::uint32 value) {
  set_has_pdsch_start();
  pdsch_start_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_scell_config.pdsch_start)
}

// -------------------------------------------------------------------

// flex_lc_config

// optional uint32 lcid = 1;
inline bool flex_lc_config::has_lcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_lc_config::set_has_lcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_lc_config::clear_has_lcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_lc_config::clear_lcid() {
  lcid_ = 0u;
  clear_has_lcid();
}
inline ::google::protobuf::uint32 flex_lc_config::lcid() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config.lcid)
  return lcid_;
}
inline void flex_lc_config::set_lcid(::google::protobuf::uint32 value) {
  set_has_lcid();
  lcid_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_lc_config.lcid)
}

// optional uint32 lcg = 2;
inline bool flex_lc_config::has_lcg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_lc_config::set_has_lcg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_lc_config::clear_has_lcg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_lc_config::clear_lcg() {
  lcg_ = 0u;
  clear_has_lcg();
}
inline ::google::protobuf::uint32 flex_lc_config::lcg() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config.lcg)
  return lcg_;
}
inline void flex_lc_config::set_lcg(::google::protobuf::uint32 value) {
  set_has_lcg();
  lcg_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_lc_config.lcg)
}

// optional uint32 direction = 3;
inline bool flex_lc_config::has_direction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_lc_config::set_has_direction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_lc_config::clear_has_direction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_lc_config::clear_direction() {
  direction_ = 0u;
  clear_has_direction();
}
inline ::google::protobuf::uint32 flex_lc_config::direction() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config.direction)
  return direction_;
}
inline void flex_lc_config::set_direction(::google::protobuf::uint32 value) {
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_lc_config.direction)
}

// optional uint32 qos_bearer_type = 4;
inline bool flex_lc_config::has_qos_bearer_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_lc_config::set_has_qos_bearer_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_lc_config::clear_has_qos_bearer_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_lc_config::clear_qos_bearer_type() {
  qos_bearer_type_ = 0u;
  clear_has_qos_bearer_type();
}
inline ::google::protobuf::uint32 flex_lc_config::qos_bearer_type() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config.qos_bearer_type)
  return qos_bearer_type_;
}
inline void flex_lc_config::set_qos_bearer_type(::google::protobuf::uint32 value) {
  set_has_qos_bearer_type();
  qos_bearer_type_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_lc_config.qos_bearer_type)
}

// optional uint32 qci = 5;
inline bool flex_lc_config::has_qci() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void flex_lc_config::set_has_qci() {
  _has_bits_[0] |= 0x00000100u;
}
inline void flex_lc_config::clear_has_qci() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void flex_lc_config::clear_qci() {
  qci_ = 0u;
  clear_has_qci();
}
inline ::google::protobuf::uint32 flex_lc_config::qci() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config.qci)
  return qci_;
}
inline void flex_lc_config::set_qci(::google::protobuf::uint32 value) {
  set_has_qci();
  qci_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_lc_config.qci)
}

// optional uint64 e_RAB_max_bitrate_UL = 6;
inline bool flex_lc_config::has_e_rab_max_bitrate_ul() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void flex_lc_config::set_has_e_rab_max_bitrate_ul() {
  _has_bits_[0] |= 0x00000010u;
}
inline void flex_lc_config::clear_has_e_rab_max_bitrate_ul() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void flex_lc_config::clear_e_rab_max_bitrate_ul() {
  e_rab_max_bitrate_ul_ = GOOGLE_ULONGLONG(0);
  clear_has_e_rab_max_bitrate_ul();
}
inline ::google::protobuf::uint64 flex_lc_config::e_rab_max_bitrate_ul() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config.e_RAB_max_bitrate_UL)
  return e_rab_max_bitrate_ul_;
}
inline void flex_lc_config::set_e_rab_max_bitrate_ul(::google::protobuf::uint64 value) {
  set_has_e_rab_max_bitrate_ul();
  e_rab_max_bitrate_ul_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_lc_config.e_RAB_max_bitrate_UL)
}

// optional uint64 e_RAB_max_bitrate_DL = 7;
inline bool flex_lc_config::has_e_rab_max_bitrate_dl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void flex_lc_config::set_has_e_rab_max_bitrate_dl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void flex_lc_config::clear_has_e_rab_max_bitrate_dl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void flex_lc_config::clear_e_rab_max_bitrate_dl() {
  e_rab_max_bitrate_dl_ = GOOGLE_ULONGLONG(0);
  clear_has_e_rab_max_bitrate_dl();
}
inline ::google::protobuf::uint64 flex_lc_config::e_rab_max_bitrate_dl() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config.e_RAB_max_bitrate_DL)
  return e_rab_max_bitrate_dl_;
}
inline void flex_lc_config::set_e_rab_max_bitrate_dl(::google::protobuf::uint64 value) {
  set_has_e_rab_max_bitrate_dl();
  e_rab_max_bitrate_dl_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_lc_config.e_RAB_max_bitrate_DL)
}

// optional uint64 e_RAB_guaranteed_bitrate_UL = 8;
inline bool flex_lc_config::has_e_rab_guaranteed_bitrate_ul() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void flex_lc_config::set_has_e_rab_guaranteed_bitrate_ul() {
  _has_bits_[0] |= 0x00000040u;
}
inline void flex_lc_config::clear_has_e_rab_guaranteed_bitrate_ul() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void flex_lc_config::clear_e_rab_guaranteed_bitrate_ul() {
  e_rab_guaranteed_bitrate_ul_ = GOOGLE_ULONGLONG(0);
  clear_has_e_rab_guaranteed_bitrate_ul();
}
inline ::google::protobuf::uint64 flex_lc_config::e_rab_guaranteed_bitrate_ul() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config.e_RAB_guaranteed_bitrate_UL)
  return e_rab_guaranteed_bitrate_ul_;
}
inline void flex_lc_config::set_e_rab_guaranteed_bitrate_ul(::google::protobuf::uint64 value) {
  set_has_e_rab_guaranteed_bitrate_ul();
  e_rab_guaranteed_bitrate_ul_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_lc_config.e_RAB_guaranteed_bitrate_UL)
}

// optional uint64 e_RAB_guaranteed_bitrate_DL = 9;
inline bool flex_lc_config::has_e_rab_guaranteed_bitrate_dl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void flex_lc_config::set_has_e_rab_guaranteed_bitrate_dl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void flex_lc_config::clear_has_e_rab_guaranteed_bitrate_dl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void flex_lc_config::clear_e_rab_guaranteed_bitrate_dl() {
  e_rab_guaranteed_bitrate_dl_ = GOOGLE_ULONGLONG(0);
  clear_has_e_rab_guaranteed_bitrate_dl();
}
inline ::google::protobuf::uint64 flex_lc_config::e_rab_guaranteed_bitrate_dl() const {
  // @@protoc_insertion_point(field_get:protocol.flex_lc_config.e_RAB_guaranteed_bitrate_DL)
  return e_rab_guaranteed_bitrate_dl_;
}
inline void flex_lc_config::set_e_rab_guaranteed_bitrate_dl(::google::protobuf::uint64 value) {
  set_has_e_rab_guaranteed_bitrate_dl();
  e_rab_guaranteed_bitrate_dl_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_lc_config.e_RAB_guaranteed_bitrate_DL)
}

// -------------------------------------------------------------------

// flex_plmn

// optional uint32 mcc = 1;
inline bool flex_plmn::has_mcc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_plmn::set_has_mcc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_plmn::clear_has_mcc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_plmn::clear_mcc() {
  mcc_ = 0u;
  clear_has_mcc();
}
inline ::google::protobuf::uint32 flex_plmn::mcc() const {
  // @@protoc_insertion_point(field_get:protocol.flex_plmn.mcc)
  return mcc_;
}
inline void flex_plmn::set_mcc(::google::protobuf::uint32 value) {
  set_has_mcc();
  mcc_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_plmn.mcc)
}

// optional uint32 mnc = 2;
inline bool flex_plmn::has_mnc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_plmn::set_has_mnc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_plmn::clear_has_mnc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_plmn::clear_mnc() {
  mnc_ = 0u;
  clear_has_mnc();
}
inline ::google::protobuf::uint32 flex_plmn::mnc() const {
  // @@protoc_insertion_point(field_get:protocol.flex_plmn.mnc)
  return mnc_;
}
inline void flex_plmn::set_mnc(::google::protobuf::uint32 value) {
  set_has_mnc();
  mnc_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_plmn.mnc)
}

// optional uint32 mnc_length = 3;
inline bool flex_plmn::has_mnc_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_plmn::set_has_mnc_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_plmn::clear_has_mnc_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_plmn::clear_mnc_length() {
  mnc_length_ = 0u;
  clear_has_mnc_length();
}
inline ::google::protobuf::uint32 flex_plmn::mnc_length() const {
  // @@protoc_insertion_point(field_get:protocol.flex_plmn.mnc_length)
  return mnc_length_;
}
inline void flex_plmn::set_mnc_length(::google::protobuf::uint32 value) {
  set_has_mnc_length();
  mnc_length_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_plmn.mnc_length)
}

// -------------------------------------------------------------------

// flex_measurement_info

// optional int64 offset_freq_serving = 1;
inline bool flex_measurement_info::has_offset_freq_serving() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_measurement_info::set_has_offset_freq_serving() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_measurement_info::clear_has_offset_freq_serving() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_measurement_info::clear_offset_freq_serving() {
  offset_freq_serving_ = GOOGLE_LONGLONG(0);
  clear_has_offset_freq_serving();
}
inline ::google::protobuf::int64 flex_measurement_info::offset_freq_serving() const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_info.offset_freq_serving)
  return offset_freq_serving_;
}
inline void flex_measurement_info::set_offset_freq_serving(::google::protobuf::int64 value) {
  set_has_offset_freq_serving();
  offset_freq_serving_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_measurement_info.offset_freq_serving)
}

// optional int64 offset_freq_neighbouring = 2;
inline bool flex_measurement_info::has_offset_freq_neighbouring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_measurement_info::set_has_offset_freq_neighbouring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_measurement_info::clear_has_offset_freq_neighbouring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_measurement_info::clear_offset_freq_neighbouring() {
  offset_freq_neighbouring_ = GOOGLE_LONGLONG(0);
  clear_has_offset_freq_neighbouring();
}
inline ::google::protobuf::int64 flex_measurement_info::offset_freq_neighbouring() const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_info.offset_freq_neighbouring)
  return offset_freq_neighbouring_;
}
inline void flex_measurement_info::set_offset_freq_neighbouring(::google::protobuf::int64 value) {
  set_has_offset_freq_neighbouring();
  offset_freq_neighbouring_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_measurement_info.offset_freq_neighbouring)
}

// repeated int64 cell_individual_offset = 3;
inline int flex_measurement_info::cell_individual_offset_size() const {
  return cell_individual_offset_.size();
}
inline void flex_measurement_info::clear_cell_individual_offset() {
  cell_individual_offset_.Clear();
}
inline ::google::protobuf::int64 flex_measurement_info::cell_individual_offset(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_info.cell_individual_offset)
  return cell_individual_offset_.Get(index);
}
inline void flex_measurement_info::set_cell_individual_offset(int index, ::google::protobuf::int64 value) {
  cell_individual_offset_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.flex_measurement_info.cell_individual_offset)
}
inline void flex_measurement_info::add_cell_individual_offset(::google::protobuf::int64 value) {
  cell_individual_offset_.Add(value);
  // @@protoc_insertion_point(field_add:protocol.flex_measurement_info.cell_individual_offset)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
flex_measurement_info::cell_individual_offset() const {
  // @@protoc_insertion_point(field_list:protocol.flex_measurement_info.cell_individual_offset)
  return cell_individual_offset_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
flex_measurement_info::mutable_cell_individual_offset() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_measurement_info.cell_individual_offset)
  return &cell_individual_offset_;
}

// optional int64 filter_coefficient_rsrp = 4;
inline bool flex_measurement_info::has_filter_coefficient_rsrp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_measurement_info::set_has_filter_coefficient_rsrp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_measurement_info::clear_has_filter_coefficient_rsrp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_measurement_info::clear_filter_coefficient_rsrp() {
  filter_coefficient_rsrp_ = GOOGLE_LONGLONG(0);
  clear_has_filter_coefficient_rsrp();
}
inline ::google::protobuf::int64 flex_measurement_info::filter_coefficient_rsrp() const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_info.filter_coefficient_rsrp)
  return filter_coefficient_rsrp_;
}
inline void flex_measurement_info::set_filter_coefficient_rsrp(::google::protobuf::int64 value) {
  set_has_filter_coefficient_rsrp();
  filter_coefficient_rsrp_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_measurement_info.filter_coefficient_rsrp)
}

// optional int64 filter_coefficient_rsrq = 5;
inline bool flex_measurement_info::has_filter_coefficient_rsrq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void flex_measurement_info::set_has_filter_coefficient_rsrq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void flex_measurement_info::clear_has_filter_coefficient_rsrq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void flex_measurement_info::clear_filter_coefficient_rsrq() {
  filter_coefficient_rsrq_ = GOOGLE_LONGLONG(0);
  clear_has_filter_coefficient_rsrq();
}
inline ::google::protobuf::int64 flex_measurement_info::filter_coefficient_rsrq() const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_info.filter_coefficient_rsrq)
  return filter_coefficient_rsrq_;
}
inline void flex_measurement_info::set_filter_coefficient_rsrq(::google::protobuf::int64 value) {
  set_has_filter_coefficient_rsrq();
  filter_coefficient_rsrq_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_measurement_info.filter_coefficient_rsrq)
}

// optional .protocol.flex_measurement_event event = 6;
inline bool flex_measurement_info::has_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_measurement_info::set_has_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_measurement_info::clear_has_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_measurement_info::clear_event() {
  if (event_ != NULL) event_->::protocol::flex_measurement_event::Clear();
  clear_has_event();
}
inline const ::protocol::flex_measurement_event& flex_measurement_info::event() const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_info.event)
  return event_ != NULL ? *event_
                         : *::protocol::flex_measurement_event::internal_default_instance();
}
inline ::protocol::flex_measurement_event* flex_measurement_info::mutable_event() {
  set_has_event();
  if (event_ == NULL) {
    event_ = new ::protocol::flex_measurement_event;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_measurement_info.event)
  return event_;
}
inline ::protocol::flex_measurement_event* flex_measurement_info::release_event() {
  // @@protoc_insertion_point(field_release:protocol.flex_measurement_info.event)
  clear_has_event();
  ::protocol::flex_measurement_event* temp = event_;
  event_ = NULL;
  return temp;
}
inline void flex_measurement_info::set_allocated_event(::protocol::flex_measurement_event* event) {
  delete event_;
  event_ = event;
  if (event) {
    set_has_event();
  } else {
    clear_has_event();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_measurement_info.event)
}

// -------------------------------------------------------------------

// flex_measurement_event

// optional .protocol.flex_per_event periodical = 1;
inline bool flex_measurement_event::has_periodical() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_measurement_event::set_has_periodical() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_measurement_event::clear_has_periodical() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_measurement_event::clear_periodical() {
  if (periodical_ != NULL) periodical_->::protocol::flex_per_event::Clear();
  clear_has_periodical();
}
inline const ::protocol::flex_per_event& flex_measurement_event::periodical() const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_event.periodical)
  return periodical_ != NULL ? *periodical_
                         : *::protocol::flex_per_event::internal_default_instance();
}
inline ::protocol::flex_per_event* flex_measurement_event::mutable_periodical() {
  set_has_periodical();
  if (periodical_ == NULL) {
    periodical_ = new ::protocol::flex_per_event;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_measurement_event.periodical)
  return periodical_;
}
inline ::protocol::flex_per_event* flex_measurement_event::release_periodical() {
  // @@protoc_insertion_point(field_release:protocol.flex_measurement_event.periodical)
  clear_has_periodical();
  ::protocol::flex_per_event* temp = periodical_;
  periodical_ = NULL;
  return temp;
}
inline void flex_measurement_event::set_allocated_periodical(::protocol::flex_per_event* periodical) {
  delete periodical_;
  periodical_ = periodical;
  if (periodical) {
    set_has_periodical();
  } else {
    clear_has_periodical();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_measurement_event.periodical)
}

// optional .protocol.flex_a1_event a1 = 2;
inline bool flex_measurement_event::has_a1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_measurement_event::set_has_a1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_measurement_event::clear_has_a1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_measurement_event::clear_a1() {
  if (a1_ != NULL) a1_->::protocol::flex_a1_event::Clear();
  clear_has_a1();
}
inline const ::protocol::flex_a1_event& flex_measurement_event::a1() const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_event.a1)
  return a1_ != NULL ? *a1_
                         : *::protocol::flex_a1_event::internal_default_instance();
}
inline ::protocol::flex_a1_event* flex_measurement_event::mutable_a1() {
  set_has_a1();
  if (a1_ == NULL) {
    a1_ = new ::protocol::flex_a1_event;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_measurement_event.a1)
  return a1_;
}
inline ::protocol::flex_a1_event* flex_measurement_event::release_a1() {
  // @@protoc_insertion_point(field_release:protocol.flex_measurement_event.a1)
  clear_has_a1();
  ::protocol::flex_a1_event* temp = a1_;
  a1_ = NULL;
  return temp;
}
inline void flex_measurement_event::set_allocated_a1(::protocol::flex_a1_event* a1) {
  delete a1_;
  a1_ = a1;
  if (a1) {
    set_has_a1();
  } else {
    clear_has_a1();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_measurement_event.a1)
}

// optional .protocol.flex_a2_event a2 = 3;
inline bool flex_measurement_event::has_a2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_measurement_event::set_has_a2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_measurement_event::clear_has_a2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_measurement_event::clear_a2() {
  if (a2_ != NULL) a2_->::protocol::flex_a2_event::Clear();
  clear_has_a2();
}
inline const ::protocol::flex_a2_event& flex_measurement_event::a2() const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_event.a2)
  return a2_ != NULL ? *a2_
                         : *::protocol::flex_a2_event::internal_default_instance();
}
inline ::protocol::flex_a2_event* flex_measurement_event::mutable_a2() {
  set_has_a2();
  if (a2_ == NULL) {
    a2_ = new ::protocol::flex_a2_event;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_measurement_event.a2)
  return a2_;
}
inline ::protocol::flex_a2_event* flex_measurement_event::release_a2() {
  // @@protoc_insertion_point(field_release:protocol.flex_measurement_event.a2)
  clear_has_a2();
  ::protocol::flex_a2_event* temp = a2_;
  a2_ = NULL;
  return temp;
}
inline void flex_measurement_event::set_allocated_a2(::protocol::flex_a2_event* a2) {
  delete a2_;
  a2_ = a2;
  if (a2) {
    set_has_a2();
  } else {
    clear_has_a2();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_measurement_event.a2)
}

// optional .protocol.flex_a3_event a3 = 4;
inline bool flex_measurement_event::has_a3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_measurement_event::set_has_a3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_measurement_event::clear_has_a3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_measurement_event::clear_a3() {
  if (a3_ != NULL) a3_->::protocol::flex_a3_event::Clear();
  clear_has_a3();
}
inline const ::protocol::flex_a3_event& flex_measurement_event::a3() const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_event.a3)
  return a3_ != NULL ? *a3_
                         : *::protocol::flex_a3_event::internal_default_instance();
}
inline ::protocol::flex_a3_event* flex_measurement_event::mutable_a3() {
  set_has_a3();
  if (a3_ == NULL) {
    a3_ = new ::protocol::flex_a3_event;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_measurement_event.a3)
  return a3_;
}
inline ::protocol::flex_a3_event* flex_measurement_event::release_a3() {
  // @@protoc_insertion_point(field_release:protocol.flex_measurement_event.a3)
  clear_has_a3();
  ::protocol::flex_a3_event* temp = a3_;
  a3_ = NULL;
  return temp;
}
inline void flex_measurement_event::set_allocated_a3(::protocol::flex_a3_event* a3) {
  delete a3_;
  a3_ = a3;
  if (a3) {
    set_has_a3();
  } else {
    clear_has_a3();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_measurement_event.a3)
}

// optional .protocol.flex_a4_event a4 = 5;
inline bool flex_measurement_event::has_a4() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void flex_measurement_event::set_has_a4() {
  _has_bits_[0] |= 0x00000010u;
}
inline void flex_measurement_event::clear_has_a4() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void flex_measurement_event::clear_a4() {
  if (a4_ != NULL) a4_->::protocol::flex_a4_event::Clear();
  clear_has_a4();
}
inline const ::protocol::flex_a4_event& flex_measurement_event::a4() const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_event.a4)
  return a4_ != NULL ? *a4_
                         : *::protocol::flex_a4_event::internal_default_instance();
}
inline ::protocol::flex_a4_event* flex_measurement_event::mutable_a4() {
  set_has_a4();
  if (a4_ == NULL) {
    a4_ = new ::protocol::flex_a4_event;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_measurement_event.a4)
  return a4_;
}
inline ::protocol::flex_a4_event* flex_measurement_event::release_a4() {
  // @@protoc_insertion_point(field_release:protocol.flex_measurement_event.a4)
  clear_has_a4();
  ::protocol::flex_a4_event* temp = a4_;
  a4_ = NULL;
  return temp;
}
inline void flex_measurement_event::set_allocated_a4(::protocol::flex_a4_event* a4) {
  delete a4_;
  a4_ = a4;
  if (a4) {
    set_has_a4();
  } else {
    clear_has_a4();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_measurement_event.a4)
}

// optional .protocol.flex_a5_event a5 = 6;
inline bool flex_measurement_event::has_a5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void flex_measurement_event::set_has_a5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void flex_measurement_event::clear_has_a5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void flex_measurement_event::clear_a5() {
  if (a5_ != NULL) a5_->::protocol::flex_a5_event::Clear();
  clear_has_a5();
}
inline const ::protocol::flex_a5_event& flex_measurement_event::a5() const {
  // @@protoc_insertion_point(field_get:protocol.flex_measurement_event.a5)
  return a5_ != NULL ? *a5_
                         : *::protocol::flex_a5_event::internal_default_instance();
}
inline ::protocol::flex_a5_event* flex_measurement_event::mutable_a5() {
  set_has_a5();
  if (a5_ == NULL) {
    a5_ = new ::protocol::flex_a5_event;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_measurement_event.a5)
  return a5_;
}
inline ::protocol::flex_a5_event* flex_measurement_event::release_a5() {
  // @@protoc_insertion_point(field_release:protocol.flex_measurement_event.a5)
  clear_has_a5();
  ::protocol::flex_a5_event* temp = a5_;
  a5_ = NULL;
  return temp;
}
inline void flex_measurement_event::set_allocated_a5(::protocol::flex_a5_event* a5) {
  delete a5_;
  a5_ = a5;
  if (a5) {
    set_has_a5();
  } else {
    clear_has_a5();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_measurement_event.a5)
}

// -------------------------------------------------------------------

// flex_per_event

// optional int64 max_report_cells = 1;
inline bool flex_per_event::has_max_report_cells() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_per_event::set_has_max_report_cells() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_per_event::clear_has_max_report_cells() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_per_event::clear_max_report_cells() {
  max_report_cells_ = GOOGLE_LONGLONG(0);
  clear_has_max_report_cells();
}
inline ::google::protobuf::int64 flex_per_event::max_report_cells() const {
  // @@protoc_insertion_point(field_get:protocol.flex_per_event.max_report_cells)
  return max_report_cells_;
}
inline void flex_per_event::set_max_report_cells(::google::protobuf::int64 value) {
  set_has_max_report_cells();
  max_report_cells_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_per_event.max_report_cells)
}

// -------------------------------------------------------------------

// flex_a1_event

// optional int64 threshold_rsrp = 1;
inline bool flex_a1_event::has_threshold_rsrp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_a1_event::set_has_threshold_rsrp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_a1_event::clear_has_threshold_rsrp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_a1_event::clear_threshold_rsrp() {
  threshold_rsrp_ = GOOGLE_LONGLONG(0);
  clear_has_threshold_rsrp();
}
inline ::google::protobuf::int64 flex_a1_event::threshold_rsrp() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a1_event.threshold_rsrp)
  return threshold_rsrp_;
}
inline void flex_a1_event::set_threshold_rsrp(::google::protobuf::int64 value) {
  set_has_threshold_rsrp();
  threshold_rsrp_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a1_event.threshold_rsrp)
}

// optional int64 hysteresis = 2;
inline bool flex_a1_event::has_hysteresis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_a1_event::set_has_hysteresis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_a1_event::clear_has_hysteresis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_a1_event::clear_hysteresis() {
  hysteresis_ = GOOGLE_LONGLONG(0);
  clear_has_hysteresis();
}
inline ::google::protobuf::int64 flex_a1_event::hysteresis() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a1_event.hysteresis)
  return hysteresis_;
}
inline void flex_a1_event::set_hysteresis(::google::protobuf::int64 value) {
  set_has_hysteresis();
  hysteresis_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a1_event.hysteresis)
}

// optional int64 time_to_trigger = 3;
inline bool flex_a1_event::has_time_to_trigger() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_a1_event::set_has_time_to_trigger() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_a1_event::clear_has_time_to_trigger() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_a1_event::clear_time_to_trigger() {
  time_to_trigger_ = GOOGLE_LONGLONG(0);
  clear_has_time_to_trigger();
}
inline ::google::protobuf::int64 flex_a1_event::time_to_trigger() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a1_event.time_to_trigger)
  return time_to_trigger_;
}
inline void flex_a1_event::set_time_to_trigger(::google::protobuf::int64 value) {
  set_has_time_to_trigger();
  time_to_trigger_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a1_event.time_to_trigger)
}

// optional int64 max_report_cells = 4;
inline bool flex_a1_event::has_max_report_cells() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_a1_event::set_has_max_report_cells() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_a1_event::clear_has_max_report_cells() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_a1_event::clear_max_report_cells() {
  max_report_cells_ = GOOGLE_LONGLONG(0);
  clear_has_max_report_cells();
}
inline ::google::protobuf::int64 flex_a1_event::max_report_cells() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a1_event.max_report_cells)
  return max_report_cells_;
}
inline void flex_a1_event::set_max_report_cells(::google::protobuf::int64 value) {
  set_has_max_report_cells();
  max_report_cells_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a1_event.max_report_cells)
}

// -------------------------------------------------------------------

// flex_a2_event

// optional int64 threshold_rsrp = 1;
inline bool flex_a2_event::has_threshold_rsrp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_a2_event::set_has_threshold_rsrp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_a2_event::clear_has_threshold_rsrp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_a2_event::clear_threshold_rsrp() {
  threshold_rsrp_ = GOOGLE_LONGLONG(0);
  clear_has_threshold_rsrp();
}
inline ::google::protobuf::int64 flex_a2_event::threshold_rsrp() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a2_event.threshold_rsrp)
  return threshold_rsrp_;
}
inline void flex_a2_event::set_threshold_rsrp(::google::protobuf::int64 value) {
  set_has_threshold_rsrp();
  threshold_rsrp_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a2_event.threshold_rsrp)
}

// optional int64 hysteresis = 2;
inline bool flex_a2_event::has_hysteresis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_a2_event::set_has_hysteresis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_a2_event::clear_has_hysteresis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_a2_event::clear_hysteresis() {
  hysteresis_ = GOOGLE_LONGLONG(0);
  clear_has_hysteresis();
}
inline ::google::protobuf::int64 flex_a2_event::hysteresis() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a2_event.hysteresis)
  return hysteresis_;
}
inline void flex_a2_event::set_hysteresis(::google::protobuf::int64 value) {
  set_has_hysteresis();
  hysteresis_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a2_event.hysteresis)
}

// optional int64 time_to_trigger = 3;
inline bool flex_a2_event::has_time_to_trigger() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_a2_event::set_has_time_to_trigger() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_a2_event::clear_has_time_to_trigger() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_a2_event::clear_time_to_trigger() {
  time_to_trigger_ = GOOGLE_LONGLONG(0);
  clear_has_time_to_trigger();
}
inline ::google::protobuf::int64 flex_a2_event::time_to_trigger() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a2_event.time_to_trigger)
  return time_to_trigger_;
}
inline void flex_a2_event::set_time_to_trigger(::google::protobuf::int64 value) {
  set_has_time_to_trigger();
  time_to_trigger_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a2_event.time_to_trigger)
}

// optional int64 max_report_cells = 4;
inline bool flex_a2_event::has_max_report_cells() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_a2_event::set_has_max_report_cells() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_a2_event::clear_has_max_report_cells() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_a2_event::clear_max_report_cells() {
  max_report_cells_ = GOOGLE_LONGLONG(0);
  clear_has_max_report_cells();
}
inline ::google::protobuf::int64 flex_a2_event::max_report_cells() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a2_event.max_report_cells)
  return max_report_cells_;
}
inline void flex_a2_event::set_max_report_cells(::google::protobuf::int64 value) {
  set_has_max_report_cells();
  max_report_cells_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a2_event.max_report_cells)
}

// -------------------------------------------------------------------

// flex_a3_event

// optional int64 a3_offset = 1;
inline bool flex_a3_event::has_a3_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_a3_event::set_has_a3_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_a3_event::clear_has_a3_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_a3_event::clear_a3_offset() {
  a3_offset_ = GOOGLE_LONGLONG(0);
  clear_has_a3_offset();
}
inline ::google::protobuf::int64 flex_a3_event::a3_offset() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a3_event.a3_offset)
  return a3_offset_;
}
inline void flex_a3_event::set_a3_offset(::google::protobuf::int64 value) {
  set_has_a3_offset();
  a3_offset_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a3_event.a3_offset)
}

// optional int32 report_on_leave = 2;
inline bool flex_a3_event::has_report_on_leave() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void flex_a3_event::set_has_report_on_leave() {
  _has_bits_[0] |= 0x00000010u;
}
inline void flex_a3_event::clear_has_report_on_leave() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void flex_a3_event::clear_report_on_leave() {
  report_on_leave_ = 0;
  clear_has_report_on_leave();
}
inline ::google::protobuf::int32 flex_a3_event::report_on_leave() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a3_event.report_on_leave)
  return report_on_leave_;
}
inline void flex_a3_event::set_report_on_leave(::google::protobuf::int32 value) {
  set_has_report_on_leave();
  report_on_leave_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a3_event.report_on_leave)
}

// optional int64 hysteresis = 3;
inline bool flex_a3_event::has_hysteresis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_a3_event::set_has_hysteresis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_a3_event::clear_has_hysteresis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_a3_event::clear_hysteresis() {
  hysteresis_ = GOOGLE_LONGLONG(0);
  clear_has_hysteresis();
}
inline ::google::protobuf::int64 flex_a3_event::hysteresis() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a3_event.hysteresis)
  return hysteresis_;
}
inline void flex_a3_event::set_hysteresis(::google::protobuf::int64 value) {
  set_has_hysteresis();
  hysteresis_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a3_event.hysteresis)
}

// optional int64 time_to_trigger = 4;
inline bool flex_a3_event::has_time_to_trigger() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_a3_event::set_has_time_to_trigger() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_a3_event::clear_has_time_to_trigger() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_a3_event::clear_time_to_trigger() {
  time_to_trigger_ = GOOGLE_LONGLONG(0);
  clear_has_time_to_trigger();
}
inline ::google::protobuf::int64 flex_a3_event::time_to_trigger() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a3_event.time_to_trigger)
  return time_to_trigger_;
}
inline void flex_a3_event::set_time_to_trigger(::google::protobuf::int64 value) {
  set_has_time_to_trigger();
  time_to_trigger_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a3_event.time_to_trigger)
}

// optional int64 max_report_cells = 5;
inline bool flex_a3_event::has_max_report_cells() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_a3_event::set_has_max_report_cells() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_a3_event::clear_has_max_report_cells() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_a3_event::clear_max_report_cells() {
  max_report_cells_ = GOOGLE_LONGLONG(0);
  clear_has_max_report_cells();
}
inline ::google::protobuf::int64 flex_a3_event::max_report_cells() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a3_event.max_report_cells)
  return max_report_cells_;
}
inline void flex_a3_event::set_max_report_cells(::google::protobuf::int64 value) {
  set_has_max_report_cells();
  max_report_cells_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a3_event.max_report_cells)
}

// -------------------------------------------------------------------

// flex_a4_event

// optional int64 threshold_rsrp = 1;
inline bool flex_a4_event::has_threshold_rsrp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_a4_event::set_has_threshold_rsrp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_a4_event::clear_has_threshold_rsrp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_a4_event::clear_threshold_rsrp() {
  threshold_rsrp_ = GOOGLE_LONGLONG(0);
  clear_has_threshold_rsrp();
}
inline ::google::protobuf::int64 flex_a4_event::threshold_rsrp() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a4_event.threshold_rsrp)
  return threshold_rsrp_;
}
inline void flex_a4_event::set_threshold_rsrp(::google::protobuf::int64 value) {
  set_has_threshold_rsrp();
  threshold_rsrp_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a4_event.threshold_rsrp)
}

// optional int64 hysteresis = 2;
inline bool flex_a4_event::has_hysteresis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_a4_event::set_has_hysteresis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_a4_event::clear_has_hysteresis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_a4_event::clear_hysteresis() {
  hysteresis_ = GOOGLE_LONGLONG(0);
  clear_has_hysteresis();
}
inline ::google::protobuf::int64 flex_a4_event::hysteresis() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a4_event.hysteresis)
  return hysteresis_;
}
inline void flex_a4_event::set_hysteresis(::google::protobuf::int64 value) {
  set_has_hysteresis();
  hysteresis_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a4_event.hysteresis)
}

// optional int64 time_to_trigger = 3;
inline bool flex_a4_event::has_time_to_trigger() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_a4_event::set_has_time_to_trigger() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_a4_event::clear_has_time_to_trigger() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_a4_event::clear_time_to_trigger() {
  time_to_trigger_ = GOOGLE_LONGLONG(0);
  clear_has_time_to_trigger();
}
inline ::google::protobuf::int64 flex_a4_event::time_to_trigger() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a4_event.time_to_trigger)
  return time_to_trigger_;
}
inline void flex_a4_event::set_time_to_trigger(::google::protobuf::int64 value) {
  set_has_time_to_trigger();
  time_to_trigger_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a4_event.time_to_trigger)
}

// optional int64 max_report_cells = 4;
inline bool flex_a4_event::has_max_report_cells() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_a4_event::set_has_max_report_cells() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_a4_event::clear_has_max_report_cells() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_a4_event::clear_max_report_cells() {
  max_report_cells_ = GOOGLE_LONGLONG(0);
  clear_has_max_report_cells();
}
inline ::google::protobuf::int64 flex_a4_event::max_report_cells() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a4_event.max_report_cells)
  return max_report_cells_;
}
inline void flex_a4_event::set_max_report_cells(::google::protobuf::int64 value) {
  set_has_max_report_cells();
  max_report_cells_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a4_event.max_report_cells)
}

// -------------------------------------------------------------------

// flex_a5_event

// optional int64 threshold_rsrp_1 = 1;
inline bool flex_a5_event::has_threshold_rsrp_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_a5_event::set_has_threshold_rsrp_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_a5_event::clear_has_threshold_rsrp_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_a5_event::clear_threshold_rsrp_1() {
  threshold_rsrp_1_ = GOOGLE_LONGLONG(0);
  clear_has_threshold_rsrp_1();
}
inline ::google::protobuf::int64 flex_a5_event::threshold_rsrp_1() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a5_event.threshold_rsrp_1)
  return threshold_rsrp_1_;
}
inline void flex_a5_event::set_threshold_rsrp_1(::google::protobuf::int64 value) {
  set_has_threshold_rsrp_1();
  threshold_rsrp_1_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a5_event.threshold_rsrp_1)
}

// optional int64 threshold_rsrp_2 = 2;
inline bool flex_a5_event::has_threshold_rsrp_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_a5_event::set_has_threshold_rsrp_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_a5_event::clear_has_threshold_rsrp_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_a5_event::clear_threshold_rsrp_2() {
  threshold_rsrp_2_ = GOOGLE_LONGLONG(0);
  clear_has_threshold_rsrp_2();
}
inline ::google::protobuf::int64 flex_a5_event::threshold_rsrp_2() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a5_event.threshold_rsrp_2)
  return threshold_rsrp_2_;
}
inline void flex_a5_event::set_threshold_rsrp_2(::google::protobuf::int64 value) {
  set_has_threshold_rsrp_2();
  threshold_rsrp_2_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a5_event.threshold_rsrp_2)
}

// optional int64 hysteresis = 3;
inline bool flex_a5_event::has_hysteresis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_a5_event::set_has_hysteresis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_a5_event::clear_has_hysteresis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_a5_event::clear_hysteresis() {
  hysteresis_ = GOOGLE_LONGLONG(0);
  clear_has_hysteresis();
}
inline ::google::protobuf::int64 flex_a5_event::hysteresis() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a5_event.hysteresis)
  return hysteresis_;
}
inline void flex_a5_event::set_hysteresis(::google::protobuf::int64 value) {
  set_has_hysteresis();
  hysteresis_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a5_event.hysteresis)
}

// optional int64 time_to_trigger = 4;
inline bool flex_a5_event::has_time_to_trigger() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_a5_event::set_has_time_to_trigger() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_a5_event::clear_has_time_to_trigger() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_a5_event::clear_time_to_trigger() {
  time_to_trigger_ = GOOGLE_LONGLONG(0);
  clear_has_time_to_trigger();
}
inline ::google::protobuf::int64 flex_a5_event::time_to_trigger() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a5_event.time_to_trigger)
  return time_to_trigger_;
}
inline void flex_a5_event::set_time_to_trigger(::google::protobuf::int64 value) {
  set_has_time_to_trigger();
  time_to_trigger_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a5_event.time_to_trigger)
}

// optional int64 max_report_cells = 5;
inline bool flex_a5_event::has_max_report_cells() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void flex_a5_event::set_has_max_report_cells() {
  _has_bits_[0] |= 0x00000010u;
}
inline void flex_a5_event::clear_has_max_report_cells() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void flex_a5_event::clear_max_report_cells() {
  max_report_cells_ = GOOGLE_LONGLONG(0);
  clear_has_max_report_cells();
}
inline ::google::protobuf::int64 flex_a5_event::max_report_cells() const {
  // @@protoc_insertion_point(field_get:protocol.flex_a5_event.max_report_cells)
  return max_report_cells_;
}
inline void flex_a5_event::set_max_report_cells(::google::protobuf::int64 value) {
  set_has_max_report_cells();
  max_report_cells_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_a5_event.max_report_cells)
}

// -------------------------------------------------------------------

// flex_gummei

// optional .protocol.flex_plmn plmn = 1;
inline bool flex_gummei::has_plmn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_gummei::set_has_plmn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_gummei::clear_has_plmn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_gummei::clear_plmn() {
  if (plmn_ != NULL) plmn_->::protocol::flex_plmn::Clear();
  clear_has_plmn();
}
inline const ::protocol::flex_plmn& flex_gummei::plmn() const {
  // @@protoc_insertion_point(field_get:protocol.flex_gummei.plmn)
  return plmn_ != NULL ? *plmn_
                         : *::protocol::flex_plmn::internal_default_instance();
}
inline ::protocol::flex_plmn* flex_gummei::mutable_plmn() {
  set_has_plmn();
  if (plmn_ == NULL) {
    plmn_ = new ::protocol::flex_plmn;
  }
  // @@protoc_insertion_point(field_mutable:protocol.flex_gummei.plmn)
  return plmn_;
}
inline ::protocol::flex_plmn* flex_gummei::release_plmn() {
  // @@protoc_insertion_point(field_release:protocol.flex_gummei.plmn)
  clear_has_plmn();
  ::protocol::flex_plmn* temp = plmn_;
  plmn_ = NULL;
  return temp;
}
inline void flex_gummei::set_allocated_plmn(::protocol::flex_plmn* plmn) {
  delete plmn_;
  plmn_ = plmn;
  if (plmn) {
    set_has_plmn();
  } else {
    clear_has_plmn();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_gummei.plmn)
}

// optional uint32 mme_group_id = 2;
inline bool flex_gummei::has_mme_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_gummei::set_has_mme_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_gummei::clear_has_mme_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_gummei::clear_mme_group_id() {
  mme_group_id_ = 0u;
  clear_has_mme_group_id();
}
inline ::google::protobuf::uint32 flex_gummei::mme_group_id() const {
  // @@protoc_insertion_point(field_get:protocol.flex_gummei.mme_group_id)
  return mme_group_id_;
}
inline void flex_gummei::set_mme_group_id(::google::protobuf::uint32 value) {
  set_has_mme_group_id();
  mme_group_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_gummei.mme_group_id)
}

// optional uint32 mme_code = 3;
inline bool flex_gummei::has_mme_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_gummei::set_has_mme_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_gummei::clear_has_mme_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_gummei::clear_mme_code() {
  mme_code_ = 0u;
  clear_has_mme_code();
}
inline ::google::protobuf::uint32 flex_gummei::mme_code() const {
  // @@protoc_insertion_point(field_get:protocol.flex_gummei.mme_code)
  return mme_code_;
}
inline void flex_gummei::set_mme_code(::google::protobuf::uint32 value) {
  set_has_mme_code();
  mme_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_gummei.mme_code)
}

// -------------------------------------------------------------------

// flex_s1ap_mme

// optional string s1_ip = 1;
inline bool flex_s1ap_mme::has_s1_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void flex_s1ap_mme::set_has_s1_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void flex_s1ap_mme::clear_has_s1_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void flex_s1ap_mme::clear_s1_ip() {
  s1_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s1_ip();
}
inline const ::std::string& flex_s1ap_mme::s1_ip() const {
  // @@protoc_insertion_point(field_get:protocol.flex_s1ap_mme.s1_ip)
  return s1_ip_.GetNoArena();
}
inline void flex_s1ap_mme::set_s1_ip(const ::std::string& value) {
  set_has_s1_ip();
  s1_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.flex_s1ap_mme.s1_ip)
}
#if LANG_CXX11
inline void flex_s1ap_mme::set_s1_ip(::std::string&& value) {
  set_has_s1_ip();
  s1_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_s1ap_mme.s1_ip)
}
#endif
inline void flex_s1ap_mme::set_s1_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s1_ip();
  s1_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.flex_s1ap_mme.s1_ip)
}
inline void flex_s1ap_mme::set_s1_ip(const char* value, size_t size) {
  set_has_s1_ip();
  s1_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_s1ap_mme.s1_ip)
}
inline ::std::string* flex_s1ap_mme::mutable_s1_ip() {
  set_has_s1_ip();
  // @@protoc_insertion_point(field_mutable:protocol.flex_s1ap_mme.s1_ip)
  return s1_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* flex_s1ap_mme::release_s1_ip() {
  // @@protoc_insertion_point(field_release:protocol.flex_s1ap_mme.s1_ip)
  clear_has_s1_ip();
  return s1_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void flex_s1ap_mme::set_allocated_s1_ip(::std::string* s1_ip) {
  if (s1_ip != NULL) {
    set_has_s1_ip();
  } else {
    clear_has_s1_ip();
  }
  s1_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s1_ip);
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_s1ap_mme.s1_ip)
}

// optional string name = 2;
inline bool flex_s1ap_mme::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void flex_s1ap_mme::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void flex_s1ap_mme::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void flex_s1ap_mme::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& flex_s1ap_mme::name() const {
  // @@protoc_insertion_point(field_get:protocol.flex_s1ap_mme.name)
  return name_.GetNoArena();
}
inline void flex_s1ap_mme::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.flex_s1ap_mme.name)
}
#if LANG_CXX11
inline void flex_s1ap_mme::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.flex_s1ap_mme.name)
}
#endif
inline void flex_s1ap_mme::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.flex_s1ap_mme.name)
}
inline void flex_s1ap_mme::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.flex_s1ap_mme.name)
}
inline ::std::string* flex_s1ap_mme::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:protocol.flex_s1ap_mme.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* flex_s1ap_mme::release_name() {
  // @@protoc_insertion_point(field_release:protocol.flex_s1ap_mme.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void flex_s1ap_mme::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:protocol.flex_s1ap_mme.name)
}

// optional .protocol.flex_mme_state state = 3;
inline bool flex_s1ap_mme::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void flex_s1ap_mme::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void flex_s1ap_mme::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void flex_s1ap_mme::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::protocol::flex_mme_state flex_s1ap_mme::state() const {
  // @@protoc_insertion_point(field_get:protocol.flex_s1ap_mme.state)
  return static_cast< ::protocol::flex_mme_state >(state_);
}
inline void flex_s1ap_mme::set_state(::protocol::flex_mme_state value) {
  assert(::protocol::flex_mme_state_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_s1ap_mme.state)
}

// repeated .protocol.flex_gummei served_gummeis = 4;
inline int flex_s1ap_mme::served_gummeis_size() const {
  return served_gummeis_.size();
}
inline void flex_s1ap_mme::clear_served_gummeis() {
  served_gummeis_.Clear();
}
inline const ::protocol::flex_gummei& flex_s1ap_mme::served_gummeis(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_s1ap_mme.served_gummeis)
  return served_gummeis_.Get(index);
}
inline ::protocol::flex_gummei* flex_s1ap_mme::mutable_served_gummeis(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_s1ap_mme.served_gummeis)
  return served_gummeis_.Mutable(index);
}
inline ::protocol::flex_gummei* flex_s1ap_mme::add_served_gummeis() {
  // @@protoc_insertion_point(field_add:protocol.flex_s1ap_mme.served_gummeis)
  return served_gummeis_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_gummei >*
flex_s1ap_mme::mutable_served_gummeis() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_s1ap_mme.served_gummeis)
  return &served_gummeis_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_gummei >&
flex_s1ap_mme::served_gummeis() const {
  // @@protoc_insertion_point(field_list:protocol.flex_s1ap_mme.served_gummeis)
  return served_gummeis_;
}

// repeated .protocol.flex_plmn requested_plmns = 5;
inline int flex_s1ap_mme::requested_plmns_size() const {
  return requested_plmns_.size();
}
inline void flex_s1ap_mme::clear_requested_plmns() {
  requested_plmns_.Clear();
}
inline const ::protocol::flex_plmn& flex_s1ap_mme::requested_plmns(int index) const {
  // @@protoc_insertion_point(field_get:protocol.flex_s1ap_mme.requested_plmns)
  return requested_plmns_.Get(index);
}
inline ::protocol::flex_plmn* flex_s1ap_mme::mutable_requested_plmns(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.flex_s1ap_mme.requested_plmns)
  return requested_plmns_.Mutable(index);
}
inline ::protocol::flex_plmn* flex_s1ap_mme::add_requested_plmns() {
  // @@protoc_insertion_point(field_add:protocol.flex_s1ap_mme.requested_plmns)
  return requested_plmns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::flex_plmn >*
flex_s1ap_mme::mutable_requested_plmns() {
  // @@protoc_insertion_point(field_mutable_list:protocol.flex_s1ap_mme.requested_plmns)
  return &requested_plmns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::flex_plmn >&
flex_s1ap_mme::requested_plmns() const {
  // @@protoc_insertion_point(field_list:protocol.flex_s1ap_mme.requested_plmns)
  return requested_plmns_;
}

// optional uint32 rel_capacity = 6;
inline bool flex_s1ap_mme::has_rel_capacity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void flex_s1ap_mme::set_has_rel_capacity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void flex_s1ap_mme::clear_has_rel_capacity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void flex_s1ap_mme::clear_rel_capacity() {
  rel_capacity_ = 0u;
  clear_has_rel_capacity();
}
inline ::google::protobuf::uint32 flex_s1ap_mme::rel_capacity() const {
  // @@protoc_insertion_point(field_get:protocol.flex_s1ap_mme.rel_capacity)
  return rel_capacity_;
}
inline void flex_s1ap_mme::set_rel_capacity(::google::protobuf::uint32 value) {
  set_has_rel_capacity();
  rel_capacity_ = value;
  // @@protoc_insertion_point(field_set:protocol.flex_s1ap_mme.rel_capacity)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace protocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::flex_hopping_mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_hopping_mode>() {
  return ::protocol::flex_hopping_mode_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_phich_resource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_phich_resource>() {
  return ::protocol::flex_phich_resource_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_phich_duration> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_phich_duration>() {
  return ::protocol::flex_phich_duration_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_ul_cyclic_prefix_length> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_ul_cyclic_prefix_length>() {
  return ::protocol::flex_ul_cyclic_prefix_length_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_dl_cyclic_prefix_length> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_dl_cyclic_prefix_length>() {
  return ::protocol::flex_dl_cyclic_prefix_length_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_duplex_mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_duplex_mode>() {
  return ::protocol::flex_duplex_mode_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_qam> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_qam>() {
  return ::protocol::flex_qam_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_slice_algorithm> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_slice_algorithm>() {
  return ::protocol::flex_slice_algorithm_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_meas_gap_config_pattern> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_meas_gap_config_pattern>() {
  return ::protocol::flex_meas_gap_config_pattern_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_setup_release_action> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_setup_release_action>() {
  return ::protocol::flex_setup_release_action_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_ue_transmission_antenna> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_ue_transmission_antenna>() {
  return ::protocol::flex_ue_transmission_antenna_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_aperiodic_cqi_report_mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_aperiodic_cqi_report_mode>() {
  return ::protocol::flex_aperiodic_cqi_report_mode_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_tdd_ack_nack_feedback_mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_tdd_ack_nack_feedback_mode>() {
  return ::protocol::flex_tdd_ack_nack_feedback_mode_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_lc_direction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_lc_direction>() {
  return ::protocol::flex_lc_direction_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_qos_bearer_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_qos_bearer_type>() {
  return ::protocol::flex_qos_bearer_type_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_ue_state_change_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_ue_state_change_type>() {
  return ::protocol::flex_ue_state_change_type_descriptor();
}
template <> struct is_proto_enum< ::protocol::flex_mme_state> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::flex_mme_state>() {
  return ::protocol::flex_mme_state_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_config_5fcommon_2eproto__INCLUDED
